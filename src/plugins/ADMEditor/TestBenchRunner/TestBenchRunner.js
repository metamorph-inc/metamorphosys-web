//noinspection JSLint
/**
* Generated by PluginGenerator from webgme on Thu May 22 2014 22:27:57 GMT-0500 (Central Daylight Time).
*/

define(['plugin/PluginConfig',
        'plugin/PluginBase',
        'plugin/TestBenchRunner/TestBenchRunner/meta',
        'plugin/TestBenchRunner/TestBenchRunner/Templates/Templates',
        'plugin/AdmExporter/AdmExporter/AdmExporter',
        'xmljsonconverter',
        'executor/ExecutorClient',
        'ejs'], function (PluginConfig, PluginBase, MetaTypes, TEMPLATES, AdmExporter, Converter, ExecutorClient, ejs) {
    'use strict';
//<editor-fold desc="============================ Class Definition ================================">
    /**
    * Initializes a new instance of TestBenchRunner.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin TestBenchRunner.
    * @constructor
    */
    var TestBenchRunner = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.meta = MetaTypes;
        this.referencedDesign = null;
        this.multiRun = false;
        // Execution frame-work.
        this.runExecution = false;
        this.run_exec_cmd = null;
        this.exec_py = null;
        this.executorClient = null;
        this.dashboardResults = [];
        this.projectManifest = null;
        this.metaResults = null;
        this.designNameToDesignId = {};
        // AVM design format
        this.designAcmFiles = null;
        this.admData = null;
        this.admString = null;
        this.exportAtm = false;
        this.atms = [];

        this.admExporter = null;
    };

    // Prototypal inheritance from PluginBase.
    TestBenchRunner.prototype = Object.create(PluginBase.prototype);
    TestBenchRunner.prototype.constructor = TestBenchRunner;

    /**
    * Gets the name of the TestBenchRunner.
    * @returns {string} The name of the plugin.
    * @public
    */
    TestBenchRunner.prototype.getName = function () {
        return "Test bench runner";
    };

    /**
    * Gets the semantic version (semver.org) of the TestBenchRunner.
    * @returns {string} The version of the plugin.
    * @public
    */
    TestBenchRunner.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Gets the description of the TestBenchRunner.
    * @returns {string} The description of the plugin.
    * @public
    */
    TestBenchRunner.prototype.getDescription = function () {
        return "Exports the design and run the test-bench from where it is called.";
    };

    /**
    * Gets the configuration structure for the TestBenchRunner.
    * The ConfigurationStructure defines the configuration for the plugin
    * and will be used to populate the GUI when invoking the plugin from webGME.
    * @returns {object} The version of the plugin.
    * @public
    */
    TestBenchRunner.prototype.getConfigStructure = function () {
        return [
            {
                'name': 'run',
                'displayName': 'Run test-bench',
                'description': 'Will start a job and run the test-bench(es).',
                'value': false,
                'valueType': 'boolean',
                'readOnly': false
            }
//            {
//                'name': 'atmExport',
//                'displayName': 'Export ATM',
//                'description': 'Will export an ATM (no execution will take place).',
//                'value': false,
//                'valueType': 'boolean',
//                'readOnly': false
//            }
        ];
    };
//</editor-fold>

    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always has to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    TestBenchRunner.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            currentConfig = self.getCurrentConfig(),
            callMainCallback = function (error, totalSuccess) {
                self.mergeDashBoards(function (err) {
                    if (err) {
                        totalSuccess = false;
                        error += err;
                    }
                    self.result.setSuccess(totalSuccess);
                    self.save('Results for test-benches was updated after execution.', function (err) {
                        if (err) {
                            self.logger.error('Could not save result back to model.');
                            error += err;
                        }
                        if (error) {
                            self.result.setSuccess(false);
                            callback(error, self.result);
                        } else {
                            callback(null, self.result);
                        }
                    });
                });
            };

        if (!self.activeNode) {
            self.createMessage(null, 'Active node is not present! This happens sometimes... Loading another model ' +
                'and trying again will solve it most of times.', 'error');
            return callback('Active node is not present!', self.result);
        }
        self.multiRun = self.isMetaTypeOf(self.activeNode, self.META.ATMFolder);
        self.exportAtm = currentConfig.atmExport;
        self.runExecution = currentConfig.run;
        if ((self.isMetaTypeOf(self.activeNode, self.META.AVMTestBenchModel) || self.multiRun) === false) {
            self.createMessage(null, 'This plugin must be called from an AVMTestBenchModel or an ATMFolder.', 'error');
            return callback(null, self.result);
        }
        if (self.multiRun && self.exportAtm) {
            self.createMessage(null, 'Exportation of atms is not supported on ATMFolders.', 'error');
            return callback(null, self.result);
        }
        self.updateMETA(self.meta);

        if (self.multiRun) {
            self.getTestBenchInfos(self.activeNode, function (err, testBenchInfos) {
                var tbIDs = {},
                    tbID,
                    duplicateIDs = false,
                    j;
                if (err) {
                    self.logger.error(err);
                    self.createMessage(self.activeNode, 'Something went wrong when exploring the test-benches.', 'error');
                    return callback(null, self.result);
                }
                if (testBenchInfos.length === 0) {
                    self.createMessage(self.activeNode, 'No test-benches found in folder.', 'error');
                    return callback(null, self.result);
                }
                // Check if any test-benches share IDs.
                for (j = 0; j < testBenchInfos.length; j += 1) {
                    tbID = testBenchInfos[j].path;
                    if (tbIDs.hasOwnProperty(tbID)) {
                        self.createMessage(testBenchInfos[j].node, 'Test-bench IDs shared amongst test-benches. For ' +
                            ' multi-run the ID of each test-bench must be unique.', 'error');
                        self.createMessage(tbIDs[tbID], 'Test-bench has duplicate ID.', 'error');
                        duplicateIDs = true;
                    } else {
                        tbIDs[tbID] = testBenchInfos[j].node;
                    }
                }
                if (duplicateIDs) {
                    return callback(null, self.result);
                }
                self.logger.info('Got testBenchInfo about to explore referenced design..');
                self.getAdmAndAcms(self.referencedDesign, testBenchInfos, function (err) {
                    var i,
                        totalSuccess = true,
                        error = '',
                        counter = testBenchInfos.length,
                        counterCallback;
                    if (err) {
                        self.logger.error(err);
                        self.createMessage(self.referencedDesign, 'Something went wrong when exploring the referenced design.', 'error');
                        return callback(null, self.result);
                    }
                    self.logger.info('Done with calling AdmExporter - ADM and ACMs gathered.');
                    counterCallback = function (testBenchInfo) {
                        return function (err, artifact) {
                            if (err) {
                                error += err;
                                totalSuccess = false;
                            }
                            if (artifact) {
                                artifact.save(function (err, hash) {
                                    if (err) {
                                        error += err;
                                        totalSuccess = false;
                                    }
                                    self.logger.info('Saved exec-artifacts for test-bench "' + testBenchInfo.name + '"');
                                    self.result.addArtifact(hash);
                                    if (self.runExecution) {
                                        self.logger.info('About to execute job for "' + testBenchInfo.name + '".');
                                        self.executeJob(hash, testBenchInfo, function (err, success) {
                                            if (err) {
                                                error += err;
                                            }
                                            counter -= 1;
                                            self.logger.info('TotalSuccess updated from "' + totalSuccess.toString() +
                                                '" to "' + (totalSuccess && success).toString() + '".');
                                            totalSuccess = totalSuccess && success;
                                            if (counter <= 0) {
                                                self.logger.info('All executions are done - about to finish..');
                                                callMainCallback(error, totalSuccess);
                                            }
                                        });
                                    } else {
                                        counter -= 1;
                                        self.logger.info('Artifact added to result. No executions to run..');
                                        if (counter <= 0) {
                                            self.logger.info('All artifacts have been saved.');
                                            callMainCallback(error, totalSuccess);
                                        }
                                    }
                                });
                            } else {
                                self.logger.info('No artifact was generated for test-bench "' + testBenchInfo.name + '".');
                                counter -= 1;
                                if (counter <= 0) {
                                    self.logger.info('Last test-bench did not return an artifact.');
                                    callMainCallback(error, totalSuccess);
                                }
                            }
                        };
                    };
                    for (i = 0; i < testBenchInfos.length; i += 1) {
                        self.generateExecutionFiles(testBenchInfos[i], counterCallback(testBenchInfos[i]));
                    }
                });
            });
        } else {
            self.getTestBenchInfo(self.activeNode, function (err, testBenchInfo) {
                var artifact,
                    atmXmlStr,
                    jsonToXml = new Converter.Json2xml();
                if (err) {
                    self.logger.error('getTestBenchInfo returned with error: ' + err.toString());
                    self.createMessage(self.activeNode, 'Something went wrong when exploring the test-bench.', 'error');
                    return callback(null, self.result);
                }
                if (self.exportAtm) {
                    if (err) {
                        return callback(err, self.result);
                    }
                    artifact = self.blobClient.createArtifact('testBench');
                    atmXmlStr = jsonToXml.convertToString({TestBench: self.atms[0]});
                    artifact.addFile(self.atms[0]['@Name'] + '.atm', atmXmlStr, function (err, hash) {
                        if (err) {
                            return callback('Could not add adm file : err' + err.toString(), self.result);
                        }
                        self.logger.info('Added atm files to artifact, it has hash: ' + hash);
                        artifact.save(function (err, hash) {
                            if (err) {
                                return callback('Could not save atm artifact : err' + err.toString(), self.result);
                            }
                            self.result.addArtifact(hash);
                            self.result.setSuccess(true);
                            callback(null, self.result);
                        });
                    });
                } else {
                    self.getAdmAndAcms(self.referencedDesign, [testBenchInfo], function (err) {
                        if (err) {
                            self.logger.error(err);
                            self.createMessage(self.referencedDesign, 'Something went wrong when exploring the referenced design.', 'error');
                            return callback(null, self.result);
                        }
                        self.generateExecutionFiles(testBenchInfo, function (err, artifact) {
                            if (err) {
                                return callback('Could generateExecutionFiles : err' + err.toString(), self.result);
                            }
                            artifact.save(function (err, hash) {
                                if (err) {
                                    return callback('Could not save artifact : err' + err.toString(), self.result);
                                }
                                self.result.addArtifact(hash);
                                if (self.runExecution) {
                                    self.executeJob(hash, testBenchInfo, function (err, success) {
                                        self.result.setSuccess(success);
                                        self.save('Test-bench "' + testBenchInfo.name + '" results was updated after execution.', function (err) {
                                            callback(null, self.result);
                                        });
                                    });
                                } else {
                                    self.result.setSuccess(true);
                                    callback(null, self.result);
                                }
                            });
                        });
                    });
                }
            });
        }
    };

    TestBenchRunner.prototype.getTestBenchInfos = function (folderNode, callback) {
        var self = this;
        self.core.loadChildren(folderNode, function (err, children) {
            var counter, i,
                error = '',
                metaTypeName,
                childName,
                counterCallback,
                tbInfos = [];
            if (err) {
                return callback('loadChildren failed for folder with err:' + err.toString());
            }
            counter = children.length;
            counterCallback = function (err, tbInfo) {
                error = err ? error + err : error;
                counter -= 1;
                if (tbInfo) {
                    self.logger.info('Added testBenchInfo for "' + tbInfo.name + '".');
                    tbInfos.push(tbInfo);
                } else {
                    self.logger.warning('Visited child of ATMFolder without obtaining any test-bench info!');
                }
                if (counter <= 0) {
                    if (self.core.hasPointer(folderNode, 'TopLevelSystemUnderTest')) {
                        self.logger.debug('Found TopLevelSystemUnderTest reference at folder.');
                        self.core.loadPointer(folderNode, 'TopLevelSystemUnderTest', function (err, design) {
                            if (err) {
                                self.logger.error('loading TLSUT failed with err: ' + err.toString());
                                return callback(err);
                            }
                            self.referencedDesign = design;
                            self.logger.info('Found common referenced design from ATMFolder.');
                            return callback(error, tbInfos);
                        });
                    } else {
                        self.createMessage(folderNode, 'No TopLevelSystemUnderTest reference set for folder.', 'error');
                        return callback('Found no reference to TLSUT.');
                    }
                }
            };

            if (children.length === 0) {
                counterCallback(null);
            }

            for (i = 0; i < children.length; i += 1) {
                metaTypeName = self.core.getAttribute(self.getMetaType(children[i]), 'name');
                childName = self.core.getAttribute(children[i], 'name');
                if (metaTypeName === 'AVMTestBenchModel') {
                    self.getTestBenchInfo(children[i], counterCallback);
                } else {
                    counterCallback(null);
                }
            }
        });
    };

    TestBenchRunner.prototype.getTestBenchInfo = function (testBenchNode, callback) {
        var self = this,
            folderNode,
            testBenchInfo = {};
        testBenchInfo.name = self.core.getAttribute(testBenchNode, 'name');
        testBenchInfo.path = self.core.getAttribute(testBenchNode, 'ID');
        testBenchInfo.testBenchFilesHash = self.core.getAttribute(testBenchNode, 'TestBenchFiles');
        testBenchInfo.node = testBenchNode;
        if (!testBenchInfo.path && !self.exportAtm) {
            self.createMessage(testBenchNode, 'There is no "ID" provided for the test-bench. It must be a path' +
                ' in the project-tree of the xme in asset "TestBenchFiles", e.g. /TestBenches/Dynamics/MyTestBench', 'error');
            return callback('TestBench ID not provided.');
        }
        self.logger.info('Getting data for test-bench "' + testBenchInfo.name + '".');
        self.getTlsutInterface(testBenchNode, function (err, tlsut) {
            if (err) {
                self.createMessage(testBenchNode, 'Could not obtain Top Level System Under test interface.', 'error');
                return callback('Something went wrong when getting tlsut interface err: ' + err);
            }
            testBenchInfo.tlsut = tlsut;

            if (self.multiRun) {
                self.logger.info('Multi run - will look for container reference in ATMFolder');
                return callback(null, testBenchInfo);
            }

            // For single test-benches check the reference for the test-bench and its parent folder.
            if (self.core.hasPointer(testBenchNode, 'TopLevelSystemUnderTest')) {
                self.logger.info('Test-bench has TopLevelSystemUnderTest ref set.');
                self.core.loadPointer(testBenchNode, 'TopLevelSystemUnderTest', function (err, design) {
                    if (err) {
                        self.logger.error('loading TLSUT failed with err: ' + err.toString());
                        return callback(err);
                    }
                    self.referencedDesign = design;
                    callback(null, testBenchInfo);
                });
            } else {
                self.logger.info('Test-bench did NOT have a TopLevelSystemUnderTest ref set. Looking at folder..');
                folderNode = self.core.getParent(testBenchNode);
                self.logger.info('Looking for ref at folder "' + self.core.getAttribute(folderNode, 'name') + '".');
                if (self.core.hasPointer(folderNode, 'TopLevelSystemUnderTest')) {
                    self.logger.info('Found TopLevelSystemUnderTest reference at folder.');
                    self.core.loadPointer(folderNode, 'TopLevelSystemUnderTest', function (err, design) {
                        if (err) {
                            self.logger.error('loading TLSUT failed with err: ' + err.toString());
                            return callback(err);
                        }
                        self.referencedDesign = design;
                        callback(null, testBenchInfo);
                    });
                } else {
                    self.createMessage(testBenchNode, 'No TopLevelSystemUnderTest reference set for test-bench or its folder.', 'error');
                    return callback('Found no reference to TLSUT.');
                }
            }
        });
    };

//<editor-fold desc="============================ Obtaining ATM-data ===============================">
    TestBenchRunner.prototype.getTlsutInterface = function (testBenchNode, callback) {
        var self = this,
            rootPath = self.core.getPath(testBenchNode),
            name = self.core.getAttribute(testBenchNode, 'name'),
            atmData = {
                "@xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
                "@xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
                "@Name": name,
                "@xmlns": "avm",
                "TopLevelSystemUnderTest": null,
                "Parameter": [],
                "Metric": [],
                "TestInjectionPoint": [],
                "TestComponent": [],
                "Workflow": null,
                "Settings": [],
                "TestStructure": []
            };
        self.atms.push(atmData);
        self.initializeAdmExporter();
        self.admExporter.rootPath = rootPath;
        // TODO: delete next line when ATM-flow is more mature.
        self.admExporter.includeAcms = false;
        self.logger.info('RootPath "' + rootPath + '" of test-bench "' + name + '" set in AdmExporter.');

        self.core.loadChildren(testBenchNode, function (err, children) {
            var counter, i,
                error = '',
                metaTypeName,
                counterCallback,
                tlsutData;
            if (err) {
                return callback('loadChildren failed for test-bench "' + name + '" with err:' + err.toString());
            }
            counter = children.length;
            counterCallback = function (err) {
                error = err ? error + err : error;
                counter -= 1;
                if (counter <= 0) {
                    if (tlsutData) {
                        callback(error, tlsutData);
                    } else {
                        callback(error + ' there was no Container in the test-bench "' + name + '".');
                    }
                }
            };

            if (children.length === 0) {
                self.createMessage(testBenchNode, 'Test-bench "' + name + '" was empty!', 'error');
                counterCallback('Test-bench "' + name + '" was empty!');
            }

            for (i = 0; i < children.length; i += 1) {
                metaTypeName = self.core.getAttribute(self.getMetaType(children[i]), 'name');
                if (metaTypeName === 'Container') {
                    if (tlsutData) {
                        self.createMessage(testBenchNode, 'There was more than one TLSUT in test-bench "' + name + '".', 'error');
                        counterCallback('There was more than one TLSUT in test-bench "' + name + '".');
                    } else {
                        self.exploreTlsut(children[i], function (err, retrievedData) {
                            tlsutData = retrievedData;
                            counterCallback(err);
                        });
                    }
                } else if (metaTypeName === 'Workflow') {
                    self.addWorkflow(children[i], atmData, counterCallback);
                } else if (metaTypeName === 'Metric') {
                    self.addMetric(children[i], atmData, counterCallback);
                } else if (metaTypeName === 'AVMComponentModel') {
                    self.admExporter.addComponentInstance(children[i], testBenchNode, atmData, counterCallback);
                } else {
                    counterCallback(null);
                }
            }
        });
    };

    TestBenchRunner.prototype.exploreTlsut = function (tlsutNode, callback) {
        var self = this;
        self.core.loadChildren(tlsutNode, function (err, children) {
            var counter, i,
                error = '',
                metaTypeName,
                childName,
                counterCallback,
                tlsutData = {
                    properties: {},
                    connectors: {}
                };
            if (err) {
                return callback('loadChildren failed for tlsut with err:' + err.toString());
            }
            counter = children.length;
            counterCallback = function (err) {
                error = err ? error + err : error;
                counter -= 1;
                if (counter <= 0) {
                    callback(error, tlsutData);
                }
            };

            if (children.length === 0) {
                counterCallback(null);
            }

            for (i = 0; i < children.length; i += 1) {
                metaTypeName = self.core.getAttribute(self.getMetaType(children[i]), 'name');
                childName = self.core.getAttribute(children[i], 'name');
                if (metaTypeName === 'Property') {
                    //TODO: Elaborate on the info stored, e.g. units, type etc. For now just use names.
                    if (tlsutData.properties[childName]) {
                        counterCallback('Duplicate name, "' + childName + '"  of properties in top level system under test!');
                    } else {
                        tlsutData.properties[childName] = children[i];
                        counterCallback(null);
                    }
                } else if (metaTypeName === 'Connector') {
                    //TODO: Elaborate on the info stored, e.g. domainConnectors, Classes etc.
                    if (tlsutData.connectors[childName]) {
                        counterCallback('Duplicate name, "' + childName + '"  of connectors in top level system under test!');
                    } else {
                        tlsutData.connectors[childName] = children[i];
                        counterCallback(null);
                    }
                } else {
                    counterCallback(null);
                }
            }
        });
    };

    TestBenchRunner.prototype.addWorkflow = function (wfNode, atmData, callback) {
        var self = this,
            name = self.core.getAttribute(wfNode, 'name'),
            wfData = {
                '@Name': name,
                '@xmlns': '',
                'Task': []
            };
        atmData.Workflow = wfData;
        self.core.loadChildren(wfNode, function (err, children) {
            var counter, i,
                addTask,
                metaTypeName,
                taskData;
            if (err) {
                return callback('loadChildren failed for work-flow with err: ' + err.toString());
            }
            counter = children.length;
            addTask = function (taskNode) {
                if (taskNode) {
                    if (self.core.getAttribute(taskNode, 'Type') === 'InterpreterTask') {
                        taskData = {
                            '@xmlns:q1': 'avm',
                            '@xsi:type': 'q1:InterpreterTask',
                            '@Name': self.core.getAttribute(taskNode, 'name'),
                            '@COMName': self.core.getAttribute(taskNode, 'COMName'),
                            '@Parameters': self.core.getAttribute(taskNode, 'Parameters')
                        };
                        wfData.Task.push(taskData);
                    }
                }
                counter -= 1;
                if (counter <= 0) {
                    callback(null);
                }
            };

            if (children.length === 0) {
                self.createMessage(wfNode, 'No task defined in Workflow!', 'error');
                callback('No task defined in workflow');
            }

            for (i = 0; i < children.length; i += 1) {
                metaTypeName = self.core.getAttribute(self.getMetaType(children[i]), 'name');
                if (metaTypeName === 'Task') {
                    addTask(children[i]);
                } else {
                    addTask(null, null);
                }
            }
        });

    };

    TestBenchRunner.prototype.addMetric = function (metricNode, atmData, callback) {
        var self = this,
            name = self.core.getAttribute(metricNode, 'name'),
            pos = self.core.getRegistry(metricNode, 'position');
        atmData.Metric.push({
            '@xmlns': '',
            '@Name': name,
            '@Notes': self.core.getAttribute(metricNode, 'INFO'),
            "@XPosition": Math.floor(pos.x),
            "@YPosition": Math.floor(pos.y),
            "Value": null
        });
        callback(null);
    };
//</editor-fold>

//<editor-fold desc="============================ Referenced Design ===============================">
    TestBenchRunner.prototype.getAdmAndAcms = function (designNode, testBenchInfos, callback) {
        var self = this;
        self.checkDesignAgainstTLSUTs(designNode, testBenchInfos, function (err, result) {
            if (err) {
                return callback(err);
            }
            if (result !== true) {
                self.createMessage(designNode, 'Design did not match all TopLevelSystemUnderTests!', 'error');
                return callback('Design did not match all TopLevelSystemUnderTests!');
            }
            self.initializeAdmExporter();
            self.admExporter.exploreDesign(designNode, true, function (err) {
                if (err) {
                    return callback('AdmExporter.exploreDesign failed with error: ' + err);
                }
                self.admData = self.admExporter.admData;
                self.designAcmFiles = self.admExporter.acmFiles;
                callback(null);
            });
        });

    };

    TestBenchRunner.prototype.initializeAdmExporter = function () {
        var self = this;
        if (self.admExporter === null) {
            self.admExporter = new AdmExporter();
            self.admExporter.meta = self.meta;
            self.admExporter.META = self.META;
            self.admExporter.core = self.core;
            self.admExporter.logger = self.logger;
            self.admExporter.result = self.result;
            self.logger.info('AdmExporter had not been initialized - created a new instance.');
        } else {
            self.admExporter.acmFiles = {};
            self.admExporter.gatheredAcms = {};
            self.admExporter.rootPath = null;
            self.admExporter.includeAcms = true;
            self.logger.info('AdmExporter had already been initialized - reset acmFiles, gatheredAcms and rootPath.');
        }
    };

    TestBenchRunner.prototype.checkDesignAgainstTLSUTs = function (designNode, testBenchInfos, callback) {
        var self = this,
            k,
            key,
            mergedProperties = {},
            mergedConnectors = {};
        for (k = 0; k < testBenchInfos.length; k += 1) {
            for (key in testBenchInfos[k].tlsut.properties) {
                if (testBenchInfos[k].tlsut.properties.hasOwnProperty(key)) {
                    mergedProperties[key] = testBenchInfos[k].tlsut.properties[key];
                }
            }
            for (key in testBenchInfos[k].tlsut.connectors) {
                if (testBenchInfos[k].tlsut.connectors.hasOwnProperty(key)) {
                    mergedConnectors[key] = testBenchInfos[k].tlsut.connectors[key];
                }
            }
        }

        self.core.loadChildren(designNode, function (err, children) {
            var counter, i,
                error = '',
                metaTypeName,
                childName,
                counterCallback;
            if (err) {
                return callback('loadChildren failed for tlsut with err:' + err.toString());
            }
            counter = children.length;
            counterCallback = function (err) {
                var innerKey,
                    isValid;

                error = err ? error + err : error;
                counter -= 1;
                if (counter <= 0) {
                    isValid = true;
                    for (innerKey in mergedProperties) {
                        if (mergedProperties.hasOwnProperty(innerKey) && mergedProperties[innerKey] !== true) {
                            //isValid = false;
                            self.createMessage(mergedProperties[innerKey], 'Design does not have property "' + innerKey
                                + '". Property checks are currently ignored.', 'warning');
                        }
                    }
                    for (innerKey in mergedConnectors) {
                        if (mergedConnectors.hasOwnProperty(innerKey) && mergedConnectors[innerKey] !== true) {
                            isValid = false;
                            self.createMessage(mergedConnectors[innerKey], 'Design does not have connector "' +
                                innerKey + '".', 'error');
                        }
                    }
                    callback(error, isValid);
                }
            };

            if (children.length === 0) {
                counterCallback(null);
            }

            for (i = 0; i < children.length; i += 1) {
                metaTypeName = self.core.getAttribute(self.getMetaType(children[i]), 'name');
                childName = self.core.getAttribute(children[i], 'name');
                if (metaTypeName === 'Property') {
                    if (mergedProperties[childName] !== undefined) {
                        mergedProperties[childName] = true;
                    }
                    counterCallback(null);
                } else if (metaTypeName === 'Connector') {
                    if (mergedConnectors[childName] !== undefined) {
                        mergedConnectors[childName] = true;
                    }
                    counterCallback(null);
                } else {
                    counterCallback(null);
                }
            }
        });
    };
//</editor-fold>

//<editor-fold desc="============================ Execution Framework ===============================">
    TestBenchRunner.prototype.generateExecutionFiles = function (testBenchInfo, callback) {
        var self = this,
            artifact,
            executorConfig,
            jsonToXml,
            testbenchConfig,
            filesToAdd = {};
        self.logger.info('Generating execution files.');
        if (!self.admString) {
            // Only convert the common ejs files once.
            self.logger.info('This was first generation of common filesToAdd.');
            jsonToXml = new Converter.Json2xml();
            self.admString = jsonToXml.convertToString({Design: self.admData});
            self.run_exec_cmd = ejs.render(TEMPLATES['run_execution.cmd.ejs']);
            self.exec_py = ejs.render(TEMPLATES['execute.py.ejs']);
        }
        filesToAdd[self.admData['@Name'] + '.adm'] = self.admString;
        filesToAdd['run_execution.cmd'] = self.run_exec_cmd;
        filesToAdd['execute.py'] = self.exec_py;
        executorConfig = JSON.stringify({
            cmd: 'run_execution.cmd',
            resultArtifacts: [
                {
                    name: testBenchInfo.name + '_dashboard',
                    resultPatterns: ['dashboard/**', 'designs/**', 'design-space/**', 'requirements/**',
                        'test-benches/**', 'results/*/testbench_manifest.json', 'results/results.metaresults.json',
                        'manifest.project.json', 'index.html', '*.svg']
                },
                {
                    name: testBenchInfo.name + '_logs',
                    resultPatterns: [ 'log/**', '_FAILED.txt']
                },
                {
                    name: testBenchInfo.name + '_all',
                    resultPatterns: []
                }
            ]

        }, null, 4);
        filesToAdd['executor_config.json'] = executorConfig;
        testbenchConfig = JSON.stringify({ name: testBenchInfo.name, path: testBenchInfo.path }, null, 4);
        filesToAdd['testbench_config.json'] = testbenchConfig;
        self.logger.info('TestBenchConfig : ' + testbenchConfig);
        self.logger.info('ExecutorConfig  : ' + executorConfig);

        artifact = self.blobClient.createArtifact(testBenchInfo.name);
        artifact.addMetadataHash('tbAsset.zip', testBenchInfo.testBenchFilesHash, function (err, hash) {
            if (err) {
                return callback('Could not add tbAsset.zip from test-bench : err' + err.toString());
            }
            artifact.addObjectHashes(self.designAcmFiles, function (err, hashes) {
                if (err) {
                    return callback('Could not add acm files : err' + err.toString());
                }
                artifact.addFiles(filesToAdd, function (err, hashes) {
                    if (err) {
                        return callback('Could not add script files : err' + err.toString());
                    }
                    callback(null, artifact);
                });
            });
        });
    };

    TestBenchRunner.prototype.executeJob = function (artifactHash, testBenchInfo, callback) {
        var self = this;

        if (!self.executorClient) {
            self.logger.info('First execution, creating executor client..');
            self.executorClient = new ExecutorClient();
        }
        self.executorClient.createJob(artifactHash, function (err, jobInfo) {
            var intervalID,
                atSucceedJob;
            if (err) {
                return callback('Creating job failed for "' + testBenchInfo.name + '", err: '  + err.toString(), false);
            }
            self.logger.info('Initial job-info:' + JSON.stringify(jobInfo, null, 4));

            atSucceedJob = function (jInfo) {
                var key;
                self.logger.info('Execution for test-bench "' + testBenchInfo.name + '"  succeeded.');
                self.logger.info('Its final JobInfo looks like : ' + JSON.stringify(jInfo, null, 4));
                for (key in jInfo.resultHashes) {
                    if (jInfo.resultHashes.hasOwnProperty(key)) {
                        self.result.addArtifact(jInfo.resultHashes[key]);
                    }
                }
                self.blobClient.getMetadata(jInfo.resultHashes[testBenchInfo.name + '_logs'], function (err, metadata) {
                    if (err) {
                        return callback('Could not get metadata for result. Err: ' + err, false);
                    }
                    if (metadata.content.hasOwnProperty('_FAILED.txt')) {
                        self.createMessage(testBenchInfo.node, 'Execution had errors - download execution_results for "' +
                            testBenchInfo.name + '" and read _FAILED.txt', 'error');
                        return callback(null, false);
                    }
                    self.core.setAttribute(testBenchInfo.node, 'Results', jInfo.resultHashes[testBenchInfo.name + '_dashboard']);
                    self.dashboardResults.push(jInfo.resultHashes[testBenchInfo.name + '_dashboard']);
                    self.logger.info('No _FAILED.txt generated for test-bench "' + testBenchInfo.name + '".');
                    return callback(null, true);
                });
            };

            //noinspection JSLint
            intervalID = setInterval(function () {
                // Get the job-info at intervals and check for a non-CREATED status.
                self.executorClient.getInfo(artifactHash, function (err, jInfo) {
                    self.logger.info(JSON.stringify(jInfo, null, 4));
                    if (jInfo.status === 'CREATED' || jInfo.status === 'RUNNING') {
                        // The job is still running..
                        return;
                    }
                    //noinspection JSLint
                    clearInterval(intervalID);
                    if (jInfo.status === 'SUCCESS') {
                        atSucceedJob(jInfo);
                    } else {
                        self.result.addArtifact(jInfo.resultHashes[testBenchInfo.name + '_logs']);
                        self.result.addArtifact(jInfo.resultHashes[testBenchInfo.name + '_all']);
                        callback('Job execution failed', false);
                    }
                });
            }, 2000);
        });
    };

    TestBenchRunner.prototype.mergeDashBoards = function (callback) {
        var self = this,
            masterDashHash,

            mergedArtifact;
        if (!(self.multiRun && self.runExecution && self.dashboardResults.length > 0)) {
            self.logger.info('No dashboards to merge.');
            return callback(null);
        }

        mergedArtifact = self.blobClient.createArtifact('mergedDashboards');
        masterDashHash = self.dashboardResults[0];
        self.dashboardResults.shift();
        self.blobClient.getMetadata(masterDashHash, function (err, metaData) {
            if (err) {
                return callback('Could not get metadata for masterDashHash. Err: ' + err);
            }
            self.getProjectManifestAndMetaResults(metaData, function (err, projectManifest, metaResults) {
                var exclude = {};
                if (err) {
                    return callback(err);
                }
                self.projectManifest = projectManifest;
                self.metaResults = metaResults;
                exclude['manifest.project.json'] = true;
                exclude['results/results.metaresults.json'] = true;
                self.addMetaDatasToArtifact(metaData.content, mergedArtifact, exclude, function (err, tbManifests) {
                    if (err) {
                        return callback(err);
                    }
                    self.getDesignCfgToDesignId(tbManifests, function (err, cfgToDesignId) {
                        if (err) {
                            return callback(err);
                        }
                        self.logger.info(JSON.stringify(cfgToDesignId, null, 2));
                        self.designNameToDesignId = cfgToDesignId;
                        self.addSlavesDashFiles(mergedArtifact, function (err) {
                            var filesToAdd;
                            if (err) {
                                return callback(err);
                            }
                            filesToAdd = {
                                'manifest.project.json': JSON.stringify(self.projectManifest, null, 4),
                                'results/results.metaresults.json': JSON.stringify(self.metaResults, null, 4)
                            };
                            mergedArtifact.addFiles(filesToAdd, function (err, hashes) {
                                if (err) {
                                    return callback(err);
                                }
                                mergedArtifact.save(function (err, artieHash) {
                                    if (err) {
                                        return callback(err);
                                    }
                                    self.result.addArtifact(artieHash);
                                    self.core.setAttribute(self.activeNode, 'Results', artieHash);
                                    callback(null);
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    TestBenchRunner.prototype.getJSObjFromMetaData = function (metaData, callback) {
        var self = this,
            contentHash = metaData.content;
        self.logger.info('About to get JS-object from meta-data: ' +
            JSON.stringify(metaData, null, 2) + '.');
        self.blobClient.getObject(contentHash, function (err, content) {
            var jsonString;
            if (err) {
                return callback('Could not get content, err :' + err.toString());
            }
            jsonString = String.fromCharCode.apply(null, new Uint8Array(content));
            self.logger.info(jsonString);
            callback(null, JSON.parse(jsonString));
        });
    };

    TestBenchRunner.prototype.getProjectManifestAndMetaResults = function (metaData, callback) {
        var self = this,
            manifestName = 'manifest.project.json',
            metaResName = 'results/results.metaresults.json';

        self.getJSObjFromMetaData(metaData.content[manifestName], function (err, projectManifest) {
            if (err) {
                return callback(err);
            }
            self.getJSObjFromMetaData(metaData.content[metaResName], function (err, metaResults) {
                if (err) {
                    return callback(err);
                }
                callback(null, projectManifest, metaResults);
            });
        });
    };

    TestBenchRunner.prototype.addMetaDatasToArtifact = function (metaDatas, artifact, exclude, callback) {
        var self = this,
            metaDataToAdd = {},
            toExclude = exclude || {},
            fileName,
            testBenchManifests = [];
        for (fileName in metaDatas) {
            if (metaDatas.hasOwnProperty(fileName) && toExclude[fileName] === undefined) {
                metaDataToAdd[fileName] = metaDatas[fileName].content;
                if (self.endsWith(fileName, '/testbench_manifest.json')) {
                    testBenchManifests.push({
                        fileName: fileName,
                        softLinkHash: metaDatas[fileName]
                    });
                }
            }
        }

        artifact.addMetadataHashes(metaDataToAdd, function (err, hashes) {
            if (err) {
                return callback('Could not add metaDatas to artifact, err:' + err);
            }
            callback(null, testBenchManifests);
        });
    };

    TestBenchRunner.prototype.getDesignCfgToDesignId = function (testBenchManifests, callback) {
        var self = this,
            counter = testBenchManifests.length,
            error = '',
            i,
            cfgToDesignId = {},
            counterCallback = function (err, tbManifestObj) {
                error = err ? error + err : error;
                if (tbManifestObj) {
                    cfgToDesignId[tbManifestObj.DesignName] = tbManifestObj.DesignID;
                }
                counter -= 1;
                if (counter <= 0) {
                    callback(error, cfgToDesignId);
                }
            };
        if (testBenchManifests.length === 0) {
            counterCallback('No test-bench manifest in master dashboard result!', null);
        }
        for (i = 0; i < testBenchManifests.length; i += 1) {
            self.getJSObjFromMetaData(testBenchManifests[i].softLinkHash, counterCallback);
        }
    };

    TestBenchRunner.prototype.addSlavesDashFiles = function (artifact, callback) {
        var self = this,
            counter = self.dashboardResults.length,
            error = '',
            i,
            counterCallback = function (err) {
                error = err ? error + err : error;
                counter -= 1;
                if (counter <= 0) {
                    callback(error);
                }
            };

        if (self.dashboardResults.length === 0) {
            counterCallback(null);
        }
        for (i = 0; i < self.dashboardResults.length; i += 1) {
            self.addSlaveDashFiles(self.dashboardResults[i], artifact, counterCallback);
        }
    };

    TestBenchRunner.prototype.addSlaveDashFiles = function (dashHash, artifact, callback) {
        var self = this;
        self.blobClient.getMetadata(dashHash, function (err, slaveDashMetaData) {
            if (err) {
                return callback('Could not get metadata for masterDashHash. Err: ' + err);
            }
            self.getProjectManifestAndMetaResults(slaveDashMetaData, function (err, projectManifest, metaResults) {
                var testBenchPath,
                    i,
                    metaDataToAdd = {},
                    filesToAdd = {},
                    counterCallback,
                    error = '',
                    counter;
                if (err) {
                    return callback(err);
                }
                // Add info from project-manifest
                testBenchPath = projectManifest.Project.TestBenches[0];
                self.projectManifest.Project.TestBenches.push(testBenchPath);
                testBenchPath = testBenchPath.substring(2);
                metaDataToAdd[testBenchPath] = slaveDashMetaData.content[testBenchPath].content;
                // Add info from meta-results.
                counter = metaResults.Results.length;
                counterCallback = function (err) {
                    error = err ? error + err : error;
                    counter -= 1;
                    if (counter <= 0) {
                        artifact.addMetadataHashes(metaDataToAdd, function (err, hashes) {
                            if (err) {
                                return callback('Could not add metaDatas of slave to artifact, err:' + err);
                            }
                            artifact.addFiles(filesToAdd, function (err, hashes) {
                                if (err) {
                                    return callback('Could not add files of slave to artifact, err:' + err);
                                }
                                callback(null);
                            });
                        });
                    }
                };
                if (metaResults.Results.length === 0) {
                    counterCallback('No results for: ' + JSON.stringify(projectManifest, null, 2));
                }
                for (i = 0; i < metaResults.Results.length; i += 1) {
                    self.mergeResult(slaveDashMetaData, metaResults.Results[i], filesToAdd, counterCallback);
                }
            });
        });
    };

    TestBenchRunner.prototype.mergeResult = function (metaData, result, filesToAdd, callback) {
        var self = this,
            tbManifestPath;
        tbManifestPath = 'results' + result.Summary.substring(1);
        self.logger.info(JSON.stringify(metaData.content, null, 2));
        self.logger.info(tbManifestPath);
        self.getJSObjFromMetaData(metaData.content[tbManifestPath], function (err, tbManifest) {
            var designName;
            if (err) {
                return callback('Could not get test-bench object, err: ' + err);
            }
            designName = tbManifest.DesignName;
            if (self.designNameToDesignId.hasOwnProperty(designName)) {
                tbManifest.DesignID = self.designNameToDesignId[designName];
                filesToAdd[tbManifestPath] = JSON.stringify(tbManifest, null, 4);
                result.DesignID = tbManifest.DesignID;
                self.metaResults.Results.push(result);
            } else {
                self.createMessage(self.activeNode, 'Design names are not equal amongst test-benches. "' + designName +
                    '" did not exist in all dashboard folders.', 'warning');
            }
            callback(null);
        });
    };
//</editor-fold>

    TestBenchRunner.prototype.endsWith = function (str, ending) {
        var lastIndex = str.lastIndexOf(ending);
        return (lastIndex !== -1) && (lastIndex + ending.length === str.length);
    };

    return TestBenchRunner;
});