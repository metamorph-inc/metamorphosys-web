/*globals define */
/**
 * Generated by PluginGenerator from webgme on Wed Sep 03 2014 15:36:17 GMT-0500 (Central Daylight Time).
 */

define( [
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'plugin/AtmExporter/AtmExporter/meta',
    'plugin/AdmExporter/AdmExporter/AdmExporter',
    'xmljsonconverter'
], function ( PluginConfig, PluginBase, MetaTypes, AdmExporter, Converter ) {
    'use strict';

    /**
     * Initializes a new instance of AtmExporter.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin AtmExporter.
     * @constructor
     */
    var AtmExporter = function () {
        // Call base class' constructor.
        PluginBase.call( this );
        this.meta = null;
        this.atmData = null;
        this.admExporter = null;
    };

    // Prototypal inheritance from PluginBase.
    AtmExporter.prototype = Object.create( PluginBase.prototype );
    AtmExporter.prototype.constructor = AtmExporter;

    /**
     * Gets the name of the AtmExporter.
     * @returns {string} The name of the plugin.
     * @public
     */
    AtmExporter.prototype.getName = function () {
        return "ATM Exporter";
    };

    /**
     * Gets the semantic version (semver.org) of the AtmExporter.
     * @returns {string} The version of the plugin.
     * @public
     */
    AtmExporter.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
     * Gets the description of the AtmExporter.
     * @returns {string} The description of the plugin.
     * @public
     */
    AtmExporter.prototype.getDescription = function () {
        return "Exports an ATM based on the AVMTestBenchModel.";
    };

    /**
     * Gets the configuration structure for the AtmExporter.
     * The ConfigurationStructure defines the configuration for the plugin
     * and will be used to populate the GUI when invoking the plugin from webGME.
     * @returns {object} The version of the plugin.
     * @public
     */
    AtmExporter.prototype.getConfigStructure = function () {
        return [];
    };


    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    AtmExporter.prototype.main = function ( callback ) {
        var self = this;

        if ( !self.activeNode ) {
            self.createMessage( null,
                'Active node is not present! This happens sometimes... Loading another model ' +
                'and trying again will solve it most of times.', 'error' );
            callback( 'Active node is not present!', self.result );
            return;
        }
        if ( self.isMetaTypeOf( self.activeNode, self.META.AVMTestBenchModel ) === false ) {
            self.createMessage( null, 'This plugin must be called from a AVMTestBenchModel.', 'error' );
            callback( null, self.result );
            return;
        }
        self.meta = MetaTypes;
        self.updateMETA( self.meta );
        self.getTlsutInterface( self.activeNode, function ( err, tlsut ) {
            var artifact,
                atmXmlStr,
                jsonToXml = new Converter.Json2xml();
            if ( err ) {
                self.logger.error( 'Error when exploring TestBench, err: ' + err );
                callback( null, self.result );
                return;
            }
            artifact = self.blobClient.createArtifact( 'testBench' );
            atmXmlStr = jsonToXml.convertToString( {
                TestBench: self.atmData
            } );
            artifact.addFile( self.atmData[ '@Name' ] + '.atm', atmXmlStr, function ( err, hash ) {
                if ( err ) {
                    callback( 'Could not add atm file : err' + err.toString(), self.result );
                    return;
                }
                self.logger.info( 'Added atm files to artifact, it has hash: ' + hash );
                artifact.save( function ( err, hash ) {
                    if ( err ) {
                        callback( 'Could not save atm artifact : err' + err.toString(), self.result );
                        return;
                    }
                    self.result.addArtifact( hash );
                    self.result.setSuccess( true );
                    callback( null, self.result );
                } );
            } );
        } );
    };

    AtmExporter.prototype.getTlsutInterface = function ( testBenchNode, callback ) {
        var self = this,
            rootPath = self.core.getPath( testBenchNode ),
            name = self.core.getAttribute( testBenchNode, 'name' );

        self.atmData = {
            "@xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
            "@xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
            "@Name": name,
            "@xmlns": "avm",
            "TopLevelSystemUnderTest": null,
            "Parameter": [],
            "Metric": [],
            "TestInjectionPoint": [],
            "TestComponent": [],
            "Workflow": null,
            "Settings": [],
            "TestStructure": []
        };

        self.initializeAdmExporter( rootPath );

        self.core.loadChildren( testBenchNode, function ( err, children ) {
            var counter, i,
                error = '',
                metaTypeName,
                counterCallback,
                tlsutData;
            if ( err ) {
                callback( 'loadChildren failed for test-bench "' + name + '" with err:' + err.toString() );
                return;
            }
            counter = children.length;
            counterCallback = function ( err ) {
                error = err ? error + err : error;
                counter -= 1;
                if ( counter <= 0 ) {
                    if ( tlsutData ) {
                        callback( error, tlsutData );
                    } else {
                        callback( error + ' there was no Container in the test-bench "' + name + '".' );
                    }
                }
            };

            if ( children.length === 0 ) {
                self.createMessage( testBenchNode, 'Test-bench "' + name + '" was empty!', 'error' );
                counterCallback( 'Test-bench "' + name + '" was empty!' );
            }

            for ( i = 0; i < children.length; i += 1 ) {
                metaTypeName = self.core.getAttribute( self.getMetaType( children[ i ] ), 'name' );
                if ( metaTypeName === 'Container' ) {
                    if ( tlsutData ) {
                        self.createMessage( testBenchNode, 'There was more than one TLSUT in test-bench "' +
                            name + '".', 'error' );
                        counterCallback( 'There was more than one TLSUT in test-bench "' + name + '".' );
                    } else {
                        self.exploreTlsut( children[ i ], function ( err, retrievedData ) {
                            tlsutData = retrievedData;
                            counterCallback( err );
                        } );
                    }
                } else if ( metaTypeName === 'Workflow' ) {
                    self.addWorkflow( children[ i ], counterCallback );
                } else if ( metaTypeName === 'Metric' ) {
                    self.addMetric( children[ i ], counterCallback );
                } else if ( metaTypeName === 'AVMComponentModel' ) {
                    self.admExporter.addComponentInstance( children[ i ], testBenchNode, self.atmData,
                        counterCallback );
                } else {
                    counterCallback( null );
                }
            }
        } );
    };

    AtmExporter.prototype.exploreTlsut = function ( tlsutNode, callback ) {
        var self = this;
        self.core.loadChildren( tlsutNode, function ( err, children ) {
            var counter, i,
                error = '',
                metaTypeName,
                childName,
                counterCallback,
                tlsutData = {
                    properties: {},
                    connectors: {}
                };
            if ( err ) {
                callback( 'loadChildren failed for tlsut with err:' + err.toString() );
                return;
            }
            counter = children.length;
            counterCallback = function ( err ) {
                error = err ? error + err : error;
                counter -= 1;
                if ( counter <= 0 ) {
                    callback( error, tlsutData );
                }
            };

            if ( children.length === 0 ) {
                counterCallback( null );
            }

            for ( i = 0; i < children.length; i += 1 ) {
                metaTypeName = self.core.getAttribute( self.getMetaType( children[ i ] ), 'name' );
                childName = self.core.getAttribute( children[ i ], 'name' );
                if ( metaTypeName === 'Property' ) {
                    //TODO: Elaborate on the info stored, e.g. units, type etc. For now just use names.
                    if ( tlsutData.properties[ childName ] ) {
                        counterCallback( 'Duplicate name, "' + childName +
                            '"  of properties in top level system under test!' );
                    } else {
                        tlsutData.properties[ childName ] = children[ i ];
                        counterCallback( null );
                    }
                } else if ( metaTypeName === 'Connector' ) {
                    //TODO: Elaborate on the info stored, e.g. domainConnectors, Classes etc.
                    if ( tlsutData.connectors[ childName ] ) {
                        counterCallback( 'Duplicate name, "' + childName +
                            '"  of connectors in top level system under test!' );
                    } else {
                        tlsutData.connectors[ childName ] = children[ i ];
                        counterCallback( null );
                    }
                } else {
                    counterCallback( null );
                }
            }
        } );
    };

    AtmExporter.prototype.addWorkflow = function ( wfNode, callback ) {
        var self = this,
            name = self.core.getAttribute( wfNode, 'name' ),
            wfData = {
                '@Name': name,
                '@xmlns': '',
                'Task': []
            };
        self.atmData.Workflow = wfData;
        self.core.loadChildren( wfNode, function ( err, children ) {
            var counter, i,
                addTask,
                metaTypeName,
                taskData;
            if ( err ) {
                callback( 'loadChildren failed for work-flow with err: ' + err.toString() );
                return;
            }
            counter = children.length;
            addTask = function ( taskNode ) {
                if ( taskNode ) {
                    if ( self.core.getAttribute( taskNode, 'Type' ) === 'InterpreterTask' ) {
                        taskData = {
                            '@xmlns:q1': 'avm',
                            '@xsi:type': 'q1:InterpreterTask',
                            '@Name': self.core.getAttribute( taskNode, 'name' ),
                            '@COMName': self.core.getAttribute( taskNode, 'COMName' ),
                            '@Parameters': self.core.getAttribute( taskNode, 'Parameters' )
                        };
                        wfData.Task.push( taskData );
                    }
                }
                counter -= 1;
                if ( counter <= 0 ) {
                    callback( null );
                }
            };

            if ( children.length === 0 ) {
                self.createMessage( wfNode, 'No task defined in Workflow!', 'error' );
                callback( 'No task defined in workflow' );
            }

            for ( i = 0; i < children.length; i += 1 ) {
                metaTypeName = self.core.getAttribute( self.getMetaType( children[ i ] ), 'name' );
                if ( metaTypeName === 'Task' ) {
                    addTask( children[ i ] );
                } else {
                    addTask( null, null );
                }
            }
        } );

    };

    AtmExporter.prototype.addMetric = function ( metricNode, callback ) {
        var self = this,
            name = self.core.getAttribute( metricNode, 'name' ),
            pos = self.core.getRegistry( metricNode, 'position' );
        self.atmData.Metric.push( {
            '@xmlns': '',
            '@Name': name,
            '@Notes': self.core.getAttribute( metricNode, 'INFO' ),
            "@XPosition": Math.floor( pos.x ),
            "@YPosition": Math.floor( pos.y ),
            "Value": null
        } );
        callback( null );
    };

    AtmExporter.prototype.initializeAdmExporter = function ( rootPath ) {
        var self = this;
        self.admExporter = new AdmExporter();
        self.admExporter.meta = self.meta;
        self.admExporter.META = self.META;
        self.admExporter.core = self.core;
        self.admExporter.logger = self.logger;
        self.admExporter.result = self.result;
        self.admExporter.rootPath = rootPath;
        // TODO: delete next line when ATM-flow is more mature.
        self.admExporter.includeAcms = false;
        self.logger.info( 'AdmExporter initialized.' );
    };

    return AtmExporter;
} );