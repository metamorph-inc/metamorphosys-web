/**
 * Generated by PluginGenerator from webgme on Mon Apr 14 2014 10:15:45 GMT-0500 (Central Daylight Time).
 */
// TODO: Get the json data dynamically!
define( [
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'plugin/AdmImporter/AdmImporter/meta',
    'xmljsonconverter'
], function ( PluginConfig, PluginBase, MetaTypes, Converter ) {
    'use strict';
    //<editor-fold desc="============================ Class Definition ================================">
    /**
     * Initializes a new instance of AdmImporter.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin AdmImporter.
     * @constructor
     */
    var AdmImporter = function () {
        // Call base class' constructor.
        PluginBase.call( this );
        this.meta = MetaTypes;
        this.acmCounter = 0;
        this.componentID2Acm = {};
        this.componentID2PrintInfo = {};
        // printInfoDataType = {
        //    name: {string},
        //    count: {int},
        //    parentName: {string}
        // };
        this.componentInstances = [];
        //        componentInstancesDataType = {
        //            node: {nodeObj},
        //            connIdInModel2ID: {object},
        //            propertyIdInModel2ID: {object},
        //            portIdInModel2ID: {object},
        //        };
        this.connID2Node = {};
        this.portID2Node = {};
        this.valueFlowTargetID2Node = {};
        this.valueFlows = [];
        //        valueFlowsDataType = {
        //            src: {string},
        //            dst: {string}
        //        };
        this.valueFlowMuxes = {};
        this.connectorCompositions = [];
        //        connectorCompositionsDataType = {
        //            src: {string},
        //            dst: {string}
        //        };
        this.portMaps = [];
        //        portMapsDataType = {
        //            src: {string},
        //            dst: {string}
        //        };
        this.admData = null;
        this.copies = false;
        this.currentSuccess = true;
    };

    // Prototypal inheritance from PluginBase.
    AdmImporter.prototype = Object.create( PluginBase.prototype );
    AdmImporter.prototype.constructor = AdmImporter;

    /**
     * Gets the name of the AdmImporter.
     * @returns {string} The name of the plugin.
     * @public
     */
    AdmImporter.prototype.getName = function () {
        return "ADM Importer";
    };

    /**
     * Gets the description of the AdmImporter.
     * @returns {string} The description of the plugin.
     * @public
     */
    AdmImporter.prototype.getDescription = function () {
        return "Imports an adm-file generated from desktop GME.";
    };

    /**
     * Gets the semantic version (semver.org) of the AdmImporter.
     * @returns {string} The version of the plugin.
     * @public
     */
    AdmImporter.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
     * Gets the configuration structure for the AdmImporter.
     * The ConfigurationStructure defines the configuration for the plugin
     * and will be used to populate the GUI when invoking the plugin from webGME.
     * @returns {object} The version of the plugin.
     * @public
     */
    AdmImporter.prototype.getConfigStructure = function () {
        return [ {
            'name': 'admFile',
            'displayName': 'ADM file',
            'description': 'AVM Design Model.',
            'value': "",
            'valueType': 'asset',
            'readOnly': false
        } ];
    };
    //</editor-fold>
    AdmImporter.prototype.innerMain = function ( xmlArrayBuffer, callback, finnishPlugin ) {
        var self = this,
            xml2json = new Converter.Xml2json( {
                skipWSText: true,
                arrayElements: self.arrayElementsInXml
            } ),
            admFolder = self.activeNode,
            workspaceNode;

        self.updateMETA( self.meta );
        //self.copies = config.copies;
        self.copies = true;
        if ( typeof xmlArrayBuffer === 'string' ) {
            self.admData = xml2json.convertFromString( xmlArrayBuffer );
        } else {
            self.admData = xml2json.convertFromBuffer( xmlArrayBuffer );
        }
        if ( self.admData instanceof Error ) {
            self.createMessage( null, 'Given adm not valid xml: ' + self.admData.message, 'error' );
            callback( null, self.result );
            return;
        }

        self.admData = self.admData[ 'Design' ];
        workspaceNode = self.getWorkspaceNode( admFolder );
        //timeStamp = new Date().getTime();
        self.exploreACMs( workspaceNode, false, function ( err ) {
            if ( err ) {
                callback( err, self.result );
                return;
            }
            //self.createMessage(null, 'ExecTime [s] exploreACMs     :: ' +
            //        ((new Date().getTime() - timeStamp) / 1000).toString());
            if ( self.acmCounter > 0 ) {
                self.createMessage( workspaceNode, 'Work-space did not have all ACMs used by the design.',
                    'error' );
                self.logMissingACMsToResult();
                callback( null, self.result );
                return;
            }
            //timeStamp = new Date().getTime();
            self.container = self.createAdmDesign( admFolder );
            //self.createMessage(null, 'ExecTime [s] createAdmDesign :: ' +
            //    ((new Date().getTime() - timeStamp) / 1000).toString());
            if ( false ) {
                self.makeConnectorCompositions();
                self.makeValueFlows();
                finnishPlugin( null );
            } else {
                //timeStamp = new Date().getTime();
                self.gatherComponentInstanceContent( function ( err ) {
                    //self.createMessage(null, 'ExecTime [s] gatherComponentInstanceContent :: ' +
                    //    ((new Date().getTime() - timeStamp) / 1000).toString());
                    if ( err ) {
                        finnishPlugin( err );
                    } else {
                        //timeStamp = new Date().getTime();
                        self.makeConnectorCompositions();
                        //self.createMessage(null, 'ExecTime [s] makeConnectorCompositions :: ' +
                        //    ((new Date().getTime() - timeStamp) / 1000).toString());
                        //timeStamp = new Date().getTime();
                        self.makeValueFlows();
                        //self.createMessage(null, 'ExecTime [s] makeValueFlows :: ' +
                        //    ((new Date().getTime() - timeStamp) / 1000).toString());
                        self.makePortMaps();
                        finnishPlugin( null );
                    }
                } );
            }
        } );
    };

    AdmImporter.prototype.arrayElementsInXml = {
        Design: false,
        RootContainer: false,
        Value: false,
        Container: true,
        Connector: true,
        Property: true,
        Formula: true,
        Operand: true,
        ValueFlowMux: true,
        ComponentInstance: true,
        PrimitivePropertyInstance: true,
        ConnectorInstance: true,
        PortInstance: true,
        Role: true,
        Port: true
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always have to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    AdmImporter.prototype.main = function ( callback ) {
        var self = this,
            config = self.getCurrentConfig(),
            //timeStamp,
            timeStart = new Date()
                .getTime(),
            debug = false,
            finnishPlugin = function ( err ) {
                if ( err ) {
                    callback( err, self.result );
                    return;
                }

                if ( debug ) {
                    self.saveDebugArtifacts( callback );
                } else {
                    //timeStamp = new Date().getTime();
                    self.save( 'added obj', function ( err ) {
                        if ( err ) {
                            callback( err, self.result );
                            return;
                        }
                        //self.createMessage(null, 'ExecTime [s] save :: ' +
                        //    ((new Date().getTime() - timeStamp) / 1000).toString());

                        if ( self.currentSuccess === false ) {
                            self.createMessage( null,
                                'There were issues in the matched ACMs. Incomplete model still ' +
                                'imported - make sure to address the reported issues.', 'warning' );
                        }
                        //                        self.createMessage(null, 'ExecTime [s] total :: ' +
                        //                            ((new Date().getTime() - timeStart) / 1000).toString());
                        self.result.setSuccess( self.currentSuccess );
                        callback( null, self.result );
                    } );
                }
            };

        if ( !self.activeNode ) {
            self.createMessage( null,
                'Active node is not present! This happens sometimes... Loading another model ' +
                'and trying again will solve it most of times.', 'error' );
            callback( 'Active node is not present!', self.result );
            return;
        }

        if ( self.isMetaTypeOf( self.activeNode, self.META.ADMFolder ) === false ) {
            self.createMessage( null, 'This plugin must be called from an ADMFolder.', 'error' );
            callback( null, self.result );
            return;
        }
        if ( !config.admFile ) {
            self.createMessage( null, 'No adm file provided', 'error' );
            callback( null, self.result );
            return;
        }
        self.blobClient.getObject( config.admFile, function ( err, xmlArrayBuffer ) {
            self.innerMain( xmlArrayBuffer, callback, finnishPlugin );
        } );
    };

    AdmImporter.prototype.saveDebugArtifacts = function ( callback ) {
        var self = this,
            artie,
            json2xml,
            debugFiles;

        json2xml = new Converter.Json2xml();
        debugFiles = {
            'design.json': JSON.stringify( {
                Design: self.admData
            }, null, 4 ),
            'design.adm': json2xml.convertToString( {
                Design: self.admData
            } )
        };
        artie = self.blobClient.createArtifact( 'debugFiles' );
        artie.addFiles( debugFiles, function ( err, hashes ) {
            if ( err ) {
                self.result.setSuccess( false );
                callback( 'Could not add debug files : err' + err.toString(), self.result );
                return;
            }
            artie.save( function ( err, hash ) {
                if ( err ) {
                    self.result.setSuccess( false );
                    callback( 'Could not save artifact : err' + err.toString(), self.result );
                    return;
                }
                self.result.setSuccess( true );
                self.result.addArtifact( hash );
                callback( null, self.result );
            } );
        } );
    };

    //<editor-fold desc="============================ Gathering of ACM Info ===========================">
    AdmImporter.prototype.getWorkspaceNode = function ( node ) {
        var self = this;
        while ( node ) {
            if ( self.isMetaTypeOf( node, self.meta.WorkSpace ) ) {
                self.logger.info( 'Found WorkSpace-Node : ' + self.core.getAttribute( node, 'name' ) );
                return node;
            }
            node = self.core.getParent( node );
        }
        self.logger.error( 'Could not find WorkSpace!!' );
    };

    AdmImporter.prototype.exploreACMs = function ( node, dummyACMs, callback ) {
        var self = this;
        if ( dummyACMs ) {
            callback( null );
            return;
        }
        self.initializeComponentMap( self.admData.RootContainer );
        self.logger.info( 'Number of unique ACMs (acmCounter) is ' + self.acmCounter.toString() );
        self.core.loadChildren( node, function ( err, children ) {
            var counter,
                i,
                counterCallback,
                error = '';
            // Check for error in loading before doing recursion.
            if ( err ) {
                callback( 'Could not load children for project, err: ' + err, self.result );
                return;
            }
            if ( children.length === 0 ) {
                callback( null );
                return;
            }
            // Define a counter and callback for the recursion.
            counter = {
                visits: children.length
            };
            counterCallback = function ( err ) {
                error = err ? error += err : error;
                counter.visits -= 1;
                if ( counter.visits === 0 ) {
                    callback( error );
                }
            };
            // Iterate over children and invoke recursion on ACMFolders.
            for ( i = 0; i < children.length; i += 1 ) {
                if ( self.isMetaTypeOf( children[ i ], self.meta.ACMFolder ) ) {
                    self.visitComponentsRec( children[ i ], counter, counterCallback );
                } else {
                    counterCallback( null );
                }
            }
        } );
    };

    AdmImporter.prototype.initializeComponentMap = function ( container ) {
        var self = this,
            i,
            subContainers,
            components,
            id;

        if ( container.ComponentInstance ) {
            components = container.ComponentInstance;
            for ( i = 0; i < components.length; i += 1 ) {
                id = components[ i ][ '@ComponentID' ];
                if ( self.componentID2Acm[ id ] === undefined ) {
                    self.componentID2Acm[ id ] = false;
                    self.acmCounter += 1;
                    self.componentID2PrintInfo[ id ] = {
                        name: components[ i ][ '@Name' ],
                        count: 1,
                        parentName: container[ '@Name' ]
                    };
                } else {
                    self.componentID2PrintInfo[ id ].count += 1;
                }
            }
        }

        if ( container.Container ) {
            subContainers = container.Container;
            for ( i = 0; i < subContainers.length; i += 1 ) {
                self.initializeComponentMap( subContainers[ i ] );
            }
        }
    };

    AdmImporter.prototype.visitComponentsRec = function ( node, counter, callback ) {
        var self = this,
            name = self.core.getAttribute( node, 'name' ),
            childName;
        self.logger.info( 'visitComponentsRec at node "' + name + '" acmCounter is:   ' + self.acmCounter.toString() );
        if ( self.acmCounter <= 0 ) {
            callback( null );
            return;
        }
        self.core.loadChildren( node, function ( err, children ) {
            var i,
                componentID;
            if ( err ) {
                callback( ' loadChildren failed for component ' + name + ' with error : ' + err );
                return;
            }
            counter.visits += children.length;

            if ( children.length === 0 ) {
                // The only chance for callback to be called.
                callback( null );
            } else {
                // The node needs to be accounted for.
                counter.visits -= 1;
            }
            for ( i = 0; i < children.length; i += 1 ) {
                if ( self.isMetaTypeOf( children[ i ], self.meta.ACMFolder ) ) {
                    self.visitComponentsRec( children[ i ], counter, callback );
                } else if ( self.isMetaTypeOf( children[ i ], self.meta.AVMComponentModel ) ) {
                    componentID = self.core.getAttribute( children[ i ], 'ID' );
                    childName = self.core.getAttribute( children[ i ], 'name' );
                    if ( self.componentID2Acm[ componentID ] === false ) {
                        self.componentID2Acm[ componentID ] = children[ i ];
                        self.logger.info( 'Found matching ACM "' + childName + '"' );
                        self.acmCounter -= 1;
                    } else if ( self.componentID2Acm[ componentID ] === undefined ) {
                        self.logger.info( 'ACM "' + childName + '" is not part of the design.' );
                    } else {
                        self.logger.warning( 'Found duplicate ACM ID "' + componentID + '". "' + childName +
                            '" at "' +
                            self.core.getPath( children[ i ] ) + '" will not be used.' );
                    }
                    callback( null );
                } else {
                    callback( null );
                }
            }
        } );
    };

    AdmImporter.prototype.logMissingACMsToResult = function () {
        var self = this,
            missingIDs = [],
            key,
            i,
            info;
        for ( key in self.componentID2Acm ) {
            if ( self.componentID2Acm.hasOwnProperty( key ) ) {
                if ( self.componentID2Acm[ key ] === false ) {
                    missingIDs.push( key );
                }
            }
        }
        for ( i = 0; i < missingIDs.length; i += 1 ) {
            info = self.componentID2PrintInfo[ missingIDs[ i ] ];
            self.createMessage( null, 'ACM "' + info.name + '", in ADM "' + info.parentName + '" did not have a ' +
                'matching ACM with ID "' + missingIDs[ i ] + '". (The component ocurres ' + info.count.toString() +
                ' times in the ADM.)', 'error' );
        }
    };
    //</editor-fold>

    //<editor-fold desc="=========================== Creation of ADM objects ==========================">
    AdmImporter.prototype.createAdmDesign = function ( admFolder ) {
        var self = this;
        return self.createContainer( self.admData.RootContainer, admFolder, 0 );
    };

    AdmImporter.prototype.createContainer = function ( containerData, parentNode, depth ) {
        var self = this,
            container,
            subContainersData,
            componentsData,
            connectorsData,
            portData,
            propertiesData,
            formulasData,
            muxData,
            i,
            indent = new Array( depth + 2 )
                .join( '-' );
        // Create the container and set attributes and registry.
        container = self.core.createNode( {
            parent: parentNode,
            base: self.meta.Container
        } );
        self.core.setAttribute( container, 'name', containerData[ '@Name' ] );
        self.core.setAttribute( container, 'Type', containerData[ '@xsi:type' ].slice( "avm:".length ) );
        if ( depth === 0 ) {
            self.core.setRegistry( container, 'position', {
                x: 100,
                y: 100
            } );
        } else {
            self.core.setRegistry( container, 'position', {
                x: parseInt( containerData[ '@XPosition' ], 10 ),
                y: parseInt( containerData[ '@YPosition' ], 10 )
            } );
        }

        self.logger.info( indent + 'Created Container : ' + containerData[ '@Name' ] );
        depth += 1;

        // Go through the containment and add the child-objects.
        if ( containerData.Container ) {
            subContainersData = containerData.Container;
            for ( i = 0; i < subContainersData.length; i += 1 ) {
                self.createContainer( subContainersData[ i ], container, depth );
            }
        }

        if ( containerData.ValueFlowMux ) {
            muxData = containerData.ValueFlowMux;
            for ( i = 0; i < muxData.length; i += 1 ) {
                self.valueFlowMuxes[ muxData[ i ][ '@ID' ] ] = muxData[ i ][ '@Source' ].split( ' ' );
            }
        }

        if ( containerData.ComponentInstance ) {
            componentsData = containerData.ComponentInstance;
            for ( i = 0; i < componentsData.length; i += 1 ) {
                self.createComponent( componentsData[ i ], container );
                self.logger.info( indent + 'Created Component : ' + componentsData[ i ][ '@Name' ] );
            }
        }

        if ( containerData.Connector ) {
            connectorsData = containerData.Connector;
            for ( i = 0; i < connectorsData.length; i += 1 ) {
                self.createConnector( connectorsData[ i ], container );
                self.logger.info( indent + 'Created Connector : ' + connectorsData[ i ][ '@Name' ] );
            }
        }

        if ( containerData.Port ) {
            portData = containerData.Port;
            for ( i = 0; i < portData.length; i += 1 ) {
                self.createDomainPort( portData[ i ], container );
                self.logger.info( indent + 'Created DomainPort : ' + portData[ i ][ '@Name' ] );
            }
        }

        if ( containerData.Property ) {
            propertiesData = containerData.Property;
            for ( i = 0; i < propertiesData.length; i += 1 ) {
                self.createProperty( propertiesData[ i ], container );
            }
        }

        if ( containerData.Formula ) {
            formulasData = containerData.Formula;
            for ( i = 0; i < formulasData.length; i += 1 ) {
                self.createFormula( formulasData[ i ], container );
            }
        }

        return container;
    };

    AdmImporter.prototype.createComponent = function ( componentData, parentNode ) {
        var self = this,
            i,
            avmID = componentData[ '@ComponentID' ],
            component,
            connectorInstanceData = componentData.ConnectorInstance,
            connector,
            connectorIdInModel,
            connectorId,
            connIdInModel2ID = {},
            primitivePropertyData = componentData.PrimitivePropertyInstance,
            property,
            propertyIdInModel,
            propertyId,
            propertyIdInModel2ID = {},
            portInstanceData = componentData.PortInstance,
            port,
            portIdInModel,
            portId,
            portIdInModel2ID = {};

        if ( self.componentID2Acm[ avmID ] ) {
            self.logger.info( 'Found ACM for : ' + componentData[ '@Name' ] );
            if ( self.copies ) {
                component = self.core.copyNode( self.componentID2Acm[ avmID ], parentNode );
            } else {
                component = self.core.createNode( {
                    parent: parentNode,
                    base: self.componentID2Acm[ avmID ]
                } );
            }
            if ( connectorInstanceData ) {
                for ( i = 0; i < connectorInstanceData.length; i += 1 ) {
                    connectorIdInModel = connectorInstanceData[ i ][ '@IDinComponentModel' ];
                    connectorId = connectorInstanceData[ i ][ '@ID' ];
                    self.addConnectionData( parentNode, connectorInstanceData[ i ] );
                    connIdInModel2ID[ connectorIdInModel ] = connectorId;
                }
            }
            if ( portInstanceData ) {
                for ( i = 0; i < portInstanceData.length; i += 1 ) {
                    portIdInModel = portInstanceData[ i ][ '@IDinComponentModel' ];
                    portId = portInstanceData[ i ][ '@ID' ];
                    self.addPortMapData( parentNode, portInstanceData[ i ] );
                    portIdInModel2ID[ portIdInModel ] = portId;
                }
            }
            if ( primitivePropertyData ) {
                for ( i = 0; i < primitivePropertyData.length; i += 1 ) {
                    propertyIdInModel = primitivePropertyData[ i ][ '@IDinComponentModel' ];
                    propertyId = primitivePropertyData[ i ].Value[ '@ID' ];
                    if ( primitivePropertyData[ i ].Value.ValueExpression ) {
                        self.valueFlows.push( {
                            src: primitivePropertyData[ i ].Value.ValueExpression[ '@ValueSource' ],
                            dst: propertyId
                        } );
                    }
                    // TODO: this is not a good way to do this...
                    propertyIdInModel2ID[ propertyIdInModel ] = propertyId;
                }
            }
            self.componentInstances.push( {
                node: component,
                connIdInModel2ID: connIdInModel2ID,
                propertyIdInModel2ID: propertyIdInModel2ID,
                portIdInModel2ID: portIdInModel2ID
            } );
        } else {
            self.logger.warning( 'Could not find ACM for ComponentInstance : ' + componentData[ '@Name' ] );
            self.logger.warning( 'Will create an empty shell model in design from avaliable data.' );
            component = self.core.createNode( {
                parent: parentNode,
                base: self.meta.AVMComponentModel
            } );
            self.core.setAttribute( component, 'ID', avmID );
            if ( connectorInstanceData ) {
                for ( i = 0; i < connectorInstanceData.length; i += 1 ) {
                    connectorIdInModel = connectorInstanceData[ i ][ '@IDinComponentModel' ];
                    connectorId = connectorInstanceData[ i ][ '@ID' ];
                    self.addConnectionData( parentNode, connectorInstanceData[ i ] );
                    // Create a dummy-connector in the dummy-component.
                    connector = self.core.createNode( {
                        parent: component,
                        base: self.meta.Connector
                    } );
                    self.core.setAttribute( connector, 'name', 'PortDummy' + i.toString() );
                    self.core.setAttribute( connector, 'ID', connectorIdInModel );
                    self.core.setRegistry( connector, 'position', {
                        x: 400,
                        y: ( 1 + i ) * 70
                    } );

                    self.connID2Node[ connectorId ] = connector;
                }
            }
            if ( primitivePropertyData ) {
                for ( i = 0; i < primitivePropertyData.length; i += 1 ) {
                    propertyId = primitivePropertyData[ i ].Value[ '@ID' ];
                    propertyIdInModel = primitivePropertyData[ i ][ '@IDinComponentModel' ];
                    if ( primitivePropertyData[ i ].Value.ValueExpression ) {
                        self.valueFlows.push( {
                            src: primitivePropertyData[ i ].Value.ValueExpression[ '@ValueSource' ],
                            dst: propertyId
                        } );
                    }
                    // Create a dummy-property in the dummy-component.
                    property = self.core.createNode( {
                        parent: component,
                        base: self.meta.Property
                    } );
                    self.core.setRegistry( property, 'position', {
                        x: 100,
                        y: ( 1 + i ) * 70
                    } );
                    self.core.setAttribute( property, 'name', 'PropertyDummy' + i.toString() );
                    self.core.setAttribute( property, 'ID', propertyIdInModel );

                    self.valueFlowTargetID2Node[ propertyId ] = property;
                }
            }
            self.createMessage( component, '"' + componentData[ '@Name' ] + '" is just a dummy..' );
        }

        self.core.setAttribute( component, 'name', componentData[ '@Name' ] );
        self.core.setRegistry( component, 'position', {
            x: parseInt( componentData[ '@XPosition' ], 10 ),
            y: parseInt( componentData[ '@YPosition' ], 10 )
        } );
    };

    AdmImporter.prototype.createConnector = function ( connectorData, parentNode ) {
        var self = this,
            i,
            connector;

        connector = self.core.createNode( {
            parent: parentNode,
            base: self.meta.Connector
        } );
        self.connID2Node[ connectorData[ '@ID' ] ] = connector;
        self.core.setAttribute( connector, 'name', connectorData[ '@Name' ] );
        // Add Domain-Connectors (Role in adm).
        if ( connectorData.Role ) {
            for ( i = 0; i < connectorData.Role.length; i += 1 ) {
                self.createDomainPort( connectorData.Role[ i ], connector );
            }
        }

        self.core.setRegistry( connector, 'position', {
            x: parseInt( connectorData[ '@XPosition' ], 10 ),
            y: parseInt( connectorData[ '@YPosition' ], 10 )
        } );

        self.addConnectionData( parentNode, connectorData );
    };

    AdmImporter.prototype.createDomainPort = function ( portData, parentNode ) {
        var self = this,
            port,
            typeName;
        port = self.core.createNode( {
            parent: parentNode,
            base: self.meta.DomainPort
        } );

        self.core.setAttribute( port, 'name', portData[ '@Name' ] );

        typeName = portData[ '@xsi:type' ];

        if ( self.endsWith( typeName, 'Connector' ) ) {
            if ( portData.hasOwnProperty( '@Class' ) ) {
                self.core.setAttribute( port, 'Type', 'ModelicaConnector' );
                self.core.setAttribute( port, 'Class', portData[ '@Class' ] );
            } else {
                self.createMessage( port, 'Domain port was of xsi:type Connector but did not ' +
                    'have a Class defined. Unknown Type: ' + JSON.stringify( portData, null, 2 ), 'error' );
            }
        } else if ( self.endsWith( typeName, 'Axis' ) ) {
            self.core.setAttribute( port, 'Type', 'CadAxis' );
        } else if ( self.endsWith( typeName, 'CoordinateSystem' ) ) {
            self.core.setAttribute( port, 'Type', 'CadCoordinateSystem' );
        } else if ( self.endsWith( typeName, 'Plane' ) ) {
            self.core.setAttribute( port, 'Type', 'CadPlane' );
        } else if ( self.endsWith( typeName, 'Point' ) ) {
            self.core.setAttribute( port, 'Type', 'CadPoint' );
        } else {
            self.createMessage( port, 'Unknown Type for domain port : ' + JSON.stringify( portData, null, 2 ),
                'error' );
        }

        self.core.setRegistry( port, 'position', {
            x: parseInt( portData[ '@XPosition' ], 10 ),
            y: parseInt( portData[ '@YPosition' ], 10 )
        } );

        self.portID2Node[ portData[ '@ID' ] ] = port;
        self.addPortMapData( parentNode, portData );
    };

    AdmImporter.prototype.createProperty = function ( propertyData, parentNode ) {
        var self = this,
            i,
            muxSources,
            property,
            value = '',
            isParameter = false,
            valueExpression,
            assignedValue,
            valueID = propertyData.Value[ '@ID' ];

        if ( propertyData.Value.ValueExpression ) {
            valueExpression = propertyData.Value.ValueExpression;
            if ( self.endsWith( valueExpression[ '@xsi:type' ], 'ParametricValue' ) ) {
                isParameter = true;
                assignedValue = valueExpression.AssignedValue;
                if ( self.endsWith( assignedValue[ '@xsi:type' ], 'FixedValue' ) ) {
                    if ( assignedValue.Value && assignedValue.Value[ '#text' ] ) {
                        value = valueExpression.AssignedValue.Value[ '#text' ];
                    }
                } else if ( self.endsWith( assignedValue[ '@xsi:type' ], 'DerivedValue' ) ) {
                    if ( self.valueFlowMuxes[ assignedValue[ '@ValueSource' ] ] ) {
                        muxSources = self.valueFlowMuxes[ assignedValue[ '@ValueSource' ] ];
                        for ( i = 0; i < muxSources.length; i += 1 ) {
                            self.valueFlows.push( {
                                src: muxSources[ i ],
                                dst: valueID
                            } );
                        }
                    } else {
                        self.valueFlows.push( {
                            src: assignedValue[ '@ValueSource' ],
                            dst: valueID
                        } );
                    }
                }
            } else if ( self.endsWith( valueExpression[ '@xsi:type' ], 'FixedValue' ) ) {
                if ( valueExpression.Value && valueExpression.Value[ '#text' ] ) {
                    value = valueExpression.Value[ '#text' ];
                }
            } else if ( self.endsWith( valueExpression[ '@xsi:type' ], 'DerivedValue' ) ) {
                if ( self.valueFlowMuxes[ valueExpression[ '@ValueSource' ] ] ) {
                    muxSources = self.valueFlowMuxes[ valueExpression[ '@ValueSource' ] ];
                    for ( i = 0; i < muxSources.length; i += 1 ) {
                        self.valueFlows.push( {
                            src: muxSources[ i ],
                            dst: valueID
                        } );
                    }
                } else {
                    self.valueFlows.push( {
                        src: valueExpression[ '@ValueSource' ],
                        dst: valueID
                    } );
                }
            }
        }

        if ( isParameter ) {
            property = self.core.createNode( {
                parent: parentNode,
                base: self.meta.Property
            } );
            self.core.setAttribute( property, 'ValueType', 'Parametric' );
            self.logger.info( 'Created Parameter "' + propertyData[ '@Name' ] + '" with value : "' + value + '".' );
            if ( valueExpression.Default && valueExpression.Default.Value[ '#text' ] ) {
                self.core.setAttribute( property, 'Default', valueExpression.Default.Value[ '#text' ] );
            }
            if ( valueExpression.Maximum && valueExpression.Maximum.Value[ '#text' ] ) {
                self.core.setAttribute( property, 'Maximum', valueExpression.Maximum.Value[ '#text' ] );
            }
            if ( valueExpression.Minimum && valueExpression.Minimum.Value[ '#text' ] ) {
                self.core.setAttribute( property, 'Minimum', valueExpression.Minimum.Value[ '#text' ] );
            }
        } else {
            property = self.core.createNode( {
                parent: parentNode,
                base: self.meta.Property
            } );
            self.logger.info( 'Created Property "' + propertyData[ '@Name' ] + '" with value : "' + value + '".' );
        }

        self.core.setAttribute( property, 'name', propertyData[ '@Name' ] );
        self.core.setAttribute( property, 'DataType', propertyData.Value[ '@DataType' ] );
        self.core.setAttribute( property, 'Value', value );
        if ( propertyData.Value[ '@Unit' ] ) {
            self.core.setAttribute( property, 'Unit', propertyData.Value[ '@Unit' ] );
        }
        self.core.setRegistry( property, 'position', {
            x: parseInt( propertyData[ '@XPosition' ], 10 ),
            y: parseInt( propertyData[ '@YPosition' ], 10 )
        } );

        self.valueFlowTargetID2Node[ valueID ] = property;
    };

    AdmImporter.prototype.createFormula = function ( formulaData, parentNode ) {
        var self = this,
            i,
            id = formulaData[ '@ID' ],
            formula,
            isSimple = formulaData.hasOwnProperty( '@Operation' ),
            operands;

        if ( isSimple ) {
            formula = self.core.createNode( {
                parent: parentNode,
                base: self.meta.SimpleFormula
            } );
            self.core.setAttribute( formula, 'Method', formulaData[ '@Operation' ] );
            if ( formulaData[ '@Operand' ] ) {
                operands = formulaData[ '@Operand' ].split( " " );
                for ( i = 0; i < operands.length; i += 1 ) {
                    self.valueFlows.push( {
                        src: operands[ i ],
                        dst: id
                    } );
                }
            }
            self.logger.info( 'Created SimpleFormula "' + formulaData[ '@Name' ] + '".' );
        } else {
            formula = self.core.createNode( {
                parent: parentNode,
                base: self.meta.CustomFormula
            } );
            self.core.setAttribute( formula, 'Expression', formulaData[ '@Expression' ] );
            if ( formulaData.Operand ) {
                operands = formulaData.Operand;
                for ( i = 0; i < operands.length; i += 1 ) {
                    self.valueFlows.push( {
                        src: operands[ i ][ '@ValueSource' ],
                        dst: id,
                        symbol: operands[ i ][ '@Symbol' ]
                    } );
                }
            }
            self.logger.info( 'Created CustomFormula "' + formulaData[ '@Name' ] + '".' );
        }
        self.core.setAttribute( formula, 'name', formulaData[ '@Name' ] );

        self.core.setRegistry( formula, 'position', {
            x: parseInt( formulaData[ '@XPosition' ], 10 ),
            y: parseInt( formulaData[ '@YPosition' ], 10 )
        } );

        self.valueFlowTargetID2Node[ id ] = formula;
    };

    AdmImporter.prototype.addConnectionData = function ( parentNode, connectorData ) {
        var self = this,
            connectedConnectorIDs,
            i;
        if ( connectorData[ '@ConnectorComposition' ] ) {
            connectedConnectorIDs = connectorData[ '@ConnectorComposition' ].split( " " );
            for ( i = 0; i < connectedConnectorIDs.length; i += 1 ) {
                self.connectorCompositions.push( {
                    src: connectorData[ '@ID' ],
                    dst: connectedConnectorIDs[ i ]
                } );
            }
        }
    };

    AdmImporter.prototype.addPortMapData = function ( parentNode, portData ) {
        var self = this,
            connectedPortIDs,
            i;
        if ( portData[ '@PortMap' ] ) {
            connectedPortIDs = portData[ '@PortMap' ].split( " " );
            for ( i = 0; i < connectedPortIDs.length; i += 1 ) {
                self.portMaps.push( {
                    src: portData[ '@ID' ],
                    dst: connectedPortIDs[ i ]
                } );
            }
        }
    };
    //</editor-fold>

    //<editor-fold desc="============================ Making of connections =========================">
    AdmImporter.prototype.gatherComponentInstanceContent = function ( callback ) {
        var self = this,
            i,
            error = '',
            counter = self.componentInstances.length,
            afterLoadChildren = function ( componentInstance ) {
                return function ( err, children ) {
                    counter -= 1;
                    if ( err ) {
                        error += err;
                    } else {
                        self.addToConnectorsAndPropertiesMaps( componentInstance, children );
                    }
                    if ( counter <= 0 ) {
                        callback( error );
                    }
                };
            };

        if ( counter === 0 ) {
            callback( null );
            return;
        }
        for ( i = 0; i < self.componentInstances.length; i += 1 ) {
            self.core.loadChildren( self.componentInstances[ i ].node, afterLoadChildren( self.componentInstances[
                i ] ) );
        }
    };

    AdmImporter.prototype.addToConnectorsAndPropertiesMaps = function ( componentInstance, children ) {
        //        self.componentInstances.push({
        //            node: component,
        //            connIdInModel2ID: connIdInModel2ID,
        //            propertyIdInModel2ID: propertyIdInModel2ID
        //        });
        var self = this,
            i,
            id,
            metaTypeName;

        for ( i = 0; i < children.length; i += 1 ) {
            metaTypeName = self.core.getAttribute( self.getMetaType( children[ i ] ), 'name' );
            if ( metaTypeName === 'Connector' ) {
                id = self.core.getAttribute( children[ i ], 'ID' );
                if ( componentInstance.connIdInModel2ID[ id ] ) {
                    self.connID2Node[ componentInstance.connIdInModel2ID[ id ] ] = children[ i ];
                } else {
                    self.logger.error( 'ConnectorID' + id + ' not in ' + self.core.getAttribute( componentInstance.node,
                        'name' ) );
                }
            } else if ( metaTypeName === 'Property' ) {
                id = self.core.getAttribute( children[ i ], 'ID' );
                if ( componentInstance.propertyIdInModel2ID[ id ] ) {
                    self.valueFlowTargetID2Node[ componentInstance.propertyIdInModel2ID[ id ] ] = children[ i ];
                } else {
                    self.logger.error( 'PropertyID' + id + ' not in ' + self.core.getAttribute( componentInstance.node,
                        'name' ) );
                }
            } else if ( metaTypeName === 'DomainPort' ) {
                id = self.core.getAttribute( children[ i ], 'ID' );
                if ( componentInstance.portIdInModel2ID[ id ] ) {
                    self.portID2Node[ componentInstance.portIdInModel2ID[ id ] ] = children[ i ];
                } else {
                    self.logger.error( 'PortID' + id + ' not in ' + self.core.getAttribute( componentInstance.node,
                        'name' ) );
                }
            }
        }
    };

    AdmImporter.prototype.makeConnectorCompositions = function () {
        var self = this,
            srcID,
            dstID,
            parentNode,
            srcNode,
            dstNode,
            i,
            connectionNode,
            jointID,
            filteredConnections = {};

        for ( i = 0; i < self.connectorCompositions.length; i += 1 ) {
            srcID = self.connectorCompositions[ i ].src;
            dstID = self.connectorCompositions[ i ].dst;
            jointID = srcID + '__' + dstID;
            if ( filteredConnections[ jointID ] ) {
                // self.logger.info('Connection between ' + jointID + ' already added.');
            } else {
                self.logger.info( 'Adding [src] ' + srcID + ' and [dst]' + dstID );
                jointID = dstID + '__' + srcID;
                filteredConnections[ jointID ] = true;
                srcNode = self.connID2Node[ srcID ];
                dstNode = self.connID2Node[ dstID ];
                parentNode = self.getConnectionParent( srcNode, dstNode, srcID, dstID );
                if ( parentNode ) {
                    connectionNode = self.core.createNode( {
                        parent: parentNode,
                        base: self.meta.ConnectorComposition
                    } );
                    self.core.setPointer( connectionNode, 'src', srcNode );
                    self.core.setPointer( connectionNode, 'dst', dstNode );
                } else {
                    self.logger.error( 'Could not make connector-composition between src: ' + srcID +
                        ' and dst: ' + dstID + '.' );
                }
            }
        }
    };

    AdmImporter.prototype.makePortMaps = function () {
        var self = this,
            srcID,
            dstID,
            parentNode,
            srcNode,
            dstNode,
            i,
            portMapNode,
            jointID,
            filteredPortMaps = {};

        for ( i = 0; i < self.portMaps.length; i += 1 ) {
            srcID = self.portMaps[ i ].src;
            dstID = self.portMaps[ i ].dst;
            jointID = srcID + '__' + dstID;
            if ( filteredPortMaps[ jointID ] ) {
                // self.logger.info('Connection between ' + jointID + ' already added.');
            } else {
                self.logger.info( 'Adding [src] ' + srcID + ' and [dst]' + dstID );
                jointID = dstID + '__' + srcID;
                filteredPortMaps[ jointID ] = true;
                srcNode = self.portID2Node[ srcID ];
                dstNode = self.portID2Node[ dstID ];
                parentNode = self.getConnectionParent( srcNode, dstNode, srcID, dstID );
                if ( parentNode ) {
                    portMapNode = self.core.createNode( {
                        parent: parentNode,
                        base: self.meta.PortMap
                    } );
                    self.core.setPointer( portMapNode, 'src', srcNode );
                    self.core.setPointer( portMapNode, 'dst', dstNode );
                } else {
                    self.logger.error( 'Could not make port-map between src: ' + srcID +
                        ' and dst: ' + dstID + '.' );
                }
            }
        }
    };

    AdmImporter.prototype.makeValueFlows = function () {
        var self = this,
            i,
            srcNode,
            dstNode,
            symbol,
            parentNode,
            valueFlowNode;
        for ( i = 0; i < self.valueFlows.length; i += 1 ) {
            srcNode = self.valueFlowTargetID2Node[ self.valueFlows[ i ].src ];
            dstNode = self.valueFlowTargetID2Node[ self.valueFlows[ i ].dst ];
            symbol = self.valueFlows[ i ].symbol;
            parentNode = self.getConnectionParent( srcNode, dstNode, self.valueFlows[ i ].src, self.valueFlows[ i ]
                .dst );
            if ( parentNode ) {
                valueFlowNode = self.core.createNode( {
                    parent: parentNode,
                    base: self.meta.ValueFlowComposition
                } );
                self.core.setPointer( valueFlowNode, 'src', srcNode );
                self.core.setPointer( valueFlowNode, 'dst', dstNode );
                if ( symbol ) {
                    self.logger.info( 'About to add value-flow into customFormula' );
                    if ( symbol !== self.core.getAttribute( srcNode, 'name' ) ) {
                        self.core.setAttribute( valueFlowNode, 'VariableName', symbol );
                    }
                }
            } else {
                self.logger.error( 'Could not make value-flow connection between src: ' + self.valueFlows[ i ].src +
                    ' and dst: ' + self.valueFlows[ i ].dst + '.' );
            }
        }
    };

    AdmImporter.prototype.getConnectionParent = function ( srcNode, dstNode, srcId, dstId ) {
        var self = this,
            parent,
            errMsg,
            srcParent,
            dstParent,
            srcDepth,
            dstDepth;
        if ( !srcNode || !dstNode ) {
            errMsg = 'Making connection not possible srcID: "' + srcId + '", dstID: "' + dstId + '".';
            if ( srcNode ) {
                errMsg += ' SrcNode exists, name: "' + self.core.getAttribute( srcNode, 'name' ) + '", parent : "' +
                    self.core.getAttribute( self.core.getParent( srcNode ), 'name' ) + '".';
            } else {
                errMsg += ' The srcNode does not exist!';
            }
            if ( dstNode ) {
                errMsg += ' DstNode exists, name: "' + self.core.getAttribute( dstNode, 'name' ) + '", parent : "' +
                    self.core.getAttribute( self.core.getParent( dstNode ), 'name' ) + '".';
            } else {
                errMsg += ' The dstNode does not exist!';
            }
            self.currentSuccess = false;
            self.createMessage( dstNode || srcNode || null, errMsg, 'error' );
            return null;
        }
        srcParent = self.core.getParent( srcNode );
        dstParent = self.core.getParent( dstNode );
        if ( srcParent === dstParent && self.isMetaTypeOf( srcParent, self.META.Connector ) ) {
            parent = self.core.getParent( srcParent );
        } else if ( srcParent === dstParent ) {
            parent = srcParent;
        } else {
            srcDepth = self.core.getPath( srcParent )
                .split( '/' )
                .length;
            dstDepth = self.core.getPath( dstParent )
                .split( '/' )
                .length;
            if ( srcDepth < dstDepth ) {
                parent = srcParent;
            } else if ( dstDepth > srcDepth ) {
                parent = dstParent;
            } else {
                parent = self.core.getParent( srcParent );
            }
        }
        return parent;
    };

    //</editor-fold>

    AdmImporter.prototype.endsWith = function ( str, ending ) {
        var lastIndex = str.lastIndexOf( ending );
        return ( lastIndex !== -1 ) && ( lastIndex + ending.length === str.length );
    };

    AdmImporter.prototype.startsWith = function ( str, start ) {
        if ( start === '' ) {
            return true;
        }
        return start.length > 0 && str.substring( 0, start.length ) === start;
    };

    return AdmImporter;
} );