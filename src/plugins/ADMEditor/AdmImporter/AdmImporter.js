/* global define */
/**
 * Generated by PluginGenerator from webgme on Mon Apr 14 2014 10:15:45 GMT-0500 (Central Daylight Time).
 */
// TODO: Get the json data dynamically!
define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'plugin/AdmImporter/AdmImporter/meta',
    'xmljsonconverter'
], function (PluginConfig, PluginBase, MetaTypes, Converter) {
    'use strict';
    //<editor-fold desc="============================ Class Definition ================================">
    /**
     * Initializes a new instance of AdmImporter.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin AdmImporter.
     * @constructor
     */
    var AdmImporter = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.meta = MetaTypes;
        this.acmCounter = 0;
        this.componentID2Acm = {};
        this.componentID2PrintInfo = {};
        // printInfoDataType = {
        //    name: {string},
        //    count: {int},
        //    parentName: {string}
        // };
        this.componentInstances = [];
        //        componentInstancesDataType = {
        //            node: {nodeObj},
        //            id: {str},
        //            connIdInModel2ID: {object},
        //            propertyIdInModel2ID: {object},
        //            portIdInModel2ID: {object},
        //        };
        this.connID2Node = {};
        this.portID2Node = {};
        this.valueFlowTargetID2Node = {};
        this.valueFlows = [];
        //        valueFlowsDataType = {
        //            src: {string},
        //            dst: {string}
        //        };
        this.valueFlowMuxes = {};
        this.connectorCompositions = [];
        //        connectorCompositionsDataType = {
        //            src: {string},
        //            dst: {string}
        //        };
        this.portMaps = [];
        //        portMapsDataType = {
        //            src: {string},
        //            dst: {string}
        //        };
        this.admData = null;
        this.copies = false;
        this.currentSuccess = true;
    };

    // Prototypal inheritance from PluginBase.
    AdmImporter.prototype = Object.create(PluginBase.prototype);
    AdmImporter.prototype.constructor = AdmImporter;

    /**
     * Gets the name of the AdmImporter.
     * @returns {string} The name of the plugin.
     * @public
     */
    AdmImporter.prototype.getName = function () {
        return "ADM Importer";
    };

    /**
     * Gets the description of the AdmImporter.
     * @returns {string} The description of the plugin.
     * @public
     */
    AdmImporter.prototype.getDescription = function () {
        return "Imports an adm-file generated from desktop GME.";
    };

    /**
     * Gets the semantic version (semver.org) of the AdmImporter.
     * @returns {string} The version of the plugin.
     * @public
     */
    AdmImporter.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
     * Gets the configuration structure for the AdmImporter.
     * The ConfigurationStructure defines the configuration for the plugin
     * and will be used to populate the GUI when invoking the plugin from webGME.
     * @returns {object} The version of the plugin.
     * @public
     */
    AdmImporter.prototype.getConfigStructure = function () {
        return [{
            'name': 'admFile',
            'displayName': 'ADM file',
            'description': 'AVM Design Model.',
            'value': "",
            'valueType': 'asset',
            'readOnly': false
        }];
    };
    //</editor-fold>
    AdmImporter.prototype.innerMain = function (xmlArrayBuffer, callback, finnishPlugin) {
        var self = this,
            xml2json = new Converter.Xml2json({
                skipWSText: true,
                arrayElements: self.arrayElementsInXml
            }),
            admFolder = self.activeNode,
            workspaceNode;

        self.updateMETA(self.meta);
        //self.copies = config.copies;
        self.copies = true;
        if (typeof xmlArrayBuffer === 'string') {
            self.admData = xml2json.convertFromString(xmlArrayBuffer);
        } else {
            self.admData = xml2json.convertFromBuffer(xmlArrayBuffer);
        }
        if (self.admData instanceof Error) {
            self.createMessage(null, 'Given adm not valid xml: ' + self.admData.message, 'error');
            callback(null, self.result);
            return;
        }

        self.admData = self.admData['Design'];
        workspaceNode = self.getWorkspaceNode(admFolder);
        //timeStamp = new Date().getTime();
        self.exploreACMs(workspaceNode, false, function (err) {
            if (err) {
                callback(err, self.result);
                return;
            }
            //self.createMessage(null, 'ExecTime [s] exploreACMs     :: ' +
            //        ((new Date().getTime() - timeStamp) / 1000).toString());
            if (self.acmCounter > 0) {
                self.createMessage(workspaceNode, 'Work-space did not have all ACMs used by the design.',
                    'error');
                self.logMissingACMsToResult();
                callback(null, self.result);
                return;
            }
            //timeStamp = new Date().getTime();
            self.container = self.createAdmDesign(admFolder);
            //self.createMessage(null, 'ExecTime [s] createAdmDesign :: ' +
            //    ((new Date().getTime() - timeStamp) / 1000).toString());
            if (false) {
                self.makeConnectorCompositions();
                self.makeValueFlows();
                finnishPlugin(null);
            } else {
                //timeStamp = new Date().getTime();
                self.gatherComponentInstanceContent(function (err) {
                    //self.createMessage(null, 'ExecTime [s] gatherComponentInstanceContent :: ' +
                    //    ((new Date().getTime() - timeStamp) / 1000).toString());
                    if (err) {
                        finnishPlugin(err);
                    } else {
                        //timeStamp = new Date().getTime();
                        self.makeConnectorCompositions();
                        //self.createMessage(null, 'ExecTime [s] makeConnectorCompositions :: ' +
                        //    ((new Date().getTime() - timeStamp) / 1000).toString());
                        //timeStamp = new Date().getTime();
                        self.makeValueFlows();
                        //self.createMessage(null, 'ExecTime [s] makeValueFlows :: ' +
                        //    ((new Date().getTime() - timeStamp) / 1000).toString());
                        self.makePortMaps();
                        finnishPlugin(null);
                    }
                });
            }
        });
    };

    AdmImporter.prototype.arrayElementsInXml = {
        Design: false,
        RootContainer: false,
        Value: false,
        Container: true,
        Connector: true,
        Property: true,
        Formula: true,
        Operand: true,
        ValueFlowMux: true,
        ComponentInstance: true,
        PrimitivePropertyInstance: true,
        ConnectorInstance: true,
        PortInstance: true,
        Role: true,
        Port: true,
        ContainerFeature: true
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always have to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    AdmImporter.prototype.main = function (callback) {
        var self = this,
            config = self.getCurrentConfig(),
        //timeStamp,
            timeStart = new Date()
                .getTime(),
            debug = false,
            finnishPlugin = function (err) {
                if (err) {
                    callback(err, self.result);
                    return;
                }

                if (debug) {
                    self.saveDebugArtifacts(callback);
                } else {
                    //timeStamp = new Date().getTime();
                    self.save('added obj', function (err) {
                        if (err) {
                            callback(err, self.result);
                            return;
                        }
                        //self.createMessage(null, 'ExecTime [s] save :: ' +
                        //    ((new Date().getTime() - timeStamp) / 1000).toString());

                        if (self.currentSuccess === false) {
                            self.createMessage(null,
                                'There were issues in the matched ACMs. Incomplete model still ' +
                                'imported - make sure to address the reported issues.', 'warning');
                        }
                        //                        self.createMessage(null, 'ExecTime [s] total :: ' +
                        //                            ((new Date().getTime() - timeStart) / 1000).toString());
                        self.result.setSuccess(self.currentSuccess);
                        callback(null, self.result);
                    });
                }
            };

        if (!self.activeNode) {
            self.createMessage(null,
                'Active node is not present! This happens sometimes... Loading another model ' +
                'and trying again will solve it most of times.', 'error');
            callback('Active node is not present!', self.result);
            return;
        }

        if (self.isMetaTypeOf(self.activeNode, self.META.ADMFolder) === false) {
            self.createMessage(null, 'This plugin must be called from an ADMFolder.', 'error');
            callback(null, self.result);
            return;
        }
        if (!config.admFile) {
            self.createMessage(null, 'No adm file provided', 'error');
            callback(null, self.result);
            return;
        }
        self.blobClient.getObject(config.admFile, function (err, xmlArrayBuffer) {
            self.innerMain(xmlArrayBuffer, callback, finnishPlugin);
        });
    };

    AdmImporter.prototype.saveDebugArtifacts = function (callback) {
        var self = this,
            artie,
            json2xml,
            debugFiles;

        json2xml = new Converter.Json2xml();
        debugFiles = {
            'design.json': JSON.stringify({
                Design: self.admData
            }, null, 4),
            'design.adm': json2xml.convertToString({
                Design: self.admData
            })
        };
        artie = self.blobClient.createArtifact('debugFiles');
        artie.addFiles(debugFiles, function (err, hashes) {
            if (err) {
                self.result.setSuccess(false);
                callback('Could not add debug files : err' + err.toString(), self.result);
                return;
            }
            artie.save(function (err, hash) {
                if (err) {
                    self.result.setSuccess(false);
                    callback('Could not save artifact : err' + err.toString(), self.result);
                    return;
                }
                self.result.setSuccess(true);
                self.result.addArtifact(hash);
                callback(null, self.result);
            });
        });
    };

    //<editor-fold desc="============================ Gathering of ACM Info ===========================">
    AdmImporter.prototype.getWorkspaceNode = function (node) {
        var self = this;
        while (node) {
            if (self.isMetaTypeOf(node, self.meta.WorkSpace)) {
                self.logger.info('Found WorkSpace-Node : ' + self.core.getAttribute(node, 'name'));
                return node;
            }
            node = self.core.getParent(node);
        }
        self.logger.error('Could not find WorkSpace!!');
    };

    AdmImporter.prototype.exploreACMs = function (node, dummyACMs, callback) {
        var self = this;
        if (dummyACMs) {
            callback(null);
            return;
        }
        self.initializeComponentMap(self.admData.RootContainer);
        self.logger.info('Number of unique ACMs (acmCounter) is ' + self.acmCounter.toString());
        self.core.loadChildren(node, function (err, children) {
            var counter,
                i,
                counterCallback,
                error = '';
            // Check for error in loading before doing recursion.
            if (err) {
                callback('Could not load children for project, err: ' + err, self.result);
                return;
            }
            if (children.length === 0) {
                callback(null);
                return;
            }
            // Define a counter and callback for the recursion.
            counter = {
                visits: children.length
            };
            counterCallback = function (err) {
                error = err ? error += err : error;
                counter.visits -= 1;
                if (counter.visits === 0) {
                    callback(error);
                }
            };
            // Iterate over children and invoke recursion on ACMFolders.
            for (i = 0; i < children.length; i += 1) {
                if (self.isMetaTypeOf(children[i], self.meta.ACMFolder)) {
                    self.visitComponentsRec(children[i], counter, counterCallback);
                } else {
                    counterCallback(null);
                }
            }
        });
    };

    AdmImporter.prototype.initializeComponentMap = function (container) {
        var self = this,
            i,
            subContainers,
            components,
            id;

        if (container.ComponentInstance) {
            components = container.ComponentInstance;
            for (i = 0; i < components.length; i += 1) {
                id = components[i]['@ComponentID'];
                if (self.componentID2Acm[id] === undefined) {
                    self.componentID2Acm[id] = false;
                    self.acmCounter += 1;
                    self.componentID2PrintInfo[id] = {
                        name: components[i]['@Name'],
                        count: 1,
                        parentName: container['@Name']
                    };
                } else {
                    self.componentID2PrintInfo[id].count += 1;
                }
            }
        }

        if (container.Container) {
            subContainers = container.Container;
            for (i = 0; i < subContainers.length; i += 1) {
                self.initializeComponentMap(subContainers[i]);
            }
        }
    };

    AdmImporter.prototype.visitComponentsRec = function (node, counter, callback) {
        var self = this,
            name = self.core.getAttribute(node, 'name'),
            childName;
        self.logger.info('visitComponentsRec at node "' + name + '" acmCounter is:   ' + self.acmCounter.toString());
        if (self.acmCounter <= 0) {
            callback(null);
            return;
        }
        self.core.loadChildren(node, function (err, children) {
            var i,
                componentID;
            if (err) {
                callback(' loadChildren failed for component ' + name + ' with error : ' + err);
                return;
            }
            counter.visits += children.length;

            if (children.length === 0) {
                // The only chance for callback to be called.
                callback(null);
            } else {
                // The node needs to be accounted for.
                counter.visits -= 1;
            }
            for (i = 0; i < children.length; i += 1) {
                if (self.isMetaTypeOf(children[i], self.meta.ACMFolder)) {
                    self.visitComponentsRec(children[i], counter, callback);
                } else if (self.isMetaTypeOf(children[i], self.meta.AVMComponentModel)) {
                    componentID = self.core.getAttribute(children[i], 'ID');
                    childName = self.core.getAttribute(children[i], 'name');
                    if (self.componentID2Acm[componentID] === false) {
                        self.componentID2Acm[componentID] = children[i];
                        self.logger.info('Found matching ACM "' + childName + '"');
                        self.acmCounter -= 1;
                    } else if (self.componentID2Acm[componentID] === undefined) {
                        self.logger.info('ACM "' + childName + '" is not part of the design.');
                    } else {
                        self.logger.warn('Found duplicate ACM ID "' + componentID + '". "' + childName +
                        '" at "' +
                        self.core.getPath(children[i]) + '" will not be used.');
                    }
                    callback(null);
                } else {
                    callback(null);
                }
            }
        });
    };

    AdmImporter.prototype.logMissingACMsToResult = function () {
        var self = this,
            missingIDs = [],
            key,
            i,
            info;
        for (key in self.componentID2Acm) {
            if (self.componentID2Acm.hasOwnProperty(key)) {
                if (self.componentID2Acm[key] === false) {
                    missingIDs.push(key);
                }
            }
        }
        for (i = 0; i < missingIDs.length; i += 1) {
            info = self.componentID2PrintInfo[missingIDs[i]];
            self.createMessage(null, 'ACM "' + info.name + '", in ADM "' + info.parentName + '" did not have a ' +
            'matching ACM with ID "' + missingIDs[i] + '". (The component ocurres ' + info.count.toString() +
            ' times in the ADM.)', 'error');
        }
    };
    //</editor-fold>

    //<editor-fold desc="=========================== Creation of ADM objects ==========================">
    AdmImporter.prototype.createAdmDesign = function (admFolder) {
        var self = this;
        return self.createContainer(self.admData.RootContainer, admFolder, 0);
    };

    AdmImporter.prototype.createContainer = function (containerData, parentNode, depth) {
        var self = this,
            container,
            subContainersData,
            componentsData,
            connectorsData,
            portData,
            propertiesData,
            formulasData,
            muxData,
            i,
            indent = new Array(depth + 2)
                .join('-');
        // Create the container and set attributes and registry.
        container = self.core.createNode({
            parent: parentNode,
            base: self.meta.Container
        });
        self.core.setAttribute(container, 'name', containerData['@Name']);
        self.core.setAttribute(container, 'Type', containerData['@xsi:type'].slice("avm:".length));
        if (depth === 0) {
            self.core.setRegistry(container, 'position', {
                x: 100,
                y: 100
            });
        } else {
            self.core.setRegistry(container, 'position', {
                x: parseInt(containerData['@XPosition'], 10),
                y: parseInt(containerData['@YPosition'], 10)
            });
        }

        self.logger.info(indent + 'Created Container : ' + containerData['@Name']);
        depth += 1;

        // Go through the containment and add the child-objects.
        if (containerData.Container) {
            subContainersData = containerData.Container;
            for (i = 0; i < subContainersData.length; i += 1) {
                self.createContainer(subContainersData[i], container, depth);
            }
        }

        if (containerData.ValueFlowMux) {
            muxData = containerData.ValueFlowMux;
            for (i = 0; i < muxData.length; i += 1) {
                self.valueFlowMuxes[muxData[i]['@ID']] = muxData[i]['@Source'].split(' ');
            }
        }

        if (containerData.ComponentInstance) {
            componentsData = containerData.ComponentInstance;
            for (i = 0; i < componentsData.length; i += 1) {
                self.createComponent(componentsData[i], container);
                self.logger.info(indent + 'Created Component : ' + componentsData[i]['@Name']);
            }
        }

        if (containerData.ContainerFeature) {
            var features = containerData.ContainerFeature;
            for (i = 0; i < features.length; i += 1) {
                self.createContainerFeature(features[i], container);
                self.logger.info(indent + 'Created ContainerFeature : ' + features[i]['@xsi:type']);
            }
        }

        if (containerData.Connector) {
            connectorsData = containerData.Connector;
            for (i = 0; i < connectorsData.length; i += 1) {
                self.createConnector(connectorsData[i], container);
                self.logger.info(indent + 'Created Connector : ' + connectorsData[i]['@Name']);
            }
        }

        if (containerData.Port) {
            portData = containerData.Port;
            for (i = 0; i < portData.length; i += 1) {
                self.createDomainPort(portData[i], container);
                self.logger.info(indent + 'Created DomainPort : ' + portData[i]['@Name']);
            }
        }

        if (containerData.Property) {
            propertiesData = containerData.Property;
            for (i = 0; i < propertiesData.length; i += 1) {
                self.createProperty(propertiesData[i], container);
            }
        }

        if (containerData.Formula) {
            formulasData = containerData.Formula;
            for (i = 0; i < formulasData.length; i += 1) {
                self.createFormula(formulasData[i], container);
            }
        }

        return container;
    };

    AdmImporter.prototype.createComponent = function (componentData, parentNode) {
        var self = this,
            i,
            avmID = componentData['@ComponentID'],
            component,
            connectorInstanceData = componentData.ConnectorInstance,
            connector,
            connectorIdInModel,
            connectorId,
            connIdInModel2ID = {},
            primitivePropertyData = componentData.PrimitivePropertyInstance,
            property,
            propertyIdInModel,
            propertyId,
            propertyIdInModel2ID = {},
            portInstanceData = componentData.PortInstance,
            port,
            portIdInModel,
            portId,
            portIdInModel2ID = {};

        if (self.componentID2Acm[avmID]) {
            self.logger.info('Found ACM for : ' + componentData['@Name']);
            if (self.copies) {
                component = self.core.copyNode(self.componentID2Acm[avmID], parentNode);
            } else {
                component = self.core.createNode({
                    parent: parentNode,
                    base: self.componentID2Acm[avmID]
                });
            }
            if (connectorInstanceData) {
                for (i = 0; i < connectorInstanceData.length; i += 1) {
                    connectorIdInModel = connectorInstanceData[i]['@IDinComponentModel'];
                    connectorId = connectorInstanceData[i]['@ID'];
                    self.addConnectionData(parentNode, connectorInstanceData[i]);
                    connIdInModel2ID[connectorIdInModel] = connectorId;
                }
            }
            if (portInstanceData) {
                for (i = 0; i < portInstanceData.length; i += 1) {
                    portIdInModel = portInstanceData[i]['@IDinComponentModel'];
                    portId = portInstanceData[i]['@ID'];
                    self.addPortMapData(parentNode, portInstanceData[i]);
                    portIdInModel2ID[portIdInModel] = portId;
                }
            }
            if (primitivePropertyData) {
                for (i = 0; i < primitivePropertyData.length; i += 1) {
                    propertyIdInModel = primitivePropertyData[i]['@IDinComponentModel'];
                    propertyId = primitivePropertyData[i].Value['@ID'];
                    if (primitivePropertyData[i].Value.ValueExpression) {
                        self.valueFlows.push({
                            src: primitivePropertyData[i].Value.ValueExpression['@ValueSource'],
                            dst: propertyId
                        });
                    }
                    // TODO: this is not a good way to do this...
                    propertyIdInModel2ID[propertyIdInModel] = propertyId;
                }
            }
            self.componentInstances.push({
                node: component,
                id: componentData["@ID"],
                connIdInModel2ID: connIdInModel2ID,
                propertyIdInModel2ID: propertyIdInModel2ID,
                portIdInModel2ID: portIdInModel2ID
            });
        } else {
            self.logger.warn('Could not find ACM for ComponentInstance : ' + componentData['@Name']);
            self.logger.warn('Will create an empty shell model in design from avaliable data.');
            component = self.core.createNode({
                parent: parentNode,
                base: self.meta.AVMComponentModel
            });
            self.core.setAttribute(component, 'ID', avmID);
            if (connectorInstanceData) {
                for (i = 0; i < connectorInstanceData.length; i += 1) {
                    connectorIdInModel = connectorInstanceData[i]['@IDinComponentModel'];
                    connectorId = connectorInstanceData[i]['@ID'];
                    self.addConnectionData(parentNode, connectorInstanceData[i]);
                    // Create a dummy-connector in the dummy-component.
                    connector = self.core.createNode({
                        parent: component,
                        base: self.meta.Connector
                    });
                    self.core.setAttribute(connector, 'name', 'PortDummy' + i.toString());
                    self.core.setAttribute(connector, 'ID', connectorIdInModel);
                    self.core.setRegistry(connector, 'position', {
                        x: 400,
                        y: ( 1 + i ) * 70
                    });

                    self.connID2Node[connectorId] = connector;
                }
            }
            if (primitivePropertyData) {
                for (i = 0; i < primitivePropertyData.length; i += 1) {
                    propertyId = primitivePropertyData[i].Value['@ID'];
                    propertyIdInModel = primitivePropertyData[i]['@IDinComponentModel'];
                    if (primitivePropertyData[i].Value.ValueExpression) {
                        self.valueFlows.push({
                            src: primitivePropertyData[i].Value.ValueExpression['@ValueSource'],
                            dst: propertyId
                        });
                    }
                    // Create a dummy-property in the dummy-component.
                    property = self.core.createNode({
                        parent: component,
                        base: self.meta.Property
                    });
                    self.core.setRegistry(property, 'position', {
                        x: 100,
                        y: ( 1 + i ) * 70
                    });
                    self.core.setAttribute(property, 'name', 'PropertyDummy' + i.toString());
                    self.core.setAttribute(property, 'ID', propertyIdInModel);

                    self.valueFlowTargetID2Node[propertyId] = property;
                }
            }
            self.createMessage(component, '"' + componentData['@Name'] + '" is just a dummy..');
        }

        self.core.setAttribute(component, 'name', componentData['@Name']);
        self.core.setRegistry(component, 'position', {
            x: parseInt(componentData['@XPosition'], 10),
            y: parseInt(componentData['@YPosition'], 10)
        });
    };

    AdmImporter.prototype.createContainerFeature = function (featureData, container) {
        function setOriginForRelativeConstraint() {
            var origin = self.componentInstances.filter(function (ci) {
                return ci.id === featureData['@Origin'];
            });
            if (origin.length) {
                self.core.setPointer(feature, 'Origin', origin[0].node);
            } else {
                self.createMessage(container, 'Could not find Origin ' + featureData['@Origin'], 'error');
            }
        }
        function setRangeValues(attrSuffix) {
            if (featureData['@X' + attrSuffix + 'Min'] && featureData['@X' + attrSuffix + 'Max']) {
                self.core.setAttribute(feature, 'X' + attrSuffix, featureData['@X' + attrSuffix + 'Min'] + ":" + featureData[
                    '@X' + attrSuffix + 'Max']);
            }
            if (featureData['@Y' + attrSuffix + 'Min'] && featureData['@Y' + attrSuffix + 'Max']) {
                self.core.setAttribute(feature, 'Y' + attrSuffix, featureData['@Y' + attrSuffix + 'Min'] + ":" + featureData[
                    '@Y' + attrSuffix + 'Max']);
            }
        }
        var self = this;
        var feature;

        if (['eda:RelativeLayoutConstraint', 'eda:ExactLayoutConstraint', 'eda:RangeLayoutConstraint', 'eda:RelativeRangeLayoutConstraint'].indexOf(
                featureData['@xsi:type']) !== -1) {
            var type = featureData['@xsi:type'].substr(4);
            var ids = ( featureData['@ConstraintTarget'] || '' )
                .split(' ');
            var constraintTargets = self.componentInstances.filter(function (comp) {
                return ids.indexOf(comp.id) !== -1;
            });
            feature = self.core.createNode({
                parent: container,
                base: self.meta[type]
            });

            var copyAttrIfSet = function (attrName, xform) {
                if (!xform) {
                    xform = function (attr) {
                        return attr;
                    };
                }
                if (featureData['@' + attrName]) {
                    self.core.setAttribute(feature, attrName, xform(featureData['@' + attrName]));
                }
            };
            if (type === 'RelativeLayoutConstraint') {
                copyAttrIfSet('XOffset');
                copyAttrIfSet('YOffset');
                copyAttrIfSet('RelativeLayer');
                setOriginForRelativeConstraint();
            }
            if (type === 'RelativeRangeLayoutConstraint') {
                self.core.setAttribute(feature, 'RelativeLayer', 'No Restriction');
                copyAttrIfSet('RelativeLayer');
                setRangeValues('RelativeRange');
                setOriginForRelativeConstraint();
            }
            if (type === 'ExactLayoutConstraint') {
                copyAttrIfSet('X');
                copyAttrIfSet('Y');
                copyAttrIfSet('Layer');
                copyAttrIfSet('Rotation', function (val) {
                    return val.substr(1);
                });
            }
            if (type === 'RangeLayoutConstraint') {
                self.core.setAttribute(feature, 'LayerRange', 'Either');
                copyAttrIfSet('LayerRange');
                copyAttrIfSet('Type');
                setRangeValues('Range');
            }
            self.core.setAttribute(feature, 'name', type);
            constraintTargets.forEach(function (componentInstance) {
                self.core.addMember(feature, 'ConstraintTarget', componentInstance.node);
            });
        } else {
            self.createMessage(container, 'Unknown ContainerFeature type ' + featureData['@xsi:type'], 'error');
            return;
        }

        self.core.setRegistry(feature, 'position', {
            x: parseInt(featureData['@XPosition'], 10),
            y: parseInt(featureData['@YPosition'], 10)
        });
    };

    AdmImporter.prototype.createConnector = function (connectorData, parentNode) {
        var self = this,
            i,
            connector;

        connector = self.core.createNode({
            parent: parentNode,
            base: self.meta.Connector
        });
        self.connID2Node[connectorData['@ID']] = connector;
        self.core.setAttribute(connector, 'name', connectorData['@Name']);
        // Add Domain-Connectors (Role in adm).
        if (connectorData.Role) {
            for (i = 0; i < connectorData.Role.length; i += 1) {
                self.createDomainPort(connectorData.Role[i], connector);
            }
        }

        self.core.setRegistry(connector, 'position', {
            x: parseInt(connectorData['@XPosition'], 10),
            y: parseInt(connectorData['@YPosition'], 10)
        });

        self.addConnectionData(parentNode, connectorData);
    };

    AdmImporter.prototype.createDomainPort = function (portData, parentNode) {
        var self = this,
            port,
            typeName;
        port = self.core.createNode({
            parent: parentNode,
            base: self.meta.DomainPort
        });

        self.core.setAttribute(port, 'name', portData['@Name']);

        typeName = portData['@xsi:type'];

        if (self.endsWith(typeName, 'Connector')) {
            if (portData.hasOwnProperty('@Class')) {
                self.core.setAttribute(port, 'Type', 'ModelicaConnector');
                self.core.setAttribute(port, 'Class', portData['@Class']);
            } else {
                self.createMessage(port, 'Domain port was of xsi:type Connector but did not ' +
                'have a Class defined. Unknown Type: ' + JSON.stringify(portData, null, 2), 'error');
            }
        } else if (self.endsWith(typeName, 'Axis')) {
            self.core.setAttribute(port, 'Type', 'CadAxis');
        } else if (self.endsWith(typeName, 'CoordinateSystem')) {
            self.core.setAttribute(port, 'Type', 'CadCoordinateSystem');
        } else if (self.endsWith(typeName, 'Plane')) {
            self.core.setAttribute(port, 'Type', 'CadPlane');
        } else if (self.endsWith(typeName, 'Point')) {
            self.core.setAttribute(port, 'Type', 'CadPoint');
        } else if (self.endsWith(typeName, 'Pin')) {
            self.core.setAttribute(port, 'Type', 'SchematicPin');
        } else if (self.endsWith(typeName, 'SystemCPort')) {
            self.core.setAttribute(port, 'Type', 'SystemCPort');
        } else if (self.endsWith(typeName, 'RFPort')) {
            self.core.setAttribute(port, 'Type', 'RFPort');
        } else {
            self.createMessage(port, 'Unknown Type for domain port : ' + JSON.stringify(portData, null, 2),
                'error');
        }

        self.core.setRegistry(port, 'position', {
            x: parseInt(portData['@XPosition'], 10),
            y: parseInt(portData['@YPosition'], 10)
        });

        self.portID2Node[portData['@ID']] = port;
        self.addPortMapData(parentNode, portData);
    };

    AdmImporter.prototype.createProperty = function (propertyData, parentNode) {
        var self = this,
            i,
            muxSources,
            property,
            value = '',
            isParameter = false,
            valueExpression,
            assignedValue,
            valueID = propertyData.Value['@ID'];

        if (propertyData.Value.ValueExpression) {
            valueExpression = propertyData.Value.ValueExpression;
            if (self.endsWith(valueExpression['@xsi:type'], 'ParametricValue')) {
                isParameter = true;
                assignedValue = valueExpression.AssignedValue;
                if (self.endsWith(assignedValue['@xsi:type'], 'FixedValue')) {
                    if (assignedValue.Value && assignedValue.Value['#text']) {
                        value = valueExpression.AssignedValue.Value['#text'];
                    }
                } else if (self.endsWith(assignedValue['@xsi:type'], 'DerivedValue')) {
                    if (self.valueFlowMuxes[assignedValue['@ValueSource']]) {
                        muxSources = self.valueFlowMuxes[assignedValue['@ValueSource']];
                        for (i = 0; i < muxSources.length; i += 1) {
                            self.valueFlows.push({
                                src: muxSources[i],
                                dst: valueID
                            });
                        }
                    } else {
                        self.valueFlows.push({
                            src: assignedValue['@ValueSource'],
                            dst: valueID
                        });
                    }
                }
            } else if (self.endsWith(valueExpression['@xsi:type'], 'FixedValue')) {
                if (valueExpression.Value && valueExpression.Value['#text']) {
                    value = valueExpression.Value['#text'];
                }
            } else if (self.endsWith(valueExpression['@xsi:type'], 'DerivedValue')) {
                if (self.valueFlowMuxes[valueExpression['@ValueSource']]) {
                    muxSources = self.valueFlowMuxes[valueExpression['@ValueSource']];
                    for (i = 0; i < muxSources.length; i += 1) {
                        self.valueFlows.push({
                            src: muxSources[i],
                            dst: valueID
                        });
                    }
                } else {
                    self.valueFlows.push({
                        src: valueExpression['@ValueSource'],
                        dst: valueID
                    });
                }
            }
        }

        if (isParameter) {
            property = self.core.createNode({
                parent: parentNode,
                base: self.meta.Property
            });
            self.core.setAttribute(property, 'ValueType', 'Parametric');
            self.logger.info('Created Parameter "' + propertyData['@Name'] + '" with value : "' + value + '".');
            if (valueExpression.Default && valueExpression.Default.Value['#text']) {
                self.core.setAttribute(property, 'Default', valueExpression.Default.Value['#text']);
            }
            if (valueExpression.Maximum && valueExpression.Maximum.Value['#text']) {
                self.core.setAttribute(property, 'Maximum', valueExpression.Maximum.Value['#text']);
            }
            if (valueExpression.Minimum && valueExpression.Minimum.Value['#text']) {
                self.core.setAttribute(property, 'Minimum', valueExpression.Minimum.Value['#text']);
            }
        } else {
            property = self.core.createNode({
                parent: parentNode,
                base: self.meta.Property
            });
            self.logger.info('Created Property "' + propertyData['@Name'] + '" with value : "' + value + '".');
        }

        self.core.setAttribute(property, 'name', propertyData['@Name']);
        self.core.setAttribute(property, 'DataType', propertyData.Value['@DataType']);
        self.core.setAttribute(property, 'Value', value);
        if (propertyData.Value['@Unit']) {
            self.core.setAttribute(property, 'Unit', propertyData.Value['@Unit']);
        }
        self.core.setRegistry(property, 'position', {
            x: parseInt(propertyData['@XPosition'], 10),
            y: parseInt(propertyData['@YPosition'], 10)
        });

        self.valueFlowTargetID2Node[valueID] = property;
    };

    AdmImporter.prototype.createFormula = function (formulaData, parentNode) {
        var self = this,
            i,
            id = formulaData['@ID'],
            formula,
            isSimple = formulaData.hasOwnProperty('@Operation'),
            operands;

        if (isSimple) {
            formula = self.core.createNode({
                parent: parentNode,
                base: self.meta.SimpleFormula
            });
            self.core.setAttribute(formula, 'Method', formulaData['@Operation']);
            if (formulaData['@Operand']) {
                operands = formulaData['@Operand'].split(" ");
                for (i = 0; i < operands.length; i += 1) {
                    self.valueFlows.push({
                        src: operands[i],
                        dst: id
                    });
                }
            }
            self.logger.info('Created SimpleFormula "' + formulaData['@Name'] + '".');
        } else {
            formula = self.core.createNode({
                parent: parentNode,
                base: self.meta.CustomFormula
            });
            self.core.setAttribute(formula, 'Expression', formulaData['@Expression']);
            if (formulaData.Operand) {
                operands = formulaData.Operand;
                for (i = 0; i < operands.length; i += 1) {
                    self.valueFlows.push({
                        src: operands[i]['@ValueSource'],
                        dst: id,
                        symbol: operands[i]['@Symbol']
                    });
                }
            }
            self.logger.info('Created CustomFormula "' + formulaData['@Name'] + '".');
        }
        self.core.setAttribute(formula, 'name', formulaData['@Name']);

        self.core.setRegistry(formula, 'position', {
            x: parseInt(formulaData['@XPosition'], 10),
            y: parseInt(formulaData['@YPosition'], 10)
        });

        self.valueFlowTargetID2Node[id] = formula;
    };

    AdmImporter.prototype.addConnectionData = function (parentNode, connectorData) {
        var self = this,
            connectedConnectorIDs,
            i;
        if (connectorData['@ConnectorComposition']) {
            connectedConnectorIDs = connectorData['@ConnectorComposition'].split(" ");
            for (i = 0; i < connectedConnectorIDs.length; i += 1) {
                self.connectorCompositions.push({
                    src: connectorData['@ID'],
                    dst: connectedConnectorIDs[i]
                });
            }
        }
    };

    AdmImporter.prototype.addPortMapData = function (parentNode, portData) {
        var self = this,
            connectedPortIDs,
            i;
        if (portData['@PortMap']) {
            connectedPortIDs = portData['@PortMap'].split(" ");
            for (i = 0; i < connectedPortIDs.length; i += 1) {
                self.portMaps.push({
                    src: portData['@ID'],
                    dst: connectedPortIDs[i]
                });
            }
        }
    };
    //</editor-fold>

    //<editor-fold desc="============================ Making of connections =========================">
    AdmImporter.prototype.gatherComponentInstanceContent = function (callback) {
        var self = this,
            i,
            error = '',
            counter = self.componentInstances.length,
            afterLoadChildren = function (componentInstance) {
                return function (err, children) {
                    counter -= 1;
                    if (err) {
                        error += err;
                    } else {
                        self.addToConnectorsAndPropertiesMaps(componentInstance, children);
                    }
                    if (counter <= 0) {
                        callback(error);
                    }
                };
            };

        if (counter === 0) {
            callback(null);
            return;
        }
        for (i = 0; i < self.componentInstances.length; i += 1) {
            self.core.loadChildren(self.componentInstances[i].node, afterLoadChildren(self.componentInstances[
                i]));
        }
    };

    AdmImporter.prototype.addToConnectorsAndPropertiesMaps = function (componentInstance, children) {
        //        self.componentInstances.push({
        //            node: component,
        //            connIdInModel2ID: connIdInModel2ID,
        //            propertyIdInModel2ID: propertyIdInModel2ID
        //        });
        var self = this,
            i,
            id,
            metaTypeName;

        for (i = 0; i < children.length; i += 1) {
            metaTypeName = self.core.getAttribute(self.getMetaType(children[i]), 'name');
            if (metaTypeName === 'Connector') {
                id = self.core.getAttribute(children[i], 'ID');
                if (componentInstance.connIdInModel2ID[id]) {
                    self.connID2Node[componentInstance.connIdInModel2ID[id]] = children[i];
                } else {
                    self.logger.error('ConnectorID' + id + ' not in ' + self.core.getAttribute(componentInstance.node,
                        'name'));
                }
            } else if (metaTypeName === 'Property') {
                id = self.core.getAttribute(children[i], 'ID');
                if (componentInstance.propertyIdInModel2ID[id]) {
                    self.valueFlowTargetID2Node[componentInstance.propertyIdInModel2ID[id]] = children[i];
                } else {
                    self.logger.error('PropertyID' + id + ' not in ' + self.core.getAttribute(componentInstance.node,
                        'name'));
                }
            } else if (metaTypeName === 'DomainPort') {
                id = self.core.getAttribute(children[i], 'ID');
                if (componentInstance.portIdInModel2ID[id]) {
                    self.portID2Node[componentInstance.portIdInModel2ID[id]] = children[i];
                } else {
                    self.logger.error('PortID' + id + ' not in ' + self.core.getAttribute(componentInstance.node,
                        'name'));
                }
            }
        }
    };

    AdmImporter.prototype.makeConnectorCompositions = function () {
        var self = this,
            srcID,
            dstID,
            parentNode,
            srcNode,
            dstNode,
            i,
            connectionNode,
            jointID,
            filteredConnections = {};

        for (i = 0; i < self.connectorCompositions.length; i += 1) {
            srcID = self.connectorCompositions[i].src;
            dstID = self.connectorCompositions[i].dst;
            jointID = srcID + '__' + dstID;
            if (filteredConnections[jointID]) {
                // self.logger.info('Connection between ' + jointID + ' already added.');
            } else {
                self.logger.info('Adding [src] ' + srcID + ' and [dst]' + dstID);
                jointID = dstID + '__' + srcID;
                filteredConnections[jointID] = true;
                srcNode = self.connID2Node[srcID];
                dstNode = self.connID2Node[dstID];
                parentNode = self.getConnectionParent(srcNode, dstNode, srcID, dstID);
                if (parentNode) {
                    connectionNode = self.core.createNode({
                        parent: parentNode,
                        base: self.meta.ConnectorComposition
                    });
                    self.core.setPointer(connectionNode, 'src', srcNode);
                    self.core.setPointer(connectionNode, 'dst', dstNode);
                } else {
                    self.logger.error('Could not make connector-composition between src: ' + srcID +
                    ' and dst: ' + dstID + '.');
                }
            }
        }
    };

    AdmImporter.prototype.makePortMaps = function () {
        var self = this,
            srcID,
            dstID,
            parentNode,
            srcNode,
            dstNode,
            i,
            portMapNode,
            jointID,
            filteredPortMaps = {};

        for (i = 0; i < self.portMaps.length; i += 1) {
            srcID = self.portMaps[i].src;
            dstID = self.portMaps[i].dst;
            jointID = srcID + '__' + dstID;
            if (filteredPortMaps[jointID]) {
                // self.logger.info('Connection between ' + jointID + ' already added.');
            } else {
                self.logger.info('Adding [src] ' + srcID + ' and [dst]' + dstID);
                jointID = dstID + '__' + srcID;
                filteredPortMaps[jointID] = true;
                srcNode = self.portID2Node[srcID];
                dstNode = self.portID2Node[dstID];
                parentNode = self.getConnectionParent(srcNode, dstNode, srcID, dstID);
                if (parentNode) {
                    portMapNode = self.core.createNode({
                        parent: parentNode,
                        base: self.meta.PortMap
                    });
                    self.core.setPointer(portMapNode, 'src', srcNode);
                    self.core.setPointer(portMapNode, 'dst', dstNode);
                } else {
                    self.logger.error('Could not make port-map between src: ' + srcID +
                    ' and dst: ' + dstID + '.');
                }
            }
        }
    };

    AdmImporter.prototype.makeValueFlows = function () {
        var self = this,
            i,
            srcNode,
            dstNode,
            symbol,
            parentNode,
            valueFlowNode;
        for (i = 0; i < self.valueFlows.length; i += 1) {
            srcNode = self.valueFlowTargetID2Node[self.valueFlows[i].src];
            dstNode = self.valueFlowTargetID2Node[self.valueFlows[i].dst];
            symbol = self.valueFlows[i].symbol;
            parentNode = self.getConnectionParent(srcNode, dstNode, self.valueFlows[i].src, self.valueFlows[i]
                .dst);
            if (parentNode) {
                valueFlowNode = self.core.createNode({
                    parent: parentNode,
                    base: self.meta.ValueFlowComposition
                });
                self.core.setPointer(valueFlowNode, 'src', srcNode);
                self.core.setPointer(valueFlowNode, 'dst', dstNode);
                if (symbol) {
                    self.logger.info('About to add value-flow into customFormula');
                    if (symbol !== self.core.getAttribute(srcNode, 'name')) {
                        self.core.setAttribute(valueFlowNode, 'VariableName', symbol);
                    }
                }
            } else {
                self.logger.error('Could not make value-flow connection between src: ' + self.valueFlows[i].src +
                ' and dst: ' + self.valueFlows[i].dst + '.');
            }
        }
    };

    AdmImporter.prototype.getConnectionParent = function (srcNode, dstNode, srcId, dstId) {
        var self = this,
            parent,
            errMsg,
            srcParent,
            dstParent,
            srcDepth,
            dstDepth;
        if (!srcNode || !dstNode) {
            errMsg = 'Making connection not possible srcID: "' + srcId + '", dstID: "' + dstId + '".';
            if (srcNode) {
                errMsg += ' SrcNode exists, name: "' + self.core.getAttribute(srcNode, 'name') + '", parent : "' +
                self.core.getAttribute(self.core.getParent(srcNode), 'name') + '".';
            } else {
                errMsg += ' The srcNode does not exist!';
            }
            if (dstNode) {
                errMsg += ' DstNode exists, name: "' + self.core.getAttribute(dstNode, 'name') + '", parent : "' +
                self.core.getAttribute(self.core.getParent(dstNode), 'name') + '".';
            } else {
                errMsg += ' The dstNode does not exist!';
            }
            self.currentSuccess = false;
            self.createMessage(dstNode || srcNode || null, errMsg, 'error');
            return null;
        }
        srcParent = self.core.getParent(srcNode);
        dstParent = self.core.getParent(dstNode);
        if (srcParent === dstParent && self.isMetaTypeOf(srcParent, self.META.Connector)) {
            parent = self.core.getParent(srcParent);
        } else if (srcParent === dstParent) {
            parent = srcParent;
        } else {
            srcDepth = self.core.getPath(srcParent)
                .split('/')
                .length;
            dstDepth = self.core.getPath(dstParent)
                .split('/')
                .length;
            if (srcDepth < dstDepth) {
                parent = srcParent;
            } else if (dstDepth > srcDepth) {
                parent = dstParent;
            } else {
                parent = self.core.getParent(srcParent);
            }
        }
        return parent;
    };

    //</editor-fold>

    AdmImporter.prototype.endsWith = function (str, ending) {
        var lastIndex = str.lastIndexOf(ending);
        return ( lastIndex !== -1 ) && ( lastIndex + ending.length === str.length );
    };

    AdmImporter.prototype.startsWith = function (str, start) {
        if (start === '') {
            return true;
        }
        return start.length > 0 && str.substring(0, start.length) === start;
    };

    return AdmImporter;
});
