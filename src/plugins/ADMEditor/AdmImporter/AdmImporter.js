/* global define */
/**
 * Generated by PluginGenerator from webgme on Mon Apr 14 2014 10:15:45 GMT-0500 (Central Daylight Time).
 */
define([
    'plugin/AcmImporter/AcmImporter/AcmImporter',
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'plugin/AdmImporter/AdmImporter/meta',
    'jszip',
    'xmljsonconverter',
    'q',
    'plugin/PluginContext',
    'blob/BlobClient',
    'superagent'
], function (AcmImporter, PluginConfig, PluginBase, MetaTypes, JSZip, Converter, Q, PluginContext, BlobClient, superagent) {
    'use strict';
    //<editor-fold desc="============================ Class Definition ================================">
    /**
     * Initializes a new instance of AdmImporter.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin AdmImporter.
     * @constructor
     */
    var AdmImporter = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.meta = MetaTypes;
        this.acmCounter = 0;
        this.designID2Node = {};
        this.componentID2Acm = {};
        this.componentID2PrintInfo = {};
        // printInfoDataType = {
        //    name: {string},
        //    count: {int},
        //    parentName: {string}
        // };
        this.componentInstances = [];
        //        componentInstancesDataType = {
        //            node: {nodeObj},
        //            id: {str},
        //            connIdInModel2ID: {object},
        //            propertyIdInModel2ID: {object},
        //            portIdInModel2ID: {object},
        //        };
        this.connID2Node = {};
        this.portID2Node = {};
        this.valueFlowTargetID2Node = {};
        this.valueFlows = [];
        //        valueFlowsDataType = {
        //            src: {string},
        //            dst: {string}
        //        };
        this.valueFlowMuxes = {};
        this.connectorCompositions = [];
        //        connectorCompositionsDataType = {
        //            src: {string},
        //            dst: {string}
        //        };
        this.portMaps = [];
        //        portMapsDataType = {
        //            src: {string},
        //            dst: {string}
        //        };
        this.admData = null;
        this.copies = false;
        this.currentSuccess = true;
    };

    // Prototypal inheritance from PluginBase.
    AdmImporter.prototype = Object.create(PluginBase.prototype);
    AdmImporter.prototype.constructor = AdmImporter;

    /**
     * Gets the name of the AdmImporter.
     * @returns {string} The name of the plugin.
     * @public
     */
    AdmImporter.prototype.getName = function () {
        return "ADM Importer";
    };

    /**
     * Gets the description of the AdmImporter.
     * @returns {string} The description of the plugin.
     * @public
     */
    AdmImporter.prototype.getDescription = function () {
        return "Imports an adm-file generated from desktop GME.";
    };

    /**
     * Gets the semantic version (semver.org) of the AdmImporter.
     * @returns {string} The version of the plugin.
     * @public
     */
    AdmImporter.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
     * Gets the configuration structure for the AdmImporter.
     * The ConfigurationStructure defines the configuration for the plugin
     * and will be used to populate the GUI when invoking the plugin from webGME.
     * @returns {object} The version of the plugin.
     * @public
     */
    AdmImporter.prototype.getConfigStructure = function () {
        return [{
                'name': 'admFile',
                'displayName': 'ADM file',
                'description': 'AVM Design Model.',
                'value': '',
                'valueType': 'asset',
                'readOnly': false
            },
            {
                'name': 'admUrl',
                'displayName': 'URL to ADM file',
                'description': 'URL to ADM file.',
                'value': '',
                'valueType': 'string',
                'readOnly': false
            },
            {
                'name': 'useExistingComponents',
                'displayName': 'Use components in this model',
                'description': 'Use components in this model',
                'value': true,
                'valueType': 'boolean',
                'readOnly': false
            },
            {
                'name': 'componentServerUrl',
                'displayName': 'Component Server URL',
                'description': 'Component Server URL',
                // 'value': 'http://components.metamorphsoftware.com',
                'value': '',
                'valueType': 'string',
                'readOnly': false
            }
        ];
    };
    //</editor-fold>
    AdmImporter.prototype.innerMain = function (xmlArrayBuffer, callback, finnishPlugin) {
        var self = this,
            xml2json = new Converter.Xml2json({
                skipWSText: true,
                arrayElements: self.arrayElementsInXml
            }),
            admFolder = self.activeNode,
            workspaceNode;

        self.updateMETA(self.meta);
        self.copies = true;
        if (typeof xmlArrayBuffer === 'string') {
            self.admData = xml2json.convertFromString(xmlArrayBuffer);
        } else {
            self.admData = xml2json.convertFromBuffer(xmlArrayBuffer);
        }
        if (self.admData instanceof Error) {
            self.createMessage(null, 'Given adm not valid xml: ' + self.admData.message, 'error');
            callback(null, self.result);
            return;
        }

        self.admData = self.admData['Design'];
        workspaceNode = self.getWorkspaceNode(admFolder);
        //timeStamp = new Date().getTime();
        self.exploreACMs(workspaceNode, false, function (err) {
            if (err) {
                callback(err, self.result);
                return;
            }
            //self.createMessage(null, 'ExecTime [s] exploreACMs     :: ' +
            //        ((new Date().getTime() - timeStamp) / 1000).toString());
            if (!self.getCurrentConfig().componentServerUrl && self.acmCounter > 0) {
                self.createMessage(workspaceNode, 'Work-space did not have all ACMs used by the design.', 'error');
                self.logMissingACMsToResult();
                callback(null, self.result);
                return;
            }
            //timeStamp = new Date().getTime();
            self.createAdmDesign(admFolder)
            //self.createMessage(null, 'ExecTime [s] createAdmDesign :: ' +
            //    ((new Date().getTime() - timeStamp) / 1000).toString());
                .then(function (container) {
                    self.container = container;
                //timeStamp = new Date().getTime();
                self.gatherComponentInstanceContent(function (err) {
                    //self.createMessage(null, 'ExecTime [s] gatherComponentInstanceContent :: ' +
                    //    ((new Date().getTime() - timeStamp) / 1000).toString());
                    if (err) {
                        finnishPlugin(err);
                    } else {
                        //timeStamp = new Date().getTime();
                        self.makeConnectorCompositions();
                        //self.createMessage(null, 'ExecTime [s] makeConnectorCompositions :: ' +
                        //    ((new Date().getTime() - timeStamp) / 1000).toString());
                        //timeStamp = new Date().getTime();
                        self.makeValueFlows();
                        //self.createMessage(null, 'ExecTime [s] makeValueFlows :: ' +
                        //    ((new Date().getTime() - timeStamp) / 1000).toString());
                        self.makePortMaps();
                        finnishPlugin(null);
                    }
                });
            }).catch(function (error) {
                    finnishPlugin(error);
                });
        });
    };

    AdmImporter.prototype.arrayElementsInXml = {
        Design: false,
        RootContainer: false,
        Value: false,
        Container: true,
        Connector: true,
        Property: true,
        Formula: true,
        Operand: true,
        ValueFlowMux: true,
        ComponentInstance: true,
        PrimitivePropertyInstance: true,
        ConnectorInstance: true,
        PortInstance: true,
        Role: true,
        Port: true,
        ContainerFeature: true
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always have to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    AdmImporter.prototype.main = function (callback) {
        var self = this,
            config = self.getCurrentConfig(),
        //timeStamp,
            timeStart = new Date()
                .getTime(),
            debug = false,
            finnishPlugin = function (err) {
                if (err) {
                    self.createMessage(null, err, 'error');
                    callback(null, self.result);
                    return;
                }

                if (debug) {
                    self.saveDebugArtifacts(callback);
                } else {
                    //timeStamp = new Date().getTime();
                    self.save('added obj', function (err) {
                        if (err) {
                            callback(null, self.result);
                            return;
                        }
                        //self.createMessage(null, 'ExecTime [s] save :: ' +
                        //    ((new Date().getTime() - timeStamp) / 1000).toString());

                        if (self.currentSuccess === false) {
                            self.createMessage(null,
                                'There were issues in the matched ACMs. Incomplete model still ' +
                                'imported - make sure to address the reported issues.', 'warning');
                        }
                        //                        self.createMessage(null, 'ExecTime [s] total :: ' +
                        //                            ((new Date().getTime() - timeStart) / 1000).toString());
                        self.result.setSuccess(self.currentSuccess);
                        callback(null, self.result);
                    });
                }
            };

        if (!self.activeNode) {
            self.createMessage(null,
                'Active node is not present! This happens sometimes... Loading another model ' +
                'and trying again will solve it most of times.', 'error');
            callback('Active node is not present!', self.result);
            return;
        }

        if (self.isMetaTypeOf(self.activeNode, self.META.ADMFolder) === false && self.isMetaTypeOf(self.activeNode, self.META.Container) === false) {
            self.result.setSuccess(false);
            self.createMessage(null, 'This plugin must be called from an ADMFolder or Container', 'error');
            //+ self.core.getAttribute('name', self.getMetaType(self.activeNode)), 'error');
            callback(null, self.result);
            return;
        }
        if (!config.admFile && !config.admUrl) {
            self.createMessage(null, 'No adm file provided', 'error');
            callback(null, self.result);
            return;
        }
        if (!config.useExistingComponents && !config.componentServerUrl) {
            self.createMessage(null, 'Configuration error: ' +
                'either useExistingComponents must be true or the componentServerUrl must be specified', 'error');
            callback(null, self.result);
            return;
        }
        var processAdmFile = function (err, xmlArrayBuffer) {
                if (err) {
                    self.createMessage(null, '' + err, 'error');
                    self.result.setSuccess(false);
                    return callback(null, self.result);
                }
                var magic = Array.prototype.slice.call(new Uint8Array(xmlArrayBuffer), 0, 4);
                if (magic[0] === 'P'.charCodeAt(0) && magic[1] === 'K'.charCodeAt(0)) {
                    // PK\003\004 , PK\005\006 or PK\007\008
                    var zipFile,
                        admXml;
                    try {
                        zipFile = new JSZip(xmlArrayBuffer);
                    } catch (error) {
                        self.createMessage(null, 'zip file is not valid: ' + error, 'error');
                        return callback(null, self.result);
                    }

                    admXml = zipFile.file(/\.adm$/).filter(function (entry) {
                        return entry.name.indexOf('__MACOSX') !== 0;
                    });
                    if (admXml.length === 1) {
                        return self.innerMain(admXml[0].asText(), callback, finnishPlugin);
                    } else {
                        self.createMessage(null, 'zip must contain exactly one .adm file, not ' + admXml.length, 'error');
                        return callback(null, self.result);
                    }
                } else {
                    self.innerMain(xmlArrayBuffer, callback, finnishPlugin);
                }
            };
        if (config.admFile) {
            self.blobClient.getObject(config.admFile, processAdmFile);
        } else {
            AcmImporter.prototype.getZipFromUrl.call(this, config.admUrl, function (err, res/*, filename*/) {
                if (err) {
                    self.createMessage(null, 'Could not GET \'' + config.admUrl + '\': ' + err, 'error');
                    self.result.setSuccess(false);
                    return callback(null, self.result);
                }
                processAdmFile(null, res);
            });
        }
    };

    AdmImporter.prototype.saveDebugArtifacts = function (callback) {
        var self = this,
            artie,
            json2xml,
            debugFiles;

        json2xml = new Converter.Json2xml();
        debugFiles = {
            'design.json': JSON.stringify({
                Design: self.admData
            }, null, 4),
            'design.adm': json2xml.convertToString({
                Design: self.admData
            })
        };
        artie = self.blobClient.createArtifact('debugFiles');
        artie.addFiles(debugFiles, function (err, hashes) {
            if (err) {
                self.result.setSuccess(false);
                callback('Could not add debug files : err' + err.toString(), self.result);
                return;
            }
            artie.save(function (err, hash) {
                if (err) {
                    self.result.setSuccess(false);
                    callback('Could not save artifact : err' + err.toString(), self.result);
                    return;
                }
                self.result.setSuccess(true);
                self.result.addArtifact(hash);
                callback(null, self.result);
            });
        });
    };

    //<editor-fold desc="============================ Gathering of ACM Info ===========================">
    AdmImporter.prototype.getWorkspaceNode = function (node) {
        var self = this;
        while (node) {
            if (self.isMetaTypeOf(node, self.meta.WorkSpace)) {
                self.logger.info('Found WorkSpace-Node : ' + self.core.getAttribute(node, 'name'));
                return node;
            }
            node = self.core.getParent(node);
        }
        self.logger.error('Could not find WorkSpace!!');
    };

    AdmImporter.prototype.exploreACMs = function (node, dummyACMs, callback) {
        var self = this;
        if (dummyACMs) {
            callback(null);
            return;
        }
        self.initializeComponentMap(self.admData.RootContainer);
        self.logger.info('Number of unique ACMs (acmCounter) is ' + self.acmCounter.toString());
        self.core.loadChildren(node, function (err, children) {
            var counter,
                i,
                counterCallback,
                error = '';
            // Check for error in loading before doing recursion.
            if (err) {
                callback('Could not load children for project, err: ' + err, self.result);
                return;
            }
            if (children.length === 0) {
                callback(null);
                return;
            }
            // Define a counter and callback for the recursion.
            counter = {
                visits: children.length
            };
            counterCallback = function (err) {
                error = err ? error += err : error;
                counter.visits -= 1;
                if (counter.visits === 0) {
                    callback(error);
                }
            };
            // Iterate over children and invoke recursion on ACMFolders.
            for (i = 0; i < children.length; i += 1) {
                if (self.isMetaTypeOf(children[i], self.meta.ACMFolder)) {
                    self.visitComponentsRec(children[i], counter, counterCallback);
                } else {
                    counterCallback(null);
                }
            }
        });
    };

    AdmImporter.prototype.initializeComponentMap = function (container) {
        var self = this,
            i,
            subContainers,
            components,
            id;

        if (container.ComponentInstance) {
            components = container.ComponentInstance;
            for (i = 0; i < components.length; i += 1) {
                id = components[i]['@ComponentID'];
                if (self.componentID2Acm[id] === undefined) {
                    self.componentID2Acm[id] = false;
                    self.acmCounter += 1;
                    self.componentID2PrintInfo[id] = {
                        name: components[i]['@Name'],
                        count: 1,
                        parentName: container['@Name']
                    };
                } else {
                    self.componentID2PrintInfo[id].count += 1;
                }
            }
        }

        if (container.Container) {
            subContainers = container.Container;
            for (i = 0; i < subContainers.length; i += 1) {
                self.initializeComponentMap(subContainers[i]);
            }
        }
    };

    AdmImporter.prototype.visitComponentsRec = function (node, counter, callback) {
        var self = this,
            name = self.core.getAttribute(node, 'name'),
            childName;
        self.logger.info('visitComponentsRec at node "' + name + '" acmCounter is:   ' + self.acmCounter.toString());
        if (self.acmCounter <= 0) {
            callback(null);
            return;
        }
        self.core.loadChildren(node, function (err, children) {
            var i,
                componentID;
            if (err) {
                callback(' loadChildren failed for component ' + name + ' with error : ' + err);
                return;
            }
            counter.visits += children.length;

            if (children.length === 0) {
                // The only chance for callback to be called.
                callback(null);
            } else {
                // The node needs to be accounted for.
                counter.visits -= 1;
            }
            for (i = 0; i < children.length; i += 1) {
                if (self.isMetaTypeOf(children[i], self.meta.ACMFolder)) {
                    self.visitComponentsRec(children[i], counter, callback);
                } else if (self.isMetaTypeOf(children[i], self.meta.AVMComponentModel)) {
                    componentID = self.core.getAttribute(children[i], 'ID');
                    childName = self.core.getAttribute(children[i], 'name');
                    if (self.componentID2Acm[componentID] === false) {
                        self.componentID2Acm[componentID] = children[i];
                        self.logger.info('Found matching ACM "' + childName + '"');
                        self.acmCounter -= 1;
                    } else if (self.componentID2Acm[componentID] === undefined) {
                        self.logger.info('ACM "' + childName + '" is not part of the design.');
                    } else {
                        self.logger.warn('Found duplicate ACM ID "' + componentID + '". "' + childName +
                        '" at "' +
                        self.core.getPath(children[i]) + '" will not be used.');
                    }
                    callback(null);
                } else {
                    callback(null);
                }
            }
        });
    };

    AdmImporter.prototype.logMissingACMsToResult = function () {
        var self = this,
            missingIDs = [],
            key,
            i,
            info;
        for (key in self.componentID2Acm) {
            if (self.componentID2Acm.hasOwnProperty(key)) {
                if (self.componentID2Acm[key] === false) {
                    missingIDs.push(key);
                }
            }
        }
        for (i = 0; i < missingIDs.length; i += 1) {
            info = self.componentID2PrintInfo[missingIDs[i]];
            self.createMessage(null, 'ACM "' + info.name + '", in ADM "' + info.parentName + '" did not have a ' +
            'matching ACM with ID "' + missingIDs[i] + '". (The component ocurres ' + info.count.toString() +
            ' times in the ADM.)', 'error');
        }
    };
    //</editor-fold>

    //<editor-fold desc="=========================== Creation of ADM objects ==========================">
    AdmImporter.prototype.createAdmDesign = function (admFolder) {
        var self = this;
        return Q.all(self.createContainersPass1(self.admData.RootContainer, admFolder, 0))
            .then(function () {
                self.createContainersPass2(self.admData.RootContainer, admFolder, 0);
            }).then(function () {
                var config = self.getCurrentConfig(),
                    root = self.designID2Node[self.admData.RootContainer['@ID']];
                if (config.position) {
                    self.core.setRegistry(root, 'position', {
                        x: config.position.x,
                        y: config.position.y
                    });
                }
                self.createMessage(root, 'Added ADM', 'debug');
                return root;
            });
    };

    AdmImporter.prototype.createContainersPass1 =  function (containerData, parentNode, depth) {
        var self = this,
            container,
            components = [],
            indent = new Array(depth + 2).join('-');

        // Create the container and set attributes and registry.
        container = self.core.createNode({
            parent: parentNode,
            base: self.meta.Container
        });
        containerData['@ID'] = containerData['@ID'] || self.core.getPath(container);
        this.designID2Node[containerData['@ID']] = container;
        self.core.setAttribute(container, 'name', containerData['@Name']);
        self.core.setAttribute(container, 'Type', containerData['@xsi:type'].slice("avm:".length));
        if (depth === 0) {
            self.core.setRegistry(container, 'position', {
                x: 100,
                y: 100
            });
        } else {
            self.core.setRegistry(container, 'position', {
                x: parseInt(containerData['@XPosition'], 10),
                y: parseInt(containerData['@YPosition'], 10)
            });
        }

        self.logger.info(indent + 'Created Container : ' + containerData['@Name']);
        depth += 1;

        // Go through the containment and add the child-objects.
        if (containerData.Container) {
            components = components.concat.apply(components, containerData.Container.map(function (subContainerData) {
                return self.createContainersPass1(subContainerData, container, depth);
            }));
        }

        if (containerData.ComponentInstance) {
            components = components.concat(containerData.ComponentInstance.map(function (componentData) {
                    return self.createComponent(componentData, container)
                        .then(function () {
                            self.logger.info(indent + 'Created Component : ' + componentData['@Name']);
                        });
                }
            ));
        }

        return components;
    };

    AdmImporter.prototype.createContainersPass2 = function (containerData, parentNode, depth) {
        var self = this,
            container,
            connectorsData,
            portData,
            propertiesData,
            formulasData,
            muxData,
            i,
            indent = new Array(depth + 2).join('-');

        container = this.designID2Node[containerData['@ID']];
        depth += 1;

        if (containerData.Container) {
            containerData.Container.map(function (subContainerData) {
                return self.createContainersPass2(subContainerData, container, depth);
            });
        }

        if (containerData.ValueFlowMux) {
            muxData = containerData.ValueFlowMux;
            for (i = 0; i < muxData.length; i += 1) {
                self.valueFlowMuxes[muxData[i]['@ID']] = muxData[i]['@Source'].split(' ');
            }
        }

        if (containerData.ContainerFeature) {
            var features = containerData.ContainerFeature;
            for (i = 0; i < features.length; i += 1) {
                self.createContainerFeature(features[i], container);
                self.logger.info(indent + 'Created ContainerFeature : ' + features[i]['@xsi:type']);
            }
        }

        if (containerData.Connector) {
            connectorsData = containerData.Connector;
            for (i = 0; i < connectorsData.length; i += 1) {
                self.createConnector(connectorsData[i], container);
                self.logger.info(indent + 'Created Connector : ' + connectorsData[i]['@Name']);
            }
        }

        if (containerData.Port) {
            portData = containerData.Port;
            for (i = 0; i < portData.length; i += 1) {
                self.createDomainPort(portData[i], container);
                self.logger.info(indent + 'Created DomainPort : ' + portData[i]['@Name']);
            }
        }

        if (containerData.Property) {
            propertiesData = containerData.Property;
            for (i = 0; i < propertiesData.length; i += 1) {
                self.createProperty(propertiesData[i], container);
            }
        }

        if (containerData.Formula) {
            formulasData = containerData.Formula;
            for (i = 0; i < formulasData.length; i += 1) {
                self.createFormula(formulasData[i], container);
            }
        }

        return container;
    };

    AdmImporter.prototype.createComponent = function (componentData, parentNode) {
        var self = this,
            i,
            avmID = componentData['@ComponentID'],
            component,
            connectorInstanceData = componentData.ConnectorInstance,
            primitivePropertyData = componentData.PrimitivePropertyInstance,
            portInstanceData = componentData.PortInstance,
            pluginConfig = self.getCurrentConfig();

        if (pluginConfig.useExistingComponents && self.componentID2Acm[avmID]) {
            self.logger.info('Found ACM for : ' + componentData['@Name']);
            if (self.copies) {
                component = Q(self.core.copyNode(self.componentID2Acm[avmID], parentNode));
            } else {
                component = Q(self.core.createNode({
                    parent: parentNode,
                    base: self.componentID2Acm[avmID]
                }));
            }
        } else if (pluginConfig.componentServerUrl) {
            var config = {
                AcmUrl: pluginConfig.componentServerUrl + '/getcomponent/download/' + encodeURIComponent(avmID),
                DeleteExisting: false
            };

            component = self.runPlugin(AcmImporter, config, {activeNode: parentNode})
                .then(function (result) {
                    return result.id2ComponentMap[Object.keys(result.id2ComponentMap)[0]];
                });
        } else {
            component = Q.reject('Could not find component with ID ' + componentData['@Name']);
        }

        var createComponentInstance = function (component) {
            var connIdInModel2ID = {},
                propertyIdInModel2ID = {},
                portIdInModel2ID = {};

            if (connectorInstanceData) {
                for (i = 0; i < connectorInstanceData.length; i += 1) {
                    var connectorIdInModel = connectorInstanceData[i]['@IDinComponentModel'];
                    var connectorId = connectorInstanceData[i]['@ID'];
                    self.addConnectionData(parentNode, connectorInstanceData[i]);
                    connIdInModel2ID[connectorIdInModel] = connectorId;
                }
            }
            if (portInstanceData) {
                for (i = 0; i < portInstanceData.length; i += 1) {
                    var portIdInModel = portInstanceData[i]['@IDinComponentModel'];
                    var portId = portInstanceData[i]['@ID'];
                    self.addPortMapData(parentNode, portInstanceData[i]);
                    portIdInModel2ID[portIdInModel] = portId;
                }
            }
            if (primitivePropertyData) {
                for (i = 0; i < primitivePropertyData.length; i += 1) {
                    var propertyIdInModel = primitivePropertyData[i]['@IDinComponentModel'];
                    var propertyId = primitivePropertyData[i].Value['@ID'];
                    if (primitivePropertyData[i].Value.ValueExpression) {
                        self.valueFlows.push({
                            src: primitivePropertyData[i].Value.ValueExpression['@ValueSource'],
                            dst: propertyId
                        });
                    }
                    // TODO: this is not a good way to do this...
                    propertyIdInModel2ID[propertyIdInModel] = propertyId;
                }
            }
            self.componentInstances.push({
                node: component,
                id: componentData["@ID"],
                connIdInModel2ID: connIdInModel2ID,
                propertyIdInModel2ID: propertyIdInModel2ID,
                portIdInModel2ID: portIdInModel2ID
            });
            self.core.setAttribute(component, 'name', componentData['@Name']);
            self.core.setRegistry(component, 'position', {
                x: parseInt(componentData['@XPosition'], 10),
                y: parseInt(componentData['@YPosition'], 10)
            });
        };

        return component.then(createComponentInstance);
    };

    AdmImporter.prototype.createContainerFeature = function (featureData, container) {

        function setOriginForRelativeConstraint() {
            var origin = self.componentInstances.filter(function (ci) {
                return ci.id === featureData['@Origin'];
            });
            if (origin.length) {
                self.core.setPointer(feature, 'Origin', origin[0].node);
            } else {
                self.createMessage(container, 'Could not find Origin ' + featureData['@Origin'], 'error');
            }
        }

        function setRangeValues(attrSuffix) {
            if (featureData['@X' + attrSuffix + 'Min'] && featureData['@X' + attrSuffix + 'Max']) {
                self.core.setAttribute(feature, 'X' + attrSuffix, featureData['@X' + attrSuffix + 'Min'] + ":" +
                featureData['@X' + attrSuffix + 'Max']);
            }
            if (featureData['@Y' + attrSuffix + 'Min'] && featureData['@Y' + attrSuffix + 'Max']) {
                self.core.setAttribute(feature, 'Y' + attrSuffix, featureData['@Y' + attrSuffix + 'Min'] + ":" +
                featureData['@Y' + attrSuffix + 'Max']);
            }
        }

        var self = this;
        var feature;

        var constraintTypes = [
            'eda:RelativeLayoutConstraint',
            'eda:ExactLayoutConstraint',
            'eda:RangeLayoutConstraint',
            'eda:RelativeRangeLayoutConstraint',
            'eda:GlobalLayoutConstraintException'
        ];

        if (constraintTypes.indexOf(featureData['@xsi:type']) !== -1) {

            var type = featureData['@xsi:type'].substr(4);
            var ids = ( featureData['@ConstraintTarget'] || '' )
                .split(' ');
            var constraintTargets = self.componentInstances.filter(function (comp) {
                return ids.indexOf(comp.id) !== -1;
            });
            feature = self.core.createNode({
                parent: container,
                base: self.meta[type]
            });

            var copyAttrIfSet = function (attrName, xform) {
                if (!xform) {
                    xform = function (attr) {
                        return attr;
                    };
                }
                if (featureData['@' + attrName]) {
                    self.core.setAttribute(feature, attrName, xform(featureData['@' + attrName]));
                }
            };

            if (type === 'RelativeLayoutConstraint') {
                copyAttrIfSet('XOffset');
                copyAttrIfSet('YOffset');
                copyAttrIfSet('RelativeLayer');
                copyAttrIfSet('RelativeRotation');
                setOriginForRelativeConstraint();
            }
            else if (type === 'RelativeRangeLayoutConstraint') {
                self.core.setAttribute(feature, 'RelativeLayer', 'No Restriction');
                copyAttrIfSet('RelativeLayer');
                setRangeValues('RelativeRange');
                setOriginForRelativeConstraint();
            }
            else if (type === 'ExactLayoutConstraint') {
                copyAttrIfSet('X');
                copyAttrIfSet('Y');
                copyAttrIfSet('Layer');
                copyAttrIfSet('Rotation', function (val) {
                    return val.substr(1);
                });
            }
            else if (type === 'RangeLayoutConstraint') {
                self.core.setAttribute(feature, 'LayerRange', 'Either');
                copyAttrIfSet('LayerRange');
                copyAttrIfSet('Type');
                setRangeValues('Range');
            }
            else if (type === 'GlobalLayoutConstraintException') {
                var constraintVal = featureData['@Constraint'];
                var val;

                if (constraintVal === 'BoardEdgeSpacing') {
                    val = 'Board Edge Spacing';
                }
                else if (constraintVal === 'InterChipSpacing') {
                    val = 'Inter-Chip Spacing';
                }

                if (val !== undefined) {
                    self.core.setAttribute(feature, 'Constraint', val);
                }
            }

            copyAttrIfSet('Notes');
            self.core.setAttribute(feature, 'name', type);
            constraintTargets.forEach(function (componentInstance) {
                self.core.addMember(feature, 'ConstraintTarget', componentInstance.node);
            });

        } else {
            self.createMessage(container, 'Unknown ContainerFeature type ' + featureData['@xsi:type'], 'error');
            return;
        }

        self.core.setRegistry(feature, 'position', {
            x: parseInt(featureData['@XPosition'], 10),
            y: parseInt(featureData['@YPosition'], 10)
        });
    };

    AdmImporter.prototype.createConnector = function (connectorData, parentNode) {
        var self = this,
            i,
            connector;

        connector = self.core.createNode({
            parent: parentNode,
            base: self.meta.Connector
        });
        self.connID2Node[connectorData['@ID']] = connector;
        self.core.setAttribute(connector, 'name', connectorData['@Name']);
        // Add Domain-Connectors (Role in adm).
        if (connectorData.Role) {
            for (i = 0; i < connectorData.Role.length; i += 1) {
                self.createDomainPort(connectorData.Role[i], connector);
            }
        }

        self.core.setRegistry(connector, 'position', {
            x: parseInt(connectorData['@XPosition'], 10),
            y: parseInt(connectorData['@YPosition'], 10)
        });

        self.addConnectionData(parentNode, connectorData);
    };

    AdmImporter.prototype.createDomainPort = function (portData, parentNode) {
        var self = this,
            port,
            typeName;
        port = self.core.createNode({
            parent: parentNode,
            base: self.meta.DomainPort
        });

        self.core.setAttribute(port, 'name', portData['@Name']);

        typeName = portData['@xsi:type'];

        if (self.endsWith(typeName, 'Connector')) {
            if (portData.hasOwnProperty('@Class')) {
                self.core.setAttribute(port, 'Type', 'ModelicaConnector');
                self.core.setAttribute(port, 'Class', portData['@Class']);
            } else {
                self.createMessage(port, 'Domain port was of xsi:type Connector but did not ' +
                'have a Class defined. Unknown Type: ' + JSON.stringify(portData, null, 2), 'error');
            }
        } else if (self.endsWith(typeName, 'Axis')) {
            self.core.setAttribute(port, 'Type', 'CadAxis');
        } else if (self.endsWith(typeName, 'CoordinateSystem')) {
            self.core.setAttribute(port, 'Type', 'CadCoordinateSystem');
        } else if (self.endsWith(typeName, 'Plane')) {
            self.core.setAttribute(port, 'Type', 'CadPlane');
        } else if (self.endsWith(typeName, 'Point')) {
            self.core.setAttribute(port, 'Type', 'CadPoint');
        } else if (self.endsWith(typeName, 'Pin')) {
            self.core.setAttribute(port, 'Type', 'SchematicPin');
        } else if (self.endsWith(typeName, 'SystemCPort')) {
            self.core.setAttribute(port, 'Type', 'SystemCPort');
        } else if (self.endsWith(typeName, 'RFPort')) {
            self.core.setAttribute(port, 'Type', 'RFPort');
        } else {
            self.createMessage(port, 'Unknown Type for domain port : ' + JSON.stringify(portData, null, 2),
                'error');
        }

        self.core.setRegistry(port, 'position', {
            x: parseInt(portData['@XPosition'], 10),
            y: parseInt(portData['@YPosition'], 10)
        });

        self.portID2Node[portData['@ID']] = port;
        self.addPortMapData(parentNode, portData);
    };

    AdmImporter.prototype.createProperty = function (propertyData, parentNode) {
        var self = this,
            i,
            muxSources,
            property,
            value = '',
            isParameter = false,
            valueExpression,
            assignedValue,
            valueID = propertyData.Value['@ID'];

        if (propertyData.Value.ValueExpression) {
            valueExpression = propertyData.Value.ValueExpression;
            if (self.endsWith(valueExpression['@xsi:type'], 'ParametricValue')) {
                isParameter = true;
                assignedValue = valueExpression.AssignedValue;
                if (self.endsWith(assignedValue['@xsi:type'], 'FixedValue')) {
                    if (assignedValue.Value && assignedValue.Value['#text']) {
                        value = valueExpression.AssignedValue.Value['#text'];
                    }
                } else if (self.endsWith(assignedValue['@xsi:type'], 'DerivedValue')) {
                    if (self.valueFlowMuxes[assignedValue['@ValueSource']]) {
                        muxSources = self.valueFlowMuxes[assignedValue['@ValueSource']];
                        for (i = 0; i < muxSources.length; i += 1) {
                            self.valueFlows.push({
                                src: muxSources[i],
                                dst: valueID
                            });
                        }
                    } else {
                        self.valueFlows.push({
                            src: assignedValue['@ValueSource'],
                            dst: valueID
                        });
                    }
                }
            } else if (self.endsWith(valueExpression['@xsi:type'], 'FixedValue')) {
                if (valueExpression.Value && valueExpression.Value['#text']) {
                    value = valueExpression.Value['#text'];
                }
            } else if (self.endsWith(valueExpression['@xsi:type'], 'DerivedValue')) {
                if (self.valueFlowMuxes[valueExpression['@ValueSource']]) {
                    muxSources = self.valueFlowMuxes[valueExpression['@ValueSource']];
                    for (i = 0; i < muxSources.length; i += 1) {
                        self.valueFlows.push({
                            src: muxSources[i],
                            dst: valueID
                        });
                    }
                } else {
                    self.valueFlows.push({
                        src: valueExpression['@ValueSource'],
                        dst: valueID
                    });
                }
            }
        }

        if (isParameter) {
            property = self.core.createNode({
                parent: parentNode,
                base: self.meta.Property
            });
            self.core.setAttribute(property, 'ValueType', 'Parametric');
            self.logger.info('Created Parameter "' + propertyData['@Name'] + '" with value : "' + value + '".');
            if (valueExpression.Default && valueExpression.Default.Value['#text']) {
                self.core.setAttribute(property, 'Default', valueExpression.Default.Value['#text']);
            }
            if (valueExpression.Maximum && valueExpression.Maximum.Value['#text']) {
                self.core.setAttribute(property, 'Maximum', valueExpression.Maximum.Value['#text']);
            }
            if (valueExpression.Minimum && valueExpression.Minimum.Value['#text']) {
                self.core.setAttribute(property, 'Minimum', valueExpression.Minimum.Value['#text']);
            }
        } else {
            property = self.core.createNode({
                parent: parentNode,
                base: self.meta.Property
            });
            self.logger.info('Created Property "' + propertyData['@Name'] + '" with value : "' + value + '".');
        }

        self.core.setAttribute(property, 'name', propertyData['@Name']);
        self.core.setAttribute(property, 'DataType', propertyData.Value['@DataType']);
        self.core.setAttribute(property, 'Value', value);
        if (propertyData.Value['@Unit']) {
            self.core.setAttribute(property, 'Unit', propertyData.Value['@Unit']);
        }
        self.core.setRegistry(property, 'position', {
            x: parseInt(propertyData['@XPosition'], 10),
            y: parseInt(propertyData['@YPosition'], 10)
        });

        self.valueFlowTargetID2Node[valueID] = property;
    };

    AdmImporter.prototype.createFormula = function (formulaData, parentNode) {
        var self = this,
            i,
            id = formulaData['@ID'],
            formula,
            isSimple = formulaData.hasOwnProperty('@Operation'),
            operands;

        if (isSimple) {
            formula = self.core.createNode({
                parent: parentNode,
                base: self.meta.SimpleFormula
            });
            self.core.setAttribute(formula, 'Method', formulaData['@Operation']);
            if (formulaData['@Operand']) {
                operands = formulaData['@Operand'].split(" ");
                for (i = 0; i < operands.length; i += 1) {
                    self.valueFlows.push({
                        src: operands[i],
                        dst: id
                    });
                }
            }
            self.logger.info('Created SimpleFormula "' + formulaData['@Name'] + '".');
        } else {
            formula = self.core.createNode({
                parent: parentNode,
                base: self.meta.CustomFormula
            });
            self.core.setAttribute(formula, 'Expression', formulaData['@Expression']);
            if (formulaData.Operand) {
                operands = formulaData.Operand;
                for (i = 0; i < operands.length; i += 1) {
                    self.valueFlows.push({
                        src: operands[i]['@ValueSource'],
                        dst: id,
                        symbol: operands[i]['@Symbol']
                    });
                }
            }
            self.logger.info('Created CustomFormula "' + formulaData['@Name'] + '".');
        }
        self.core.setAttribute(formula, 'name', formulaData['@Name']);

        self.core.setRegistry(formula, 'position', {
            x: parseInt(formulaData['@XPosition'], 10),
            y: parseInt(formulaData['@YPosition'], 10)
        });

        self.valueFlowTargetID2Node[id] = formula;
    };

    AdmImporter.prototype.addConnectionData = function (parentNode, connectorData) {
        var self = this,
            connectedConnectorIDs,
            i;
        if (connectorData['@ConnectorComposition']) {
            connectedConnectorIDs = connectorData['@ConnectorComposition'].split(" ");
            for (i = 0; i < connectedConnectorIDs.length; i += 1) {
                self.connectorCompositions.push({
                    src: connectorData['@ID'],
                    dst: connectedConnectorIDs[i]
                });
            }
        }
    };

    AdmImporter.prototype.addPortMapData = function (parentNode, portData) {
        var self = this,
            connectedPortIDs,
            i;
        if (portData['@PortMap']) {
            connectedPortIDs = portData['@PortMap'].split(" ");
            for (i = 0; i < connectedPortIDs.length; i += 1) {
                self.portMaps.push({
                    src: portData['@ID'],
                    dst: connectedPortIDs[i]
                });
            }
        }
    };
    //</editor-fold>

    //<editor-fold desc="============================ Making of connections =========================">
    AdmImporter.prototype.gatherComponentInstanceContent = function (callback) {
        var self = this,
            i,
            error = '',
            counter = self.componentInstances.length,
            afterLoadChildren = function (componentInstance) {
                return function (err, children) {
                    counter -= 1;
                    if (err) {
                        error += err;
                    } else {
                        self.addToConnectorsAndPropertiesMaps(componentInstance, children);
                    }
                    if (counter <= 0) {
                        callback(error);
                    }
                };
            };

        if (counter === 0) {
            callback(null);
            return;
        }
        for (i = 0; i < self.componentInstances.length; i += 1) {
            self.core.loadChildren(self.componentInstances[i].node, afterLoadChildren(self.componentInstances[
                i]));
        }
    };

    AdmImporter.prototype.addToConnectorsAndPropertiesMaps = function (componentInstance, children) {
        //        self.componentInstances.push({
        //            node: component,
        //            connIdInModel2ID: connIdInModel2ID,
        //            propertyIdInModel2ID: propertyIdInModel2ID
        //        });
        var self = this,
            i,
            id,
            metaTypeName;

        for (i = 0; i < children.length; i += 1) {
            metaTypeName = self.core.getAttribute(self.getMetaType(children[i]), 'name');
            if (metaTypeName === 'Connector') {
                id = self.core.getAttribute(children[i], 'ID');
                if (componentInstance.connIdInModel2ID[id]) {
                    self.connID2Node[componentInstance.connIdInModel2ID[id]] = children[i];
                } else {
                    self.logger.error('ConnectorID' + id + ' not in ' + self.core.getAttribute(componentInstance.node,
                        'name'));
                }
            } else if (metaTypeName === 'Property') {
                id = self.core.getAttribute(children[i], 'ID');
                if (componentInstance.propertyIdInModel2ID[id]) {
                    self.valueFlowTargetID2Node[componentInstance.propertyIdInModel2ID[id]] = children[i];
                } else {
                    self.logger.error('PropertyID' + id + ' not in ' + self.core.getAttribute(componentInstance.node,
                        'name'));
                }
            } else if (metaTypeName === 'DomainPort') {
                id = self.core.getAttribute(children[i], 'ID');
                if (componentInstance.portIdInModel2ID[id]) {
                    self.portID2Node[componentInstance.portIdInModel2ID[id]] = children[i];
                } else {
                    self.logger.error('PortID' + id + ' not in ' + self.core.getAttribute(componentInstance.node,
                        'name'));
                }
            }
        }
    };

    AdmImporter.prototype.makeConnectorCompositions = function () {
        var self = this,
            srcID,
            dstID,
            parentNode,
            srcNode,
            dstNode,
            i,
            connectionNode,
            jointID,
            filteredConnections = {};

        for (i = 0; i < self.connectorCompositions.length; i += 1) {
            srcID = self.connectorCompositions[i].src;
            dstID = self.connectorCompositions[i].dst;
            jointID = srcID + '__' + dstID;
            if (filteredConnections[jointID]) {
                // self.logger.info('Connection between ' + jointID + ' already added.');
            } else {
                self.logger.info('Adding [src] ' + srcID + ' and [dst]' + dstID);
                jointID = dstID + '__' + srcID;
                filteredConnections[jointID] = true;
                srcNode = self.connID2Node[srcID];
                dstNode = self.connID2Node[dstID];
                parentNode = self.getConnectionParent(srcNode, dstNode, srcID, dstID);
                if (parentNode) {
                    connectionNode = self.core.createNode({
                        parent: parentNode,
                        base: self.meta.ConnectorComposition
                    });
                    self.core.setPointer(connectionNode, 'src', srcNode);
                    self.core.setPointer(connectionNode, 'dst', dstNode);
                } else {
                    self.logger.error('Could not make connector-composition between src: ' + srcID +
                    ' and dst: ' + dstID + '.');
                }
            }
        }
    };

    AdmImporter.prototype.makePortMaps = function () {
        var self = this,
            srcID,
            dstID,
            parentNode,
            srcNode,
            dstNode,
            i,
            portMapNode,
            jointID,
            filteredPortMaps = {};

        for (i = 0; i < self.portMaps.length; i += 1) {
            srcID = self.portMaps[i].src;
            dstID = self.portMaps[i].dst;
            jointID = srcID + '__' + dstID;
            if (filteredPortMaps[jointID]) {
                // self.logger.info('Connection between ' + jointID + ' already added.');
            } else {
                self.logger.info('Adding [src] ' + srcID + ' and [dst]' + dstID);
                jointID = dstID + '__' + srcID;
                filteredPortMaps[jointID] = true;
                srcNode = self.portID2Node[srcID];
                dstNode = self.portID2Node[dstID];
                parentNode = self.getConnectionParent(srcNode, dstNode, srcID, dstID);
                if (parentNode) {
                    portMapNode = self.core.createNode({
                        parent: parentNode,
                        base: self.meta.PortMap
                    });
                    self.core.setPointer(portMapNode, 'src', srcNode);
                    self.core.setPointer(portMapNode, 'dst', dstNode);
                } else {
                    self.logger.error('Could not make port-map between src: ' + srcID +
                    ' and dst: ' + dstID + '.');
                }
            }
        }
    };

    AdmImporter.prototype.makeValueFlows = function () {
        var self = this,
            i,
            srcNode,
            dstNode,
            symbol,
            parentNode,
            valueFlowNode;
        for (i = 0; i < self.valueFlows.length; i += 1) {
            srcNode = self.valueFlowTargetID2Node[self.valueFlows[i].src];
            dstNode = self.valueFlowTargetID2Node[self.valueFlows[i].dst];
            symbol = self.valueFlows[i].symbol;
            parentNode = self.getConnectionParent(srcNode, dstNode, self.valueFlows[i].src, self.valueFlows[i]
                .dst);
            if (parentNode) {
                valueFlowNode = self.core.createNode({
                    parent: parentNode,
                    base: self.meta.ValueFlowComposition
                });
                self.core.setPointer(valueFlowNode, 'src', srcNode);
                self.core.setPointer(valueFlowNode, 'dst', dstNode);
                if (symbol) {
                    self.logger.info('About to add value-flow into customFormula');
                    if (symbol !== self.core.getAttribute(srcNode, 'name')) {
                        self.core.setAttribute(valueFlowNode, 'VariableName', symbol);
                    }
                }
            } else {
                self.logger.error('Could not make value-flow connection between src: ' + self.valueFlows[i].src +
                ' and dst: ' + self.valueFlows[i].dst + '.');
            }
        }
    };

    AdmImporter.prototype.getConnectionParent = function (srcNode, dstNode, srcId, dstId) {
        var self = this,
            parent,
            errMsg,
            srcParent,
            dstParent,
            srcDepth,
            dstDepth;
        if (!srcNode || !dstNode) {
            errMsg = 'Making connection not possible srcID: "' + srcId + '", dstID: "' + dstId + '".';
            if (srcNode) {
                errMsg += ' SrcNode exists, name: "' + self.core.getAttribute(srcNode, 'name') + '", parent : "' +
                self.core.getAttribute(self.core.getParent(srcNode), 'name') + '".';
            } else {
                errMsg += ' The srcNode does not exist!';
            }
            if (dstNode) {
                errMsg += ' DstNode exists, name: "' + self.core.getAttribute(dstNode, 'name') + '", parent : "' +
                self.core.getAttribute(self.core.getParent(dstNode), 'name') + '".';
            } else {
                errMsg += ' The dstNode does not exist!';
            }
            self.currentSuccess = false;
            self.createMessage(dstNode || srcNode || null, errMsg, 'error');
            return null;
        }
        srcParent = self.core.getParent(srcNode);
        dstParent = self.core.getParent(dstNode);
        if (srcParent === dstParent && self.isMetaTypeOf(srcParent, self.META.Connector)) {
            parent = self.core.getParent(srcParent);
        } else if (srcParent === dstParent) {
            parent = srcParent;
        } else {
            srcDepth = self.core.getPath(srcParent)
                .split('/')
                .length;
            dstDepth = self.core.getPath(dstParent)
                .split('/')
                .length;
            if (srcDepth < dstDepth) {
                parent = srcParent;
            } else if (dstDepth > srcDepth) {
                parent = dstParent;
            } else {
                parent = self.core.getParent(srcParent);
            }
        }
        return parent;
    };

    //</editor-fold>

    AdmImporter.prototype.endsWith = function (str, ending) {
        var lastIndex = str.lastIndexOf(ending);
        return ( lastIndex !== -1 ) && ( lastIndex + ending.length === str.length );
    };

    AdmImporter.prototype.startsWith = function (str, start) {
        if (start === '') {
            return true;
        }
        return start.length > 0 && str.substring(0, start.length) === start;
    };

    AdmImporter.prototype.runPlugin = function (pluginClass, config, context) {
        var self = this;

        var pluginContext = new PluginContext();
        pluginContext.activeNode = self.activeNode;
        pluginContext.META = self.META;
        pluginContext.project = self.project;
        pluginContext.projectName = self.project.projectName;
        pluginContext.core = self.core;
        pluginContext.commitHash = self.commitHash;
        pluginContext.activeSelection = []; // selected objects
        pluginContext.rootNode = self.rootNode;

        for (var key in context) {
            if (context.hasOwnProperty(key)) {
                pluginContext[key] = context[key];
            }
        }

        var plugin = new pluginClass();
        var pluginLogger = self.logger.fork('Plugin.' + plugin.getName());
        plugin.save = function (message, callback) {
            callback(null);
        };
        var startTime = (new Date()).toISOString();
        plugin.initialize(pluginLogger, self.blobClient, self.gmeConfig);

        plugin.setCurrentConfig(config);

        plugin.configure(pluginContext);
        return Q.ninvoke(plugin, 'main')
            .then(function (result) {
                result.setFinishTime((new Date()).toISOString());
                result.setStartTime(startTime);

                if (!result.success) {
                    return Q.reject(result.error || result.messages[0].message);
                }
                return result;
            });
    };

    return AdmImporter;
});
