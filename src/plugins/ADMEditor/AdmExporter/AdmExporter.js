/*globals define*/
/**
 * Generated by PluginGenerator from webgme on Tue Apr 29 2014 17:05:39 GMT-0500 (Central Daylight Time).
 */

define( [
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'plugin/AdmExporter/AdmExporter/meta',
    'xmljsonconverter',
    'plugin/AdmExporter/AdmExporter/Templates/Templates',
    'ejs'
], function ( PluginConfig, PluginBase, MetaTypes, Converter, TEMPLATES, ejs ) {
    'use strict';

    /**
     * Initializes a new instance of AdmExporter.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin AdmExporter.
     * @constructor
     */
    var AdmExporter = function () {
        // Call base class' constructor.
        PluginBase.call( this );
        this.meta = null;
        this.admData = {
            "@xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
            "@xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
            "@DesignID": '',
            "@Name": '',
            "@xmlns": "avm",
            "RootContainer": null
        };

        this.acmFiles = {};
        this.gatheredAcms = {};
        this.includeAcms = true;
        // No value flows or connector-compositions beyond the root-container
        // should be reported in the adm file.
        this.rootPath = null;
        this.selectedCfg = null;
        this.selectedAlternatives = null;
    };

    // Prototypal inheritance from PluginBase.
    AdmExporter.prototype = Object.create( PluginBase.prototype );
    AdmExporter.prototype.constructor = AdmExporter;

    /**
     * Gets the name of the AdmExporter.
     * @returns {string} The name of the plugin.
     * @public
     */
    AdmExporter.prototype.getName = function () {
        return "ADM Exporter";
    };

    /**
     * Gets the semantic version (semver.org) of the AdmExporter.
     * @returns {string} The version of the plugin.
     * @public
     */
    AdmExporter.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
     * Gets the description of the AdmExporter.
     * @returns {string} The description of the plugin.
     * @public
     */
    AdmExporter.prototype.getDescription = function () {
        return "Exports a design into an adm.";
    };

    /**
     * Gets the configuration structure for the AdmExporter.
     * The ConfigurationStructure defines the configuration for the plugin
     * and will be used to populate the GUI when invoking the plugin from webGME.
     * @returns {object} The version of the plugin.
     * @public
     */
    AdmExporter.prototype.getConfigStructure = function () {
        return [ {
            'name': 'acms',
            'displayName': 'Include ACMs',
            'description': 'Bundles all encountered ACMs within the package and creates scripts for importing the ' +
                'design into desktop GME.',
            'value': false,
            'valueType': 'boolean',
            'readOnly': false
        }, {
            'name': 'desertCfg',
            'displayName': 'Desert Configuration.',
            'description': 'Only this configuration will be exported. (If empty whole design space will be exported.)',
            'value': '',
            'valueType': 'string',
            'readOnly': false
        } ];
    };

    AdmExporter.prototype.getPositionUInt32 = function ( node ) {
        var pos = this.core.getRegistry( node, 'position' );
        return {
            x: Math.min( pos.x >>> 0, Math.pow( 2, 31 ) - 1 ), // make UInt32 âˆ© Int32
            y: Math.min( pos.y >>> 0, Math.pow( 2, 31 ) - 1 )
        };
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    AdmExporter.prototype.main = function ( callback ) {
        var self = this,
            //timeStart = new Date().getTime(),
            jsonToXml = new Converter.Json2xml(),
            config = self.getCurrentConfig(),
            finishAndSaveArtifact,
            createArtifacts;
        if ( !self.activeNode ) {
            self.createMessage( null,
                'Active node is not present! This happens sometimes... Loading another model ' +
                'and trying again will solve it most of times.', 'error' );
            callback( 'Active node is not present!', self.result );
            return;
        }
        if ( self.isMetaTypeOf( self.activeNode, self.META.Container ) === false ) {
            self.createMessage( null, 'This plugin must be called from a Container.', 'error' );
            callback( null, self.result );
            return;
        }
        self.meta = MetaTypes;
        self.updateMETA( self.meta );
        self.rootPath = self.core.getPath( self.activeNode );
        finishAndSaveArtifact = function ( artifact ) {
            artifact.save( function ( err, hash ) {
                if ( err ) {
                    self.result.setSuccess( false );
                    callback( 'Could not save artifact : err' + err.toString(), self.result );
                    return;
                }
                self.result.addArtifact( hash );
                self.result.setSuccess( true );
                callback( null, self.result );
            } );
        };

        self.setupDesertCfg( config.desertCfg, function ( err ) {
            if ( err ) {
                self.logger.error( err );
                callback( null, self.result );
                return;
            }
            if ( self.selectedAlternatives ) {
                self.logger.info( 'Running on single configuration' );
                self.logger.info( JSON.stringify( self.selectedAlternatives, null ) );
            }
            createArtifacts = function ( err ) {
                var artifact,
                    admXmlStr;
                if ( err ) {
                    callback( err, self.result );
                    return;
                }
                artifact = self.blobClient.createArtifact( 'design' );
                admXmlStr = jsonToXml.convertToString( {
                    Design: self.admData
                } );

                artifact.addFile( self.admData[ '@Name' ] + '.adm', admXmlStr, function ( err, hash ) {
                    if ( err ) {
                        self.result.setSuccess( false );
                        callback( 'Could not add adm file : err' + err.toString(), self.result );
                        return;
                    }
                    self.logger.info( 'ADM hash: ' + hash );
                    if ( self.includeAcms ) {
                        artifact.addObjectHashes( self.acmFiles, function ( err, hashes ) {
                            if ( err ) {
                                self.result.setSuccess( false );
                                callback( 'Could not add acm files : err' + err.toString(), self.result );
                                return;
                            }
                            self.logger.info( 'ACM hashes: ' + hashes.toString() );
                            artifact.addFiles( {
                                'execute.py': ejs.render( TEMPLATES[ 'execute.py.ejs' ] ),
                                'run_execution.cmd': ejs.render( TEMPLATES[ 'run_execution.cmd.ejs' ] ),
                                'empty.xme': ejs.render( TEMPLATES[ 'empty.xme.ejs' ] ),
                                'executor_config.json': JSON.stringify( {
                                    cmd: 'run_execution.cmd',
                                    files: [],
                                    dirs: []
                                }, null, 4 )
                            }, function ( err, hashes ) {
                                if ( err ) {
                                    callback( 'Could not script files : err' + err.toString(), self
                                        .result );
                                    return;
                                }
                                self.logger.info( 'Script hashes: ' + hashes.toString() );
                                finishAndSaveArtifact( artifact );
                            } );
                        } );
                    } else {
                        finishAndSaveArtifact( artifact );
                    }
                } );
            };
            self.exploreDesign( self.activeNode, config.acms, createArtifacts );
        } );
    };

    AdmExporter.prototype.setupDesertCfg = function ( desertCfgId, callback ) {
        var self = this;
        if ( !desertCfgId ) {
            callback( null );
            return;
        }
        self.core.loadByPath( self.rootNode, desertCfgId, function ( err, cfgNode ) {
            var name,
                i,
                aas;
            if ( err ) {
                self.createMessage( null, 'Could not load given configuration node, err: ' + err.toString(),
                    'error' );
                callback( err );
                return;
            }
            if ( self.startsWith( desertCfgId, self.rootPath ) === false ) {
                self.createMessage( cfgNode, 'Given desert configuration is not within design.', 'error' );
                callback( 'Given desert configuration is not within design.' );
                return;
            }
            if ( self.isMetaTypeOf( cfgNode, self.meta.DesertConfiguration ) === false ) {
                self.createMessage( cfgNode,
                    'Given path to desert configuration is not pointing to a DesertConfiguration node.',
                    'error' );
                callback( 'Wrong meta-type of desert configuration.' );
                return;
            }
            name = self.core.getAttribute( cfgNode, 'name' );
            aas = JSON.parse( self.core.getAttribute( cfgNode, 'AlternativeAssignments' ) );
            self.selectedAlternatives = {};
            for ( i = 0; i < aas.length; i += 1 ) {
                self.selectedAlternatives[ aas[ i ].alternativeOf ] = aas[ i ].selectedAlternative;
            }
            callback( null );
        } );
    };

    AdmExporter.prototype.shouldBeGenerated = function ( node ) {
        var self = this,
            parentNode,
            parentId;
        if ( !self.selectedAlternatives ) {
            return true;
        }
        parentNode = self.core.getParent( node );
        if ( self.core.getAttribute( parentNode, 'Type' ) !== 'Alternative' ) {
            return true;
        }
        parentId = self.core.getPath( parentNode );
        if ( self.selectedAlternatives[ parentId ] ) {
            if ( self.selectedAlternatives[ parentId ] === self.core.getPath( node ) ) {
                return true;
            }
        } else {
            self.createMessage( parentNode,
                'Container is not in the desert-configuration, the latter is out of date.',
                'error' );
            return false;
        }

        return false;
    };

    AdmExporter.prototype.exploreDesign = function ( startNode, includeACMs, callback ) {
        var self = this,
            designName = self.core.getAttribute( startNode, 'name' );
        self.includeAcms = includeACMs;
        self.admData[ '@Name' ] = designName;
        self.admData[ '@DesignID' ] = self.core.getGuid( startNode );
        self.rootPath = self.core.getPath( startNode );
        self.logger.info( 'rootPath is ' + self.rootPath );
        self.visitAllChildrenFromRootContainer( startNode, callback );
    };

    AdmExporter.prototype.atModelNode = function ( node, parent, containerData, callback ) {
        var self = this,
            nodeType = self.core.getAttribute( self.getMetaType( node ), 'name' ),
            nodeName = self.core.getAttribute( node, 'name' ),
            parentName = self.core.getAttribute( parent, 'name' );

        if ( nodeType === 'AVMComponentModel' ) {
            if ( self.shouldBeGenerated( node ) ) {
                self.addComponentInstance( node, parent, containerData, callback );
            } else {
                self.logger.info( 'At node "' + nodeName + '" of type "' + nodeType + '" with parent "' +
                    parentName + '".' );
                self.logger.info( 'Will not be generated!' );
                callback( null );
            }
        } else if ( nodeType === 'Connector' ) {
            self.addConnector( node, parent, containerData, callback );
        } else if ( nodeType === 'Property' ) {
            self.addProperty( node, parent, containerData, callback );
        } else if ( nodeType === 'SimpleFormula' ) {
            self.addFormula( node, parent, containerData, true, callback );
        } else if ( nodeType === 'CustomFormula' ) {
            self.addFormula( node, parent, containerData, false, callback );
        } else if ( nodeType === 'DomainPort' ) {
            self.addDomainPort( node, parent, containerData, callback );
        } else if ( nodeType === 'AssemblyRoot' ) {
            self.addAssemblyRoot( node, parent, containerData, callback );
        } else {
            callback( null );
        }
    };

    AdmExporter.prototype.addComponentInstance = function ( node, parent, containerData, callback ) {
        var self = this,
            pos = self.getPositionUInt32( node ),
            nodeName = self.core.getAttribute( node, 'name' ),
            acmHash,
            componentID = self.core.getAttribute( node, 'ID' ),
            data = {
                "@Name": nodeName,
                "@ComponentID": componentID,
                "@ID": self.core.getGuid( node ),
                "@XPosition": pos.x,
                "@YPosition": pos.y,
                "PortInstance": [],
                "PrimitivePropertyInstance": [],
                "ConnectorInstance": []
            };

        if ( containerData.TopLevelSystemUnderTest === undefined ) {
            containerData.ComponentInstance.push( data );
        } else {
            containerData.TestComponent.push( data );
        }

        if ( self.includeAcms ) {
            acmHash = self.core.getAttribute( node, 'Resource' );
            if ( acmHash ) {
                if ( self.gatheredAcms[ acmHash ] ) {
                    self.logger.info( 'ACM of "' + nodeName + '" used twice. Not adding again..' );
                } else {
                    self.acmFiles[ 'ACMs/' + nodeName + '__' + componentID.replace( /[^\w]/gi, '_' ) + '.zip' ] =
                        acmHash;
                    self.gatheredAcms[ acmHash ] = true;
                }
            } else {
                self.logger.error( 'ACM was not specified for ' + nodeName );
                callback( 'ACM was not specified for ' + nodeName );
                return;
            }
        }
        self.core.loadChildren( node, function ( err, children ) {
            var i,
                error = '',
                counter,
                counterCallback;
            if ( err ) {
                callback( 'loadChildren failed for ' + nodeName + ' :' + err.toString() );
                return;
            }

            counterCallback = function ( err ) {
                error = err ? error + err : error;
                counter -= 1;
                if ( counter <= 0 ) {
                    callback( error );
                }
            };

            if ( children.length === 0 ) {
                counter = 1;
                counterCallback( null );
                return;
            }

            counter = children.length;

            for ( i = 0; i < children.length; i += 1 ) {
                if ( self.isMetaTypeOf( children[ i ], self.meta.Connector ) ) {
                    self.addConnector( children[ i ], node, data, counterCallback );
                } else if ( self.isMetaTypeOf( children[ i ], self.meta.DomainPort ) ) {
                    self.addDomainPort( children[ i ], node, data, counterCallback );
                } else if ( self.isMetaTypeOf( children[ i ], self.meta.Property ) ) {
                    self.addProperty( children[ i ], node, data, counterCallback );
                } else {
                    counterCallback( null );
                }
            }
        } );
    };

    //<editor-fold desc="=========================== Connectors/DomainPorts ==========================">
    AdmExporter.prototype.addConnector = function ( node, parent, containerData, callback ) {
        var self = this,
            parentType = self.core.getAttribute( self.getMetaType( parent ), 'name' ),
            errMsg,
            data = self.getConnectorData( node, parent );

        if ( parentType === 'Container' ) {
            containerData.Connector.push( data );
        } else if ( parentType === 'AVMComponentModel' ) {
            containerData.ConnectorInstance.push( data );
        } else {
            errMsg = 'Unexpected parentType in addConnector: ' + parentType;
            self.logger.error( errMsg );
            callback( errMsg );
            return;
        }

        self.addRoles( node, data, function ( err ) {
            if ( err ) {
                callback( err );
                return;
            }
            self.getConnectionString( node, function ( err, connectionString ) {
                if ( err ) {
                    callback( err );
                    return;
                }
                data[ '@ConnectorComposition' ] = connectionString;
                callback( null );
            } );
        } );
    };

    AdmExporter.prototype.addDomainPort = function ( node, parent, containerData, callback ) {
        var self = this,
            parentType = self.core.getAttribute( self.getMetaType( parent ), 'name' ),
            data = self.getDomainPortData( node, parent );

        if ( parentType === 'Container' ) {
            containerData.Port.push( data );
        } else if ( parentType === 'AVMComponentModel' ) {
            containerData.PortInstance.push( data );
        }

        self.getConnectionString( node, function ( err, connectionString ) {
            if ( err ) {
                callback( err );
                return;
            }
            data[ '@PortMap' ] = connectionString;
            callback( null );
        } );
    };

    AdmExporter.prototype.addRoles = function ( connectorNode, data, callback ) {
        var self = this,
            domainConnectors = data.Role,
            nodeName;

        if ( domainConnectors === undefined ) {
            // This a connector within an ACM..
            callback( null );
            return;
        }

        nodeName = self.core.getAttribute( connectorNode, 'name' );
        self.core.loadChildren( connectorNode, function ( err, children ) {
            var i,
                roleData,
                counter = children.length,
                error = '',
                getCounterCallback = function ( portData ) {
                    return function ( err, connectionString ) {
                        error = err ? error + err : error;
                        portData[ '@PortMap' ] = connectionString;
                        counter -= 1;
                        if ( counter === 0 ) {
                            callback( error );
                        }
                    };
                };
            if ( err ) {
                callback( 'loadChildren failed for connector ' + nodeName + ' :' + err.toString() );
                return;
            }

            if ( children.length === 0 ) {
                callback( null );
            }
            for ( i = 0; i < children.length; i += 1 ) {
                if ( self.isMetaTypeOf( children[ i ], self.META.DomainPort ) ) {
                    roleData = self.getDomainPortData( children[ i ], connectorNode );
                    domainConnectors.push( roleData );
                    self.getConnectionString( children[ i ], getCounterCallback( roleData ) );
                } else if ( self.isMetaTypeOf( children[ i ], self.META.PortMap ) ) {
                    // TODO
                    if ( --counter === 0 ) {
                        callback( error );
                    }
                } else {
                    self.logger.error( "Unexpected '" + self.getMetaType( children[ i ] ) + "' in Connector '" +
                        core.getAttribute( "name", connectorNode ) );
                    if ( --counter === 0 ) {
                        callback( error );
                    }
                }
            }
        } );
    };


    /**
     * Gets the full connection string for ConnectorComposition/PortMap of a Connector/DomainPort.
     * @param portNode - Connector or DomainPort.
     * @param {function} callback
     */
    AdmExporter.prototype.getConnectionString = function ( portNode, callback ) {
        var self = this,
            collectionNames = self.core.getCollectionNames( portNode ),
            counter = 2,
            error = '',
            connectionString = '',
            counterCallback = function ( err ) {
                error = err ? error + err : error;
                counter -= 1;
                if ( counter === 0 ) {
                    callback( error, connectionString );
                }
            };

        if ( collectionNames.indexOf( 'src' ) > -1 ) {
            self._getPartialConnectionString( portNode, 'src', function ( err, dstId ) {
                if ( err ) {
                    counterCallback( err );
                    return;
                }
                connectionString = self.appendWhiteSpacedString( connectionString, dstId );
                counterCallback( null );
            } );
        } else {
            counterCallback( null );
        }
        if ( collectionNames.indexOf( 'dst' ) > -1 ) {
            self._getPartialConnectionString( portNode, 'dst', function ( err, srcId ) {
                if ( err ) {
                    counterCallback( err );
                    return;
                }
                connectionString = self.appendWhiteSpacedString( connectionString, srcId );
                counterCallback( null );
            } );
        } else {
            counterCallback( null );
        }
    };

    AdmExporter.prototype._getPartialConnectionString = function ( portNode, collectionName, callback ) {
        var self = this,
            pointerName = collectionName === 'src' ? 'dst' : 'src';

        self.core.loadCollection( portNode, collectionName, function ( err, connections ) {
            var counter, i,
                counterCallback,
                error = '',
                connectedIDs = '';
            if ( err ) {
                callback( err );
                return;
            }
            counterCallback = function ( err, connectedID ) {
                if ( err ) {
                    error += err;
                } else {
                    connectedIDs = self.appendWhiteSpacedString( connectedIDs, connectedID );
                }
                counter -= 1;
                if ( counter <= 0 ) {
                    callback( error, connectedIDs );
                }
            };
            counter = connections.length;
            if ( connections.length === 0 ) {
                counterCallback( null, '' );
                return;
            }
            for ( i = 0; i < connections.length; i += 1 ) {
                self.getConnectedPortID( connections[ i ], pointerName, counterCallback );
            }
        } );
    };

    /**
     * Gets the ID of the connected Connector or DomainPort. (If the connected one is not part of the configuration -
     * the 'returned' id is empty.)
     * @param connectionNode - ConnectorComposition or PortMap to get the connected Connector/DomainPort through.
     * @param {string} pointerName - 'src' or 'dst'.
     * @param {function} callback
     */
    AdmExporter.prototype.getConnectedPortID = function ( connectionNode, pointerName, callback ) {
        var self = this,
            hasPointer = self.core.hasPointer( connectionNode, pointerName );

        if ( hasPointer ) {
            self.core.loadPointer( connectionNode, pointerName, function ( err, connectedPort ) {
                var id = '',
                    parent,
                    grandParent,
                    grandParentMetaType,
                    parentMetaType;
                if ( err ) {
                    callback( err );
                    return;
                }
                if ( self.nodeIsWithinDesign( connectedPort ) ) {
                    parent = self.core.getParent( connectedPort );
                    parentMetaType = self.core.getAttribute( self.getMetaType( parent ), 'name' );
                    if ( parentMetaType === 'AVMComponentModel' ) {
                        //If parent of parent is alternative, then only add if parent is in AA.
                        if ( self.shouldBeGenerated( parent ) ) {
                            id = 'id-' + self.core.getGuid( parent ) + '-' + self.core.getAttribute(
                                connectedPort, 'ID' );
                        }
                    } else if ( parentMetaType === 'Container' ) {
                        //If parent of parent is alternative, then only add if parent is in AA.
                        if ( self.shouldBeGenerated( parent ) ) {
                            id = self.core.getGuid( connectedPort );
                        }
                    } else if ( parentMetaType === 'Connector' ) {
                        grandParent = self.core.getParent( parent );
                        grandParentMetaType = self.core.getAttribute( self.getMetaType( grandParent ), 'name' );
                        if ( grandParentMetaType === 'Container' ) {
                            if ( self.shouldBeGenerated( grandParent ) ) {
                                id = self.core.getGuid( connectedPort );
                            }
                        } else {
                            callback( 'Unexpected Connector grandParentMetaType ' + grandParentMetaType );
                            return;
                        }
                    } else {
                        callback( 'Unexpected Connector parentMetaType ' + parentMetaType );
                        return;
                    }
                }
                callback( null, id );
            } );
        } else {
            self.createMessage( connectionNode, 'Connection with no src/dst exists in design.', 'error' );
            callback( 'A connection with only one direction pointer exists in model.' );
        }
    };
    //</editor-fold>

    //<editor-fold desc="=========================== Properties/ValueFlows ==========================">
    AdmExporter.prototype.addProperty = function ( node, parent, containerData, callback ) {
        var self = this,
            pos = self.getPositionUInt32( node ),
            parentType = self.core.getAttribute( self.getMetaType( parent ), 'name' ),
            collectionNames = self.core.getCollectionNames( node ),
            valueType = self.core.getAttribute( node, 'ValueType' ),
            dataType = self.core.getAttribute( node, 'DataType' ),
            unit,
            data,
            value,
            id,
            addPropertyData;

        addPropertyData = function ( valueSourceID ) {
            if ( parentType === 'Container' ) {
                id = self.core.getGuid( node );
                data = {
                    "@xsi:type": "q1:PrimitiveProperty",
                    "@Name": self.core.getAttribute( node, 'name' ),
                    "@ID": null,
                    "@XPosition": pos.x,
                    "@YPosition": pos.y,
                    "Value": {
                        "@ID": id,
                        "@DimensionType": "Scalar",
                        "@Dimensions": "",
                        "@DataType": dataType,
                        "ValueExpression": null
                    }
                };
                unit = self.core.getAttribute( node, 'Unit' );
                if ( unit ) {
                    data.Value[ '@Unit' ] = unit;
                }
                value = self.core.getAttribute( node, 'Value' ) || '';
                if ( valueType === 'Parametric' ) {
                    data[ '@ID' ] = 'param.' + id;
                    data.Value.ValueExpression = {
                        "@xsi:type": "q1:" + valueType + "Value",
                        "Default": {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": self.core.getAttribute( node, 'Default' ) || ''
                            }
                        },
                        "Maximum": {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": self.core.getAttribute( node, 'Maximum' ) || ''
                            }
                        },
                        "Minimum": {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": self.core.getAttribute( node, 'Minimum' ) || ''
                            }
                        },
                        "AssignedValue": null
                    };
                    if ( valueSourceID ) {
                        data.Value.ValueExpression.AssignedValue = {
                            "@xsi:type": "q1:DerivedValue",
                            "@ValueSource": valueSourceID
                        };
                    } else {
                        data.Value.ValueExpression.AssignedValue = {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": value
                            }
                        };
                    }
                } else if ( valueType === 'Fixed' ) {
                    data[ '@ID' ] = 'property.' + id;
                    if ( valueSourceID ) {
                        data.Value.ValueExpression = {
                            "@xsi:type": "q1:DerivedValue",
                            "@ValueSource": valueSourceID
                        };
                    } else {
                        data.Value.ValueExpression = {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": value
                            }
                        };
                    }
                } else {
                    self.logger.error( 'Unexpected property value type, ' + valueType );
                }
                containerData.Property.push( data );
            } else if ( parentType === 'AVMComponentModel' ) {
                id = self.core.getAttribute( node, 'ID' );
                data = {
                    "@IDinComponentModel": id,
                    "Value": {
                        "@ID": 'id-' + self.core.getGuid( parent ) + '-' + id,
                        "@DimensionType": "Scalar",
                        "@Dimensions": "",
                        "@DataType": dataType
                    }
                };
                if ( valueSourceID ) {
                    data.Value.ValueExpression = {
                        "@xsi:type": "q1:DerivedValue",
                        "@ValueSource": valueSourceID
                    };
                }
                containerData.PrimitivePropertyInstance.push( data );
            } else {
                self.logger.error( 'Unexpected parentType for property, ' + parentType );
            }

            callback( null );
        };
        if ( collectionNames.indexOf( 'dst' ) < 0 ) {
            addPropertyData( null );
        } else {
            self.core.loadCollection( node, 'dst', function ( err, valueFlows ) {
                if ( err ) {
                    callback( 'Could not load collection for ' + self.core.getAttribute( node, 'name' ) +
                        'err: ' + err.toString() );
                    return;
                }
                if ( valueFlows.length > 1 ) {
                    if ( self.core.getAttribute( parent, 'Type' ) !== 'Alternative' ) {
                        self.createMessage( node, self.core.getAttribute( node, 'name' ) +
                            ' had more than one incoming value', 'warning' );
                        callback( null );
                    } else if ( self.selectedAlternatives ) {
                        // With only one configuration or within a non-alternative container there should NOT be any muxes.
                        self.getValueSrcId( valueFlows, node, parent, function ( err, srcId ) {
                            if ( err ) {
                                callback(
                                    'Problems getting ValueSrcId in alternative for configuration, err: ' +
                                    err );
                            } else {
                                addPropertyData( srcId );
                            }
                        } );
                    } else {
                        self.addValueFlowMux( valueFlows, parent, containerData, function ( err, muxId ) {
                            if ( err ) {
                                self.createMessage( node, 'Property had multiple incoming value-flows.' +
                                    ' Failed to add valueFlow-mux for it.', 'error' );
                                callback( err );
                            } else {
                                addPropertyData( muxId );
                            }
                        } );
                    }
                } else {
                    self.getValueSrcId( valueFlows, node, parent, function ( err, srcId ) {
                        if ( err ) {
                            callback( 'Problems getting ValueSrcId, err: ' + err );
                        } else {
                            addPropertyData( srcId );
                        }
                    } );
                }
            } );
        }
    };

    AdmExporter.prototype.addFormula = function ( node, parent, containerData, isSimple, callback ) {
        var self = this,
            pos = self.getPositionUInt32( node ),
            collectionNames = self.core.getCollectionNames( node ),
            formulaName = self.core.getAttribute( node, 'name' ),
            data,
            id = self.core.getGuid( node ),
            addFormulaData;
        self.logger.info( 'At formula "' + formulaName + '".' );
        addFormulaData = function ( operands, error ) {
            var i;
            if ( isSimple ) {
                data = {
                    "@xmlns:q1": "avm",
                    "@xmlns": "",
                    "@xsi:type": "q1:SimpleFormula",
                    "@ID": id,
                    "@Name": formulaName,
                    "@XPosition": pos.x,
                    "@YPosition": pos.y,
                    "@Operation": self.core.getAttribute( node, 'Method' ),
                    "@Operand": ''
                };
                for ( i = 0; i < operands.length; i += 1 ) {
                    data[ "@Operand" ] = self.appendWhiteSpacedString( data[ "@Operand" ], operands[ i ].id );
                }
            } else {
                data = {
                    "@xmlns:q1": "avm",
                    "@xmlns": "",
                    "@xsi:type": "q1:ComplexFormula",
                    "@ID": id,
                    "@Name": formulaName,
                    "@XPosition": pos.x,
                    "@YPosition": pos.y,
                    "@Expression": self.core.getAttribute( node, 'Expression' ),
                    "Operand": []
                };
                for ( i = 0; i < operands.length; i += 1 ) {
                    data.Operand.push( {
                        "@Symbol": operands[ i ].symbol,
                        "@ValueSource": operands[ i ].id
                    } );
                }
            }
            containerData.Formula.push( data );
            callback( error );
        };

        if ( collectionNames.indexOf( 'dst' ) < 0 ) {
            addFormulaData( null );
        } else {
            self.core.loadCollection( node, 'dst', function ( err, valueFlows ) {
                var counter = valueFlows.length,
                    i,
                    error = '',
                    operands = [],
                    counterCallback;
                if ( err ) {
                    callback( 'Could not load collection for ' + formulaName + 'err: ' + err.toString() );
                    return;
                }
                counter = valueFlows.length;
                counterCallback = function ( valueFlow ) {

                    return function ( err, valueSource ) {
                        var symbol,
                            valueSourceId,
                            valueSourceParent,
                            parentMetaType;

                        if ( err ) {
                            error += err;
                        } else {
                            valueSourceParent = self.core.getParent( valueSource );
                            parentMetaType = self.core.getAttribute( self.getMetaType( valueSourceParent ),
                                'name' );
                            if ( parentMetaType === 'AVMComponentModel' ) {
                                if ( self.shouldBeGenerated( valueSourceParent ) ) {
                                    valueSourceId = 'id-' + self.core.getGuid( valueSourceParent ) + '-' +
                                        self.core.getAttribute( valueSource, 'ID' );
                                }
                            } else if ( parentMetaType === 'Container' ) {
                                //If parent of parent is alternative, then only add if parent is in AA.
                                if ( self.shouldBeGenerated( valueSourceParent ) ) {
                                    valueSourceId = self.core.getGuid( valueSource );
                                }
                            } else {
                                self.logger.error( 'Unexpected parentMetaType of valueSourceNode' +
                                    parentMetaType );
                            }

                            if ( !isSimple ) {
                                symbol = self.core.getAttribute( valueFlow, 'VariableName' );
                                if ( !symbol ) {
                                    symbol = self.core.getAttribute( valueSource, 'name' );
                                }
                            }
                            if ( valueSourceId ) {
                                operands.push( {
                                    symbol: symbol,
                                    id: valueSourceId
                                } );
                            }
                        }
                        counter -= 1;
                        if ( counter <= 0 ) {
                            addFormulaData( operands, error );
                        }
                    };
                };
                if ( valueFlows.length === 0 ) {
                    self.logger.warning( 'Formula "' + formulaName + '" did not have any incoming value flows.' );
                    addFormulaData( [], error );
                    return;
                }
                for ( i = 0; i < valueFlows.length; i += 1 ) {
                    if ( self.core.hasPointer( valueFlows[ i ], 'src' ) ) {
                        self.core.loadPointer( valueFlows[ i ], 'src', counterCallback( valueFlows[ i ] ) );
                    } else {
                        self.createMessage( valueFlows[ i ],
                            'ValueFlow Connection with no src exists in design.', 'error' );
                        counterCallback( valueFlows[ i ] )(
                            'A valueFlow with only one direction pointer exists in model.' );
                    }
                }
            } );
        }
    };

    AdmExporter.prototype.addValueFlowMux = function ( valueFlows, parent, containerData, callback ) {
        var self = this,
            i,
            counter = valueFlows.length,
            s4 = function () {
                return Math.floor( ( 1 + Math.random() ) * 0x10000 )
                    .toString( 16 )
                    .substring( 1 );
            },
            mux = {
                '@ID': 'muxid-' + s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4(),
                '@Source': ''
            },
            error = '',
            counterCallback = function ( err, valueSource ) {
                var valueSourceId,
                    valueSourceParent,
                    parentMetaType;

                if ( err ) {
                    error += err;
                } else {
                    valueSourceParent = self.core.getParent( valueSource );
                    parentMetaType = self.core.getAttribute( self.getMetaType( valueSourceParent ), 'name' );
                    if ( parentMetaType === 'AVMComponentModel' ) {
                        valueSourceId = 'id-' + self.core.getGuid( valueSourceParent ) + '-' + self.core.getAttribute(
                            valueSource, 'ID' );
                    } else if ( parentMetaType === 'Container' ) {
                        valueSourceId = self.core.getGuid( valueSource );
                    } else {
                        self.logger.error( 'Unexpected parentMetaType of valueSourceNode' + parentMetaType );
                    }
                    mux[ '@Source' ] = self.appendWhiteSpacedString( mux[ '@Source' ], valueSourceId );
                }
                counter -= 1;
                if ( counter <= 0 ) {
                    callback( error, mux[ '@ID' ] );
                }
            };

        containerData.ValueFlowMux.push( mux );
        if (valueFlows.length === 0) {
            callback(null, mux[ '@ID' ]);
            return;
        }
        for ( i = 0; i < valueFlows.length; i += 1 ) {
            if ( self.core.hasPointer( valueFlows[ i ], 'src' ) ) {
                self.core.loadPointer( valueFlows[ i ], 'src', counterCallback );
            } else {
                self.createMessage( valueFlows[ i ], 'ValueFlow Connection with no src exists in design.', 'error' );
                counterCallback( 'A valueFlow with only one direction pointer exists in model.' );
            }
        }
    };

    AdmExporter.prototype.getValueSrcId = function ( valueFlows, targetNode, targetParent, callback ) {
        var self = this,
            error = '',
            i,
            finalSrcId,
            counter = valueFlows.length,
            parentType = self.core.getAttribute( self.getMetaType( targetParent ), 'name' ),
            atValueFlowNode = function ( valueFlow ) {
                var srcId;
                //counter -= 1;
                if ( !self.core.hasPointer( valueFlow, 'src' ) ) {
                    self.createMessage( valueFlow, 'ValueFlow Connection with no src exists in design.', 'error' );
                    error += 'A valueFlow with only one direction pointer exists in model.';
                    counter -= 1;
                    if ( counter <= 0 ) {
                        callback( error, null );
                    }
                } else {
                    self.core.loadPointer( valueFlow, 'src', function ( err, valueSourceNode ) {
                        var src,
                            srcParentMetaType;
                        if ( err ) {
                            error += 'Could not load src pointer for ' + self.core.getAttribute( valueFlow,
                                'name' ) + 'err: ' + err.toString();
                        } else if ( self.nodeIsWithinDesign( valueSourceNode ) ) {
                            src = self.core.getParent( valueSourceNode );
                            srcParentMetaType = self.core.getAttribute( self.getMetaType( src ), 'name' );
                            if ( srcParentMetaType === 'AVMComponentModel' ) {
                                if ( parentType === 'AVMComponentModel' && self.core.getPath( src ) ===
                                        self.core.getPath( targetParent ) ) {
                                    self.logger.info( 'Skipping connection within same ACM : ' +
                                        self.core.getAttribute( targetNode, 'name' ) );
                                } else {
                                    // If parent of parent is alternative, then only add if parent is in AA.
                                    if ( self.shouldBeGenerated( src ) ) {
                                        srcId = 'id-' + self.core.getGuid( src ) + '-' + self.core.getAttribute(
                                            valueSourceNode, 'ID' );
                                    }
                                }
                            } else if ( srcParentMetaType === 'Container' ) {
                                //If parent of parent is alternative, then only add if parent is in AA.
                                if ( self.shouldBeGenerated( src ) ) {
                                    srcId = self.core.getGuid( valueSourceNode );
                                }
                            } else {
                                self.logger.error( 'Unexpected parentMetaType of valueSourceNode' +
                                    srcParentMetaType );
                            }
                        }
                        if ( srcId ) {
                            if ( finalSrcId ) {
                                self.createMessage( targetNode, 'Cannot have more than one incoming value.',
                                    'error' );
                                error += 'There is more than one incoming value..';
                            } else {
                                finalSrcId = srcId;
                            }
                        }
                        counter -= 1;
                        if ( counter === 0 ) {
                            callback( error, finalSrcId );
                        }
                    } );
                }
            };
        if (valueFlows.length === 0) {
            callback(null);
            return;
        }
        for ( i = 0; i < valueFlows.length; i += 1 ) {
            atValueFlowNode( valueFlows[ i ] );
        }
    };
    //</editor-fold>

    AdmExporter.prototype.loadSetMembers = function ( node, setName, callback ) {
        var self = this;
        var pointedIds = self.core.getMemberPaths( node, setName );
        var pointedNodes = [];
        var error = '';


        function getLoadCallback( i ) {
            return function ( err, pointedNode ) {
                if ( err ) {
                    error += err;
                }
                pointedNodes[ i ] = pointedNode;
                counter--;
                if ( counter === 0 ) {
                    callback( error, pointedNodes, pointedIds );
                    counter--;
                }
            };
        }
        var counter = pointedIds.length;
        for ( var i = 0; i < pointedIds.length; i += 1 ) {
            if ( self.startsWith( pointedIds[ i ], self.rootPath ) ) {
                self.core.loadByPath( self.rootNode, pointedIds[ i ], getLoadCallback( i ) );
            } else {
                counter--;
                pointedNodes[ i ] = null;
                // self.logger.warning('AssemblyRoot selection is not within design, see path "' + componentIds[i] + '".');
            }
        }
        if ( counter === 0 ) {
            callback( null, pointedNodes, pointedIds );
            counter--;
        }
    };

    AdmExporter.prototype.addAssemblyRoot = function ( node, parent, containerData, callback ) {
        var self = this;
        self.loadSetMembers( node, 'Selection', function ( err, componentNodes, componentIds ) {
            var componentNode,
                i;
            if ( err ) {
                callback( 'Failed loading node from AssemblyRoot ' + err.toString() );
            } else {
                for ( i = 0; i < componentNodes.length; i++ ) {
                    componentNode = componentNodes[ i ];
                    if ( componentNode ) {
                        if ( self.shouldBeGenerated( componentNode ) ) {
                            //<DomainFeature xmlns:q3="cad" xmlns="" xsi:type="q3:AssemblyRoot"
                            // AssemblyRootComponentInstance="{9267c3e4-a944-4a68-85a8-c90dfb5a428c}" />
                            if ( self.admData.DomainFeature ) {
                                // TODO: Append the selection here when format updated.
                                self.logger.warning(
                                    'Only one AssemblyRoot can be exported, an arbitrary selection will be made!'
                                );
                                self.admData.DomainFeature[ '@AssemblyRootComponentInstance' ] = self.core.getGuid(
                                    componentNode );
                            } else {
                                self.admData.DomainFeature = {
                                    '@xmlns:q1': 'cad',
                                    '@xmlns': '',
                                    '@xsi:type': 'q1:AssemblyRoot',
                                    '@AssemblyRootComponentInstance': self.core.getGuid( componentNode )
                                };
                            }
                        } else {
                            self.logger.info( 'Skipping AssemblyRoot Selection of "' + self.core.getPath(
                                componentNode ) + '".' );
                        }
                    } else {
                        self.logger.warning( 'AssemblyRoot selection is not within design, see path "' +
                            componentIds[ i ] + '".' );
                    }
                }
                callback( null );
            }
        } );
    };

    AdmExporter.prototype.visitAllChildrenFromRootContainer = function ( rootNode, callback ) {
        var self = this,
            error = '',
            counter,
            counterCallback,
            containerData;

        counter = {
            visits: 1
        };
        counterCallback = function ( err ) {
            error = err ? error + err : error;
            counter.visits -= 1;
            if ( counter.visits === 0 ) {
                callback( error === '' ? undefined : error );
            }
        };

        containerData = self.getContainerData( rootNode, true );
        self.admData.RootContainer = containerData;
        self.visitAllChildrenRec( rootNode, counter, containerData, counterCallback );
    };

    AdmExporter.prototype.visitAllChildrenRec = function ( node, counter, containerData, callback ) {
        var self = this;
        self.core.loadChildren( node, function ( err, children ) {
            var i,
                atModelNodeCallback;
            if ( err ) {
                callback( 'loadChildren failed for ' + self.core.getAttribute( node, 'name' ) );
                return;
            }
            if ( children.length === 0 ) {
                callback( null );
            } else {
                counter.visits += children.length;
                counter.visits -= 1;
                atModelNodeCallback = function ( childNode ) {
                    return function ( err ) {
                        var subContainerData;
                        if ( err ) {
                            callback( err );
                            return;
                        }
                        if ( self.isMetaTypeOf( childNode, self.meta.Container ) && self.shouldBeGenerated(
                            childNode ) ) {
                            // If containerData is Alternative, then only add if childNode.id is in AA.
                            subContainerData = self.getContainerData( childNode );
                            containerData.Container.push( subContainerData );
                            self.visitAllChildrenRec( childNode, counter, subContainerData, callback );
                        } else {
                            callback( null );
                        }
                    };
                };
                for ( i = 0; i < children.length; i += 1 ) {
                    self.atModelNode( children[ i ], node, containerData, atModelNodeCallback( children[ i ] ) );
                }
            }
        } );
    };

    AdmExporter.prototype.getContainerData = function ( node, isRoot ) {
        var self = this,
            pos,
            containerData = {
                "@xmlns:q1": "avm",
                "@xsi:type": 'q1:' + self.core.getAttribute( node, 'Type' ),
                "@Name": self.core.getAttribute( node, 'name' ),
                "@xmlns": "",
                "Container": [],
                "Property": [],
                "ComponentInstance": [],
                "Port": [],
                "Connector": [],
                "JoinData": [],
                "Formula": [],
                "ValueFlowMux": []
            };

        if ( !isRoot ) {
            pos = self.getPositionUInt32( node );
            containerData[ "@XPosition" ] = pos.x;
            containerData[ "@YPosition" ] = pos.y;
        }

        return containerData;
    };

    AdmExporter.prototype.getConnectorData = function ( node, parent ) {
        var self = this,
            pos,
            parentType = self.core.getAttribute( self.getMetaType( parent ), 'name' ),
            data;

        if ( parentType === 'Container' ) {
            pos = self.getPositionUInt32( node );
            data = {
                "@Name": self.core.getAttribute( node, 'name' ),
                "@ID": self.core.getGuid( node ),
                "@ConnectorComposition": '',
                "@ApplyJoinData": '',
                "@Definition": '',
                "@XPosition": pos.x,
                "@YPosition": pos.y,
                "Role": []
            };
        } else if ( parentType === 'AVMComponentModel' ) {
            data = {
                "@ID": 'id-' + self.core.getGuid( parent ) + '-' + self.core.getAttribute( node, 'ID' ),
                "@IDinComponentModel": self.core.getAttribute( node, 'ID' ),
                "@ConnectorComposition": '',
                "@ApplyJoinData": ''
            };
        } else {
            self.logger.error( 'Unexpected parent-type, ' + parentType + ', of connector.' );
            data = {};
        }

        return data;
    };

    AdmExporter.prototype.getDomainPortData = function ( node, parent ) {
        var self = this,
            typeName = self.core.getAttribute( node, 'Type' ),
            domainNodeName = self.core.getAttribute( node, 'name' ),
            parentType = self.core.getAttribute( self.getMetaType( parent ), 'name' ),
            data,
            pos,
            attributes,
            attr;

        if ( parentType === 'Container' || parentType === 'Connector' ) {
            pos = self.getPositionUInt32( node );
            data = {
                '@ID': self.core.getGuid( node ),
                '@PortMap': '',
                '@Name': domainNodeName,
                '@Notes': '',
                '@Definition': '',
                "@XPosition": pos.x,
                "@YPosition": pos.y
            };
            if ( typeName === 'ModelicaConnector' ) {
                attributes = {
                    '@xmlns:q1': 'modelica',
                    '@xsi:type': 'q1:Connector',
                    '@Locator': domainNodeName,
                    '@Class': self.core.getAttribute( node, 'Class' )
                };
            } else if ( typeName === 'CadAxis' ) {
                attributes = {
                    '@xmlns:q1': 'cad',
                    '@xsi:type': 'q1:Axis',
                    '@DatumName': ''
                };
            } else if ( typeName === 'CadCoordinateSystem' ) {
                attributes = {
                    '@xmlns:q1': 'cad',
                    '@xsi:type': 'q1:CoordinateSystem',
                    '@DatumName': ''
                };
            } else if ( typeName === 'CadPlane' ) {
                attributes = {
                    '@xmlns:q1': 'cad',
                    '@xsi:type': 'q1:Plane',
                    '@DatumName': '',
                    '@SurfaceReverseMap': ''
                };
            } else if ( typeName === 'CadPoint' ) {
                attributes = {
                    '@xmlns:q1': 'cad',
                    '@xsi:type': 'q1:Point',
                    '@DatumName': ''
                };
            }
            for ( attr in attributes ) {
                if ( attributes.hasOwnProperty( attr ) ) {
                    data[ attr ] = attributes[ attr ];
                }
            }
        } else if ( parentType === 'AVMComponentModel' ) {
            data = {
                '@ID': 'id-' + self.core.getGuid( parent ) + '-' + self.core.getAttribute( node, 'ID' ),
                '@PortMap': '',
                '@IDinComponentModel': self.core.getAttribute( node, 'ID' )
            };
        } else {
            self.logger.error( 'Unexpected parent-type, ' + parentType + ', of domainPort.' );
            data = {};
        }

        return data;
    };

    AdmExporter.prototype.appendWhiteSpacedString = function ( toBeAppended, appendix ) {
        if ( appendix ) {
            if ( toBeAppended ) {
                toBeAppended += " " + appendix;
            } else {
                toBeAppended = appendix;
            }
        }
        return toBeAppended;
    };

    AdmExporter.prototype.nodeIsWithinDesign = function ( node ) {
        var self = this,
            path = self.core.getPath( node );
        if ( self.startsWith( path, self.rootPath ) ) {
            return true;
        }
        self.logger.info( 'Connection to node with path ' + path + ' will not be generated.' +
            'It is not part of the root-design' );
        return false;
    };

    AdmExporter.prototype.startsWith = function ( str, start ) {
        if ( start === '' ) {
            return true;
        }
        return start.length > 0 && str.substring( 0, start.length ) === start;
    };

    return AdmExporter;
} );
