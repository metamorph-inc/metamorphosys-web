/**
* Generated by PluginGenerator from webgme on Tue Apr 29 2014 17:05:39 GMT-0500 (Central Daylight Time).
*/

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'plugin/AdmExporter/AdmExporter/meta',
    'xmljsonconverter',
    'plugin/AdmExporter/AdmExporter/Templates/Templates',
    'ejs'], function (PluginConfig, PluginBase, MetaTypes, Converter, TEMPLATES, ejs) {
    'use strict';

    /**
    * Initializes a new instance of AdmExporter.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin AdmExporter.
    * @constructor
    */
    var AdmExporter = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.meta = null;
        this.admData = {
            "@xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
            "@xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
            "@DesignID": '',
            "@Name": '',
            "@xmlns": "avm",
            "RootContainer": null
        };

        this.acmFiles = {};
        this.gatheredAcms = {};
        this.includeAcms = true;
        // No value flows or connector-compositions beyond the root-container
        // should be reported in the adm file.
        this.rootPath = null;
    };

    // Prototypal inheritance from PluginBase.
    AdmExporter.prototype = Object.create(PluginBase.prototype);
    AdmExporter.prototype.constructor = AdmExporter;

    /**
    * Gets the name of the AdmExporter.
    * @returns {string} The name of the plugin.
    * @public
    */
    AdmExporter.prototype.getName = function () {
        return "ADM Exporter";
    };

    /**
    * Gets the semantic version (semver.org) of the AdmExporter.
    * @returns {string} The version of the plugin.
    * @public
    */
    AdmExporter.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Gets the description of the AdmExporter.
    * @returns {string} The description of the plugin.
    * @public
    */
    AdmExporter.prototype.getDescription = function () {
        return "Exports a design into an adm.";
    };

    /**
    * Gets the configuration structure for the AdmExporter.
    * The ConfigurationStructure defines the configuration for the plugin
    * and will be used to populate the GUI when invoking the plugin from webGME.
    * @returns {object} The version of the plugin.
    * @public
    */
    AdmExporter.prototype.getConfigStructure = function () {
        return [
            {
                'name': 'acms',
                'displayName': 'Include ACMs',
                'description': 'Bundles all encountered ACMs within the package and creates scripts for importing the '
                    + 'design into desktop GME.',
                'value': false,
                'valueType': 'boolean',
                'readOnly': false
            }
        ];
    };


    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always has to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    AdmExporter.prototype.main = function (callback) {
        var self = this,
            timeStart = new Date().getTime(),
            jsonToXml = new Converter.Json2xml(),
            config = self.getCurrentConfig(),
            finishAndSaveArtifact,
            createArtifacts;
        if (!self.activeNode) {
            self.createMessage(null, 'Active node is not present! This happens sometimes... Loading another model ' +
                'and trying again will solve it most of times.');
            return callback('Active node is not present!', self.result);
        }
        if (self.isMetaTypeOf(self.activeNode, self.META.Container) === false) {
            self.createMessage(null, 'This plugin must be called from a Container.');
            return callback(null, self.result);
        }
        self.meta = MetaTypes;
        self.updateMETA(self.meta);
        finishAndSaveArtifact = function (artifact) {
            artifact.save(function (err, hash) {
                if (err) {
                    self.result.setSuccess(false);
                    return callback('Could not save artifact : err' + err.toString(), self.result);
                }
                self.createMessage(null, 'ExecTime [s] total :: ' +
                    ((new Date().getTime() - timeStart) / 1000).toString());
                self.result.addArtifact(hash);
                self.result.setSuccess(true);
                callback(null, self.result);
            });
        };

        createArtifacts = function (err) {
            var artifact,
                admXmlStr;
            if (err) {
                return callback(err, self.result);
            }
            artifact = self.blobClient.createArtifact('design');
            admXmlStr = jsonToXml.convertToString({Design: self.admData});

            artifact.addFile(self.admData['@Name'] + '.adm', admXmlStr, function (err, hash) {
                if (err) {
                    self.result.setSuccess(false);
                    return callback('Could not add adm file : err' + err.toString(), self.result);
                }
                self.logger.info('ADM hash: ' + hash);
                if (self.includeAcms) {
                    artifact.addObjectHashes(self.acmFiles, function (err, hashes) {
                        if (err) {
                            self.result.setSuccess(false);
                            return callback('Could not add acm files : err' + err.toString(), self.result);
                        }
                        self.logger.info('ACM hashes: ' + hashes.toString());
                        artifact.addFiles({
                            'execute.py': ejs.render(TEMPLATES['execute.py.ejs']),
                            'run_execution.cmd': ejs.render(TEMPLATES['run_execution.cmd.ejs']),
                            'empty.xme': ejs.render(TEMPLATES['empty.xme.ejs']),
                            'executor_config.json': JSON.stringify({
                                cmd: 'run_execution.cmd',
                                files: [],
                                dirs: []
                            }, null, 4)
                        }, function (err, hashes) {
                            if (err) {
                                return callback('Could not script files : err' + err.toString(), self.result);
                            }
                            self.logger.info('Script hashes: ' + hashes.toString());
                            finishAndSaveArtifact(artifact);
                        });
                    });
                } else {
                    finishAndSaveArtifact(artifact);
                }
            });
        };

        self.exploreDesign(self.activeNode, config.acms, createArtifacts);
    };

    AdmExporter.prototype.exploreDesign = function (startNode, includeACMs, callback) {
        var self = this,
            designName = self.core.getAttribute(startNode, 'name');
        self.includeAcms = includeACMs;
        self.admData['@Name'] = designName;
        self.admData['@DesignID'] = self.core.getGuid(startNode);
        self.rootPath = self.core.getPath(startNode);
        self.logger.info('rootPath is ' + self.rootPath);
        self.visitAllChildrenFromRootContainer(startNode, callback);
    };

    AdmExporter.prototype.atModelNode = function (node, parent, containerData, callback) {
        var self = this,
            nodeType = self.core.getAttribute(self.getMetaType(node), 'name'),
            nodeName = self.core.getAttribute(node, 'name'),
            parentName = self.core.getAttribute(parent, 'name');

        self.logger.info('At node "' + nodeName + '" of type "' + nodeType + '" with parent "' + parentName + '".');

        if (nodeType === 'AVMComponentModel') {
            self.addComponentInstance(node, parent, containerData, callback);
        } else if (nodeType === 'Connector') {
            self.addConnector(node, parent, containerData, callback);
        } else if (nodeType === 'Property') {
            self.addProperty(node, parent, containerData, callback);
        } else if (nodeType === 'SimpleFormula') {
            self.addFormula(node, parent, containerData, true, callback);
        } else if (nodeType === 'CustomFormula') {
            self.addFormula(node, parent, containerData, false, callback);
        } else {
            callback(null);
        }
    };

    AdmExporter.prototype.addComponentInstance = function (node, parent, containerData, callback) {
        var self = this,
            pos = self.core.getRegistry(node, 'position'),
            nodeName = self.core.getAttribute(node, 'name'),
            acmHash,
            componentID = self.core.getAttribute(node, 'ID'),
            data = {
                "@Name": nodeName,
                "@ComponentID": componentID,
                "@ID": self.core.getGuid(node),
                "@XPosition": Math.floor(pos.x),
                "@YPosition": Math.floor(pos.y),
                "PortInstance": [],
                "PrimitivePropertyInstance": [],
                "ConnectorInstance": []
            };

        if (containerData.TopLevelSystemUnderTest === undefined) {
            containerData.ComponentInstance.push(data);
        } else {
            containerData.TestComponent.push(data);
        }

        if (self.includeAcms) {
            acmHash = self.core.getAttribute(node, 'Resource');
            if (acmHash) {
                if (self.gatheredAcms[acmHash]) {
                    self.logger.info('ACM of "' + nodeName + '" used twice. Not adding again..');
                } else {
                    self.acmFiles['ACMs/' + nodeName + '__' + componentID.replace(/[^\w]/gi, '_') + '.zip'] = acmHash;
                    self.gatheredAcms[acmHash] = true;
                }
            } else {
                self.logger.error('ACM was not specified for ' + nodeName);
                return callback('ACM was not specified for ' + nodeName);
            }
        }
        self.core.loadChildren(node, function (err, children) {
            var i,
                error = '',
                counter,
                counterCallback;
            if (err) {
                return callback('loadChildren failed for ' + nodeName + ' :' + err.toString());
            }

            counterCallback = function (err) {
                error = err ? error + err : error;
                counter -= 1;
                if (counter <= 0) {
                    callback(error);
                }
            };

            if (children.length === 0) {
                return counterCallback(null);
            }

            counter = children.length;

            for (i = 0; i < children.length; i += 1) {
                if (self.isMetaTypeOf(children[i], self.meta.Connector)) {
                    self.addConnector(children[i], node, data, counterCallback);
                } else if (self.isMetaTypeOf(children[i], self.meta.Property)) {
                    self.addProperty(children[i], node, data, counterCallback);
                } else {
                    counterCallback(null);
                }
            }
        });
    };

    AdmExporter.prototype.addConnector = function (node, parent, containerData, callback) {
        var self = this,
            pos,
            parentType = self.core.getAttribute(self.getMetaType(parent), 'name'),
            data,
            collectionNames =  self.core.getCollectionNames(node),
            counter = 2,
            error = '',
            counterCallback = function (err) {
                error = err ? error + err : error;
                counter -= 1;
                if (counter === 0) {
                    callback(error);
                }
            };
        if (parentType === 'Container') {
            pos = self.core.getRegistry(node, 'position');
            data = {
                "@Name": self.core.getAttribute(node, 'name'),
                "@ID": self.core.getGuid(node),
                "@ConnectorComposition": '',
                "@ApplyJoinData": '',
                "@Definition": '',
                "@XPosition": Math.floor(pos.x),
                "@YPosition": Math.floor(pos.y),
                "Role": []
            };
            containerData.Connector.push(data);
        } else {
            // This is a connector instance of a component.
            data = {
                "@ID": '{' + self.core.getGuid(parent) + '}-' + self.core.getAttribute(node, 'ID'),
                "@IDinComponentModel": self.core.getAttribute(node, 'ID'),
                "@ConnectorComposition": '',
                "@ApplyJoinData": ''
            };
            containerData.ConnectorInstance.push(data);
        }

        self.addDomainConnectors(node, data, function (err) {
            if (err) {
                return callback(err);
            }
            if (collectionNames.indexOf('src') > -1) {
                self.getConnectorCompositionID(node, 'src', function (err, dstId) {
                    if (err) {
                        return counterCallback(err);
                    }
                    data['@ConnectorComposition'] = self.appendWhiteSpacedString(data['@ConnectorComposition'], dstId);
                    counterCallback(null);
                });
            } else {
                counterCallback(null);
            }
            if (collectionNames.indexOf('dst') > -1) {
                self.getConnectorCompositionID(node, 'dst', function (err, srcId) {
                    if (err) {
                        return counterCallback(err);
                    }
                    data['@ConnectorComposition'] = self.appendWhiteSpacedString(data['@ConnectorComposition'], srcId);
                    counterCallback(null);
                });
            } else {
                counterCallback(null);
            }
        });
    };

    AdmExporter.prototype.addDomainConnectors = function (connectorNode, data, callback) {
        var self = this,
            domainConnectors = data.Role,
            nodeName;

        if (domainConnectors === undefined) {
            // This a connector within an ACM..
            return callback(null);
        }

        nodeName = self.core.getAttribute(connectorNode, 'name');
        self.core.loadChildren(connectorNode, function (err, children) {
            var i,
                typeName,
                domainNodeName;
            if (err) {
                return callback('loadChildren failed for connector ' + nodeName + ' :' + err.toString());
            }
            for (i = 0; i < children.length; i += 1) {
                typeName = self.core.getAttribute(children[i], 'Type');
                domainNodeName = self.core.getAttribute(children[i], 'name');
                if (typeName === 'ModelicaConnector') {
                    domainConnectors.push({
                        '@xmlns:q1': 'modelica',
                        '@xsi:type': 'q1:Connector',
                        '@ID': self.core.getGuid(children[i]),
                        '@PortMap': '',
                        '@Name': domainNodeName,
                        '@Notes': '',
                        '@Definition': '',
                        '@Locator': domainNodeName,
                        '@Class': self.core.getAttribute(children[i], 'Class')
                    });
                } else if (typeName === 'CadAxis') {
                    domainConnectors.push({
                        '@xmlns:q1': 'cad',
                        '@xsi:type': 'q1:Axis',
                        '@ID': self.core.getGuid(children[i]),
                        '@PortMap': '',
                        '@Name': domainNodeName,
                        '@Notes': '',
                        '@Definition': '',
                        '@DatumName': ''
                    });
                } else if (typeName === 'CadCoordinateSystem') {
                    domainConnectors.push({
                        '@xmlns:q1': 'cad',
                        '@xsi:type': 'q1:CoordinateSystem',
                        '@ID': self.core.getGuid(children[i]),
                        '@PortMap': '',
                        '@Name': domainNodeName,
                        '@Notes': '',
                        '@Definition': '',
                        '@DatumName': ''
                    });
                } else if (typeName === 'CadPlane') {
                    domainConnectors.push({
                        '@xmlns:q1': 'cad',
                        '@xsi:type': 'q1:Plane',
                        '@ID': self.core.getGuid(children[i]),
                        '@PortMap': '',
                        '@Name': domainNodeName,
                        '@Notes': '',
                        '@Definition': '',
                        '@DatumName': '',
                        '@SurfaceReverseMap': ''
                    });
                } else if (typeName === 'CadPoint') {
                    domainConnectors.push({
                        '@xmlns:q1': 'cad',
                        '@xsi:type': 'q1:Point',
                        '@ID': self.core.getGuid(children[i]),
                        '@PortMap': '',
                        '@Name': domainNodeName,
                        '@Notes': '',
                        '@Definition': '',
                        '@DatumName': ''
                    });
                }
            }

            callback(null);
        });
    };

    AdmExporter.prototype.getConnectorCompositionID = function (connectorNode, collectionName, callback) {
        var self = this,
            pointerName = collectionName === 'src' ? 'dst' : 'src';

        self.core.loadCollection(connectorNode, collectionName, function (err, connections) {
            var counter, i,
                counterCallback,
                error = '',
                connectedIDs = '';
            if (err) {
                return callback(err);
            }
            counterCallback = function (err, connectedID) {
                if (err) {
                    error += err;
                } else {
                    connectedIDs = self.appendWhiteSpacedString(connectedIDs, connectedID);
                }
                counter -= 1;
                if (counter <= 0) {
                    callback(error, connectedIDs);
                }
            };
            counter = connections.length;
            if (connections.length === 0) {
                return counterCallback(null, '');
            }
            for (i = 0; i < connections.length; i += 1) {
                self.getConnectedPortID(connections[i], pointerName, counterCallback);
            }
        });
    };

    AdmExporter.prototype.getConnectedPortID = function (connectionNode, pointerName, callback) {
        var self = this,
            hasPointer = self.core.hasPointer(connectionNode, pointerName);

        if (hasPointer) {
            self.core.loadPointer(connectionNode, pointerName, function (err, connectedPort) {
                var id = '',
                    parent,
                    parentMetaType;
                if (err) {
                    return callback(err);
                }
                if (self.nodeIsWithinDesign(connectedPort)) {
                    parent = self.core.getParent(connectedPort);
                    parentMetaType = self.core.getAttribute(self.getMetaType(parent), 'name');
                    if (parentMetaType === 'AVMComponentModel') {
                        id = '{' + self.core.getGuid(parent) + '}-' + self.core.getAttribute(connectedPort, 'ID');
                    } else {
                        id = self.core.getGuid(connectedPort);
                    }
                }
                callback(null, id);
            });
        } else {
            self.createMessage(connectionNode, 'Connection with no src/dst exists in design.');
            callback('A connectorComposition with only one direction pointer exists in model.');
        }
    };

    AdmExporter.prototype.addProperty = function (node, parent, containerData, callback) {
        var self = this,
            pos = self.core.getRegistry(node, 'position'),
            parentType = self.core.getAttribute(self.getMetaType(parent), 'name'),
            collectionNames = self.core.getCollectionNames(node),
            valueType = self.core.getAttribute(node, 'ValueType'),
            dataType = self.core.getAttribute(node, 'DataType'),
            unit,
            data,
            value,
            id,
            addPropertyData;

        addPropertyData = function (valueSourceID) {
            if (parentType === 'Container') {
                id = self.core.getGuid(node);
                data = {
                    "@xsi:type": "q1:PrimitiveProperty",
                    "@Name": self.core.getAttribute(node, 'name'),
                    "@ID": null,
                    "@XPosition": Math.floor(pos.x),
                    "@YPosition": Math.floor(pos.y),
                    "Value": {
                        "@ID": id,
                        "@DimensionType": "Scalar",
                        "@Dimensions": "",
                        "@DataType": dataType,
                        "ValueExpression": null
                    }
                };
                unit = self.core.getAttribute(node, 'Unit');
                if (unit) {
                    data.Value['@Unit'] = unit;
                }
                value = self.core.getAttribute(node, 'Value') || '';
                if (valueType === 'Parametric') {
                    data['@ID'] = 'param.' + id;
                    data.Value.ValueExpression = {
                        "@xsi:type": "q1:" + valueType + "Value",
                        "Default": {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": self.core.getAttribute(node, 'Default') || ''
                            }
                        },
                        "Maximum": {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": self.core.getAttribute(node, 'Maximum') || ''
                            }
                        },
                        "Minimum": {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": self.core.getAttribute(node, 'Minimum') || ''
                            }
                        },
                        "AssignedValue": null
                    };
                    if (valueSourceID) {
                        data.Value.ValueExpression.AssignedValue = {
                            "@xsi:type": "q1:DerivedValue",
                            "@ValueSource": valueSourceID
                        };
                    } else {
                        data.Value.ValueExpression.AssignedValue = {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": value
                            }
                        };
                    }
                } else {
                    data['@ID'] = 'property.' + id;
                    if (valueSourceID) {
                        data.Value.ValueExpression = {
                            "@xsi:type": "q1:DerivedValue",
                            "@ValueSource": valueSourceID
                        };
                    } else {
                        data.Value.ValueExpression = {
                            "@xsi:type": "q1:FixedValue",
                            "Value": {
                                "#text": value
                            }
                        };
                    }
                }
                containerData.Property.push(data);
            } else {
                id = self.core.getAttribute(node, 'ID');
                data = {
                    "@IDinComponentModel": id,
                    "Value": {
                        "@ID": '{' + self.core.getGuid(parent) + '}-' + id,
                        "@DimensionType": "Scalar",
                        "@Dimensions": "",
                        "@DataType": dataType
                    }
                };
                if (valueSourceID) {
                    data.Value.ValueExpression = {
                        "@xsi:type": "q1:DerivedValue",
                        "@ValueSource": valueSourceID
                    };
                }
                containerData.PrimitivePropertyInstance.push(data);
            }

            callback(null);
        };
        if (collectionNames.indexOf('dst') < 0) {
            addPropertyData(null);
        } else {
            self.core.loadCollection(node, 'dst', function (err, valueFlows) {
                if (err) {
                    return callback('Could not load collection for ' + self.core.getAttribute(node, 'name') +
                        'err: ' + err.toString());
                }
                if (valueFlows.length > 1) {
                    self.createMessage(node, self.core.getAttribute(node, 'name') + ' had more than one incoming value');
                    return callback(null);
                }
                if (!self.core.hasPointer(valueFlows[0], 'src')) {
                    self.createMessage(valueFlows[0], 'ValueFlow Connection with no src exists in design.');
                    return callback('A valueFlow with only one direction pointer exists in model.');
                }
                self.core.loadPointer(valueFlows[0], 'src', function (err, valueSourceNode) {
                    var vsId,
                        vsParent,
                        parentMetaType;
                    if (err) {
                        return callback('Could not load src pointer for ' + self.core.getAttribute(valueFlows[0], 'name')
                            + 'err: ' + err.toString());
                    }
                    if (self.nodeIsWithinDesign(valueSourceNode)) {
                        vsParent = self.core.getParent(valueSourceNode);
                        parentMetaType = self.core.getAttribute(self.getMetaType(vsParent), 'name');
                        if (parentMetaType === 'AVMComponentModel') {
                            if (parentType === 'AVMComponentModel' && self.core.getPath(vsParent) === self.core.getPath(parent)) {
                                self.logger.info('Skipping connection within same ACM : ' +
                                    self.core.getAttribute(node, 'name'));
                            } else {
                                vsId = '{' + self.core.getGuid(vsParent) + '}-' + self.core.getAttribute(valueSourceNode, 'ID');
                            }
                        } else {
                            vsId = self.core.getGuid(valueSourceNode);
                        }
                    }
                    addPropertyData(vsId);
                });
            });
        }
    };

    AdmExporter.prototype.addFormula = function (node, parent, containerData, isSimple, callback) {
        var self = this,
            pos = self.core.getRegistry(node, 'position'),
            collectionNames = self.core.getCollectionNames(node),
            formulaName = self.core.getAttribute(node, 'name'),
            data,
            id = self.core.getGuid(node),
            addFormulaData;
        self.logger.info('At formula "' + formulaName + '".');
        addFormulaData = function (operands, error) {
            var i;
            if (isSimple) {
                data = {
                    "@xmlns:q1": "avm",
                    "@xmlns": "",
                    "@xsi:type": "q1:SimpleFormula",
                    "@ID": id,
                    "@Name": formulaName,
                    "@XPosition": Math.floor(pos.x),
                    "@YPosition": Math.floor(pos.y),
                    "@Operation": self.core.getAttribute(node, 'Method'),
                    "@Operand": ''
                };
                for (i = 0; i < operands.length; i += 1) {
                    data["@Operand"] = self.appendWhiteSpacedString(data["@Operand"], operands[i].id);
                }
            } else {
                data = {
                    "@xmlns:q1": "avm",
                    "@xmlns": "",
                    "@xsi:type": "q1:ComplexFormula",
                    "@ID": id,
                    "@Name": formulaName,
                    "@XPosition": Math.floor(pos.x),
                    "@YPosition": Math.floor(pos.y),
                    "@Expression": self.core.getAttribute(node, 'Expression'),
                    "Operand": []
                };
                for (i = 0; i < operands.length; i += 1) {
                    data.Operand.push({
                        "@Symbol": operands[i].symbol,
                        "@ValueSource": operands[i].id
                    });
                }
            }
            containerData.Formula.push(data);
            callback(error);
        };

        if (collectionNames.indexOf('dst') < 0) {
            addFormulaData(null);
        } else {
            self.core.loadCollection(node, 'dst', function (err, valueFlows) {
                var counter = valueFlows.length,
                    i,
                    error = '',
                    operands = [],
                    counterCallback;
                if (err) {
                    return callback('Could not load collection for ' + formulaName + 'err: ' + err.toString());
                }
                counter = valueFlows.length;
                counterCallback = function (valueFlow) {

                    return function (err, valueSource) {
                        var symbol,
                            id,
                            parent,
                            parentMetaType;

                        if (err) {
                            error += err;
                        } else {
                            parent = self.core.getParent(valueSource);
                            parentMetaType = self.core.getAttribute(self.getMetaType(parent), 'name');
                            if (parentMetaType === 'AVMComponentModel') {
                                id = '{' + self.core.getGuid(parent) + '}-' + self.core.getAttribute(valueSource, 'ID');
                            } else {
                                id = self.core.getGuid(valueSource);
                            }

                            if (!isSimple) {
                                symbol = self.core.getAttribute(valueFlow, 'VariableName');
                                if (!symbol) {
                                    symbol = self.core.getAttribute(valueSource, 'name');
                                }
                            }

                            operands.push({
                                symbol: symbol,
                                id: id
                            });
                        }
                        counter -= 1;
                        if (counter <= 0) {
                            addFormulaData(operands, error);
                        }
                    };
                };
                if (counter === 0) {
                    self.logger.warning('Formula "' + formulaName + '" did not have any incoming value flows.');
                    addFormulaData([], error);
                }
                for (i = 0; i < valueFlows.length; i += 1) {
                    self.core.loadPointer(valueFlows[i], 'src', counterCallback(valueFlows[i]));
                }
            });
        }
    };

    AdmExporter.prototype.visitAllChildrenFromRootContainer = function (rootNode, callback) {
        var self = this,
            error = '',
            counter,
            counterCallback,
            containerData;

        counter = {visits: 1};
        counterCallback = function (err) {
            error = err ? error + err : error;
            counter.visits -= 1;
            if (counter.visits === 0) {
                callback(error);
            }
        };

        containerData = self.getContainerData(rootNode, true);
        self.admData.RootContainer = containerData;
        self.visitAllChildrenRec(rootNode, counter, containerData, counterCallback);
    };

    AdmExporter.prototype.visitAllChildrenRec = function (node, counter, containerData, callback) {
        var self = this;
        self.core.loadChildren(node, function (err, children) {
            var i,
                atModelNodeCallback;
            if (err) {
                return callback('loadChildren failed for ' + self.core.getAttribute(node, 'name'));
            }
            counter.visits += children.length;
            if (children.length === 0) {
                callback(null);
            } else {
                counter.visits -= 1;
                atModelNodeCallback = function (childNode) {
                    return function (err) {
                        var subContainerData;
                        if (err) {
                            callback(err);
                        }
                        if (self.isMetaTypeOf(childNode, self.meta.Container)) {
                            subContainerData = self.getContainerData(childNode);
                            containerData.Container.push(subContainerData);
                            self.visitAllChildrenRec(childNode, counter, subContainerData, callback);
                        } else {
                            callback(null);
                        }
                    };
                };
                for (i = 0; i < children.length; i += 1) {
                    self.atModelNode(children[i], node, containerData, atModelNodeCallback(children[i]));
                }
            }
        });
    };

    AdmExporter.prototype.getContainerData = function (node, isRoot) {
        var self = this,
            pos,
            containerData = {
                "@xmlns:q1": "avm",
                "@xsi:type": 'q1:' + self.core.getAttribute(node, 'Type'),
                "@Name": self.core.getAttribute(node, 'name'),
                "@xmlns": "",
                "Container": [],
                "Property": [],
                "ComponentInstance": [],
                "Port": [],
                "Connector": [],
                "JoinData": [],
                "Formula": []
            };

        if (!isRoot) {
            pos = self.core.getRegistry(node, 'position');
            containerData["@XPosition"] = Math.floor(pos.x);
            containerData["@YPosition"] = Math.floor(pos.y);
        }

        return containerData;
    };

    AdmExporter.prototype.appendWhiteSpacedString = function (toBeAppended, appendix) {
        if (appendix) {
            if (toBeAppended) {
                toBeAppended += " " + appendix;
            } else {
                toBeAppended = appendix;
            }
        }
        return toBeAppended;
    };

    AdmExporter.prototype.nodeIsWithinDesign = function (node) {
        var self = this,
            path = self.core.getPath(node);
        if (self.startsWith(path, self.rootPath)) {
            return true;
        }
        self.logger.info('Connection to node with path ' + path + ' will not be generated.' +
            'It is not part of the root-design');
        return false;
    };

    AdmExporter.prototype.startsWith = function (str, start) {
        if (start === '') {
            return true;
        }
        return start.length > 0 && str.substring(0, start.length) === start;
    };

    return AdmExporter;
});