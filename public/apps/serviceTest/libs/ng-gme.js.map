{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/library/ng-gme.js","src/library/directives/gmeDirectives.js","src/library/directives/projectBrowser/projectBrowser.js","src/library/directives/termFilter/termFilter.js","src/library/services/BranchService.js","src/library/services/DataStoreService.js","src/library/services/NodeService.js","src/library/services/ProjectService/ProjectService.js","src/library/services/gmeServices.js","src/library/services/gmeTestServices.js","src/library/services/tests/ProjectServiceTest.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ng-gme.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nrequire( './services/gmeServices.js' );\nrequire( './services/gmeTestServices.js' );\nrequire( './directives/gmeDirectives.js' );","/*globals angular*/\n'use strict';\n\nrequire( './projectBrowser/projectBrowser.js' );\n\nangular.module( 'gme.directives', [\n    'gme.templates',\n    'gme.directives.projectBrowser'\n] );","/*globals angular, chance*/\n'use strict';\n\nrequire( '../termFilter/termFilter.js' );\n\nangular.module( 'gme.directives.projectBrowser', [\n    'gme.templates',\n    'isis.ui.itemList',\n    'isis.ui.simpleDialog',\n    'gme.directives.termFilter',\n    'ngTagsInput',\n    'gme.testServices',\n    'isis.ui.valueWidgets'\n] )\n    .run( function () {\n\n    } )\n    .controller( 'ProjectBrowserController',\n        function ( $scope, $log, $filter, projectServiceTest, projectService, $simpleDialog ) {\n\n            var config,\n                dummyProjectGenerator,\n\n                projectDescriptorMapper,\n\n                filterItems,\n                projectList,\n                availableTerms,\n                databaseId,\n\n                updateProjectList;\n\n            databaseId = 'multi';\n\n            availableTerms = $scope.availableTerms = [];\n\n            //  availableTerms = $scope.availableTerms = [\n            //    {\n            //      id: 'tag1',\n            //      name: 'Tag A',\n            //      url: 'http://vanderbilt.edu'\n            //    },\n            //    {\n            //      id: 'tag2',\n            //      name: 'Tag B',\n            //      url: 'http://vanderbilt.edu'\n            //    },\n            //    {\n            //      id: 'tag3',\n            //      name: 'Tag C',\n            //      url: 'http://vanderbilt.edu'\n            //    },\n            //    {\n            //      id: 'tag4',\n            //      name: 'Tag D',\n            //      url: 'http://vanderbilt.edu'\n            //    },\n            //    {\n            //      id: 'tag5',\n            //      name: 'Tag E',\n            //      url: 'http://vanderbilt.edu'\n            //    },\n            //    {\n            //      id: 'tag6',\n            //      name: 'Tag F',\n            //      url: 'http://vanderbilt.edu'\n            //    }\n            //  ];\n\n\n            $scope.filtering = {\n                selectedTermIds: [\n\n                ]\n            };\n\n            projectList = $scope.projectList = {\n                items: []\n            };\n\n            $scope.filteredProjectList = {\n                items: []\n            };\n\n\n            filterItems = function () {\n                $scope.filteredProjectList.items = $filter( 'termFilter' )( $scope.projectList.items,\n                    $scope.filtering.selectedTermIds );\n            };\n\n            $scope.$watch( function () {\n\n                    return $scope.filtering.selectedTermIds;\n                }, function () {\n                    filterItems();\n                },\n                true );\n\n\n            $scope.$watch( 'filtering.selectedTermIds', function () {\n                filterItems();\n            } );\n\n            $scope.$watch( 'projectList.items', function () {\n                filterItems();\n            } );\n\n            dummyProjectGenerator = function ( id ) {\n\n                var projectDescriptor, i;\n\n                projectDescriptor = {\n                    id: id,\n                    title: chance.paragraph( {\n                        sentences: 1\n                    } ),\n                    cssClass: 'project-item',\n                    toolTip: 'Open project',\n                    description: chance.paragraph( {\n                        sentences: 2\n                    } ),\n                    lastUpdated: {\n                        time: Date.now(),\n                        user: 'N/A'\n\n                    },\n                    taxonomyTerms: [],\n                    stats: [ {\n                        value: id,\n                        toolTip: 'Commits',\n                        iconClass: 'fa fa-cloud-upload'\n                    }, {\n                        value: id,\n                        toolTip: 'Users',\n                        iconClass: 'fa fa-users'\n                    } ],\n                    details: chance.paragraph( {\n                        sentences: 3\n                    } )\n                };\n\n                for ( i = 0; i < $scope.availableTerms.length - 1; i++ ) {\n\n                    if ( Math.random() > 0.5 ) {\n                        projectDescriptor.taxonomyTerms.push( $scope.availableTerms[ i ] );\n                    }\n                }\n\n                return projectDescriptor;\n\n            };\n\n            //  for (i = 0; i < 20; i++) {\n            //    $scope.projectList.items.push(dummyProjectGenerator(i));\n            //  }\n\n            projectDescriptorMapper = function ( projectDescriptors ) {\n\n                var result = [];\n\n                angular.forEach( projectDescriptors, function ( projectDescriptor ) {\n\n                    //console.log( projectDescriptor );\n\n                    result.push( {\n\n                        id: projectDescriptor.id,\n                        description: projectDescriptor.info.description,\n                        title: projectDescriptor.info.visibleName,\n                        taxonomyTerms: projectDescriptor.info.tags\n\n                    } );\n\n                } );\n\n                return result;\n\n            };\n\n            updateProjectList = function () {\n\n                projectService.getAvailableProjectTags( databaseId )\n                    .then( function ( tagList ) {\n\n                        $scope.availableTerms = tagList;\n\n                    } );\n\n                console.log( 'In here...' );\n\n                projectService.getProjects( databaseId )\n                    .then( function ( gmeProjectDescriptors ) {\n\n                        $scope.projectList.items = [];\n                        $scope.projectList.items = projectDescriptorMapper( gmeProjectDescriptors );\n\n                        //$scope.projectList.items = results;\n                    } );\n\n            };\n\n\n            // Making sure we have test project in DB\n\n            projectServiceTest.startTest()\n                .then( function () {\n                    updateProjectList();\n                } );\n\n            $scope.config = config = {\n\n                sortable: true,\n                secondaryItemMenu: true,\n                detailsCollapsible: true,\n                showDetailsLabel: 'Show details',\n                hideDetailsLabel: 'Hide details',\n                filter: {},\n\n                // Event handlers\n\n                itemSort: function ( jQEvent, ui ) {\n                    console.log( 'Sort happened', jQEvent, ui );\n                },\n\n                itemClick: function ( event, item ) {\n                    console.log( 'Clicked: ' + item );\n                },\n\n                itemContextmenuRenderer: function ( e, item ) {\n                    console.log( 'Contextmenu was triggered for node:', item );\n\n                    return [ {\n                        items: [\n\n                            {\n                                id: 'open',\n                                label: 'Open Project',\n                                disabled: false,\n                                iconClass: '',\n                                action: function () {\n                                    projectService.selectProject( databaseId, item.id );\n                                }\n\n                            }\n                        ]\n                    }, {\n                        items: [ {\n                            id: 'edit',\n                            label: 'Edit Project Details',\n                            disabled: false,\n                            iconClass: '',\n                            action: function () {\n                                $simpleDialog.open( {\n                                    dialogTitle: 'Edit project details',\n                                    dialogContentTemplate: '/ng-gme/templates/newProjectTemplate.html',\n                                    onOk: function () {\n\n\n                                    },\n                                    onCancel: function () {\n                                        console.log( 'This was canceled' );\n                                    },\n                                    size: 'lg', // can be sm or lg\n                                    scope: false\n                                } );\n\n                            }\n                        }, {\n                            id: 'delete',\n                            label: 'Delete Project',\n                            disabled: false,\n                            action: function () {\n                                $simpleDialog.open( {\n                                    dialogTitle: 'Are you sure?',\n                                    dialogContentTemplate: '/ng-gme/templates/confirmProjectDelete.html',\n                                    onOk: function () {\n\n                                        projectService.deleteProject( databaseId, item.id )\n                                            .then( function () {\n                                                updateProjectList();\n                                            } );\n\n                                    },\n                                    onCancel: function () {\n                                        console.log( 'This was canceled' );\n                                    },\n                                    size: 'lg', // can be sm or lg\n                                    scope: false\n                                } );\n\n                            },\n                            iconClass: ''\n                        } ]\n                    } ];\n                },\n\n                detailsRenderer: function ( item ) {\n                    item.details = 'My details are here now!';\n                },\n\n                newItemForm: {\n                    title: 'Create new Project',\n                    itemTemplateUrl: '/ng-gme/templates/newProjectTemplate.html',\n                    expanded: false,\n                    controller: function ( $scope, projectService ) {\n\n                        $scope.newItem = {};\n\n                        $scope.tags = angular.copy( availableTerms );\n\n                        $scope.loadTags = function ( /*query*/) {\n                            return projectService.getAvailableProjectTags( databaseId );\n                        };\n\n                        $scope.createItem = function ( newItem ) {\n\n                            var tags;\n\n                            tags = {};\n\n                            angular.forEach( newItem.tags, function ( tag ) {\n                                tags[ tag.id ] = tag.name;\n                            } );\n\n                            projectService.createProject(\n                                databaseId,\n                                newItem.title, {\n                                    visibleName: newItem.title,\n                                    tags: tags,\n                                    description: newItem.description\n                                }\n                            )\n                                .then( function () {\n                                    updateProjectList();\n                                } );\n\n                            $scope.newItem = {};\n\n                            config.newItemForm.expanded = false; // this is how you close the form itself\n\n                        };\n\n                    }\n                }\n\n            };\n\n\n        } )\n    .directive( 'projectBrowser', function () {\n\n        return {\n            scope: false,\n            restrict: 'E',\n            controller: 'ProjectBrowserController',\n            replace: true,\n            templateUrl: '/ng-gme/templates/projectBrowser.html'\n        };\n    } );","/*globals angular*/\n'use strict';\n\nangular.module(\n    'gme.directives.termFilter', [\n        'isis.ui.taxonomyTerm'\n    ]\n\n)\n    .filter( 'isSelected', [\n\n        function () {\n            return function ( input, selectedTermIds, direction ) {\n                var output = [];\n\n                angular.forEach( input, function ( term ) {\n\n                    if ( direction === -1 ) {\n\n                        if ( selectedTermIds.indexOf( term.id ) === -1 ) {\n                            output.push( term );\n                        }\n\n                    } else {\n\n                        if ( selectedTermIds.indexOf( term.id ) > -1 ) {\n                            output.push( term );\n                        }\n\n                    }\n                } );\n\n                return output;\n\n            };\n        }\n    ] )\n    .filter( 'termFilter', function () {\n        return function ( input, selectedTermIds ) {\n\n            var output = [],\n                countOfTermHits;\n\n            if ( angular.isArray( selectedTermIds ) && selectedTermIds.length ) {\n\n                angular.forEach( input, function ( elem ) {\n\n                    countOfTermHits = 0;\n\n                    angular.forEach( elem.taxonomyTerms, function ( aTerm ) {\n\n                        countOfTermHits = countOfTermHits && countOfTermHits;\n\n                        if ( selectedTermIds.indexOf( aTerm.id ) > -1 ) {\n                            countOfTermHits += 1;\n                        }\n\n                    } );\n\n                    if ( countOfTermHits === selectedTermIds.length ) {\n                        output.push( elem );\n                    }\n\n                } );\n\n            } else {\n                output = input;\n            }\n\n            return output;\n\n        };\n    } )\n    .controller( 'TermFilterController', function ( $scope ) {\n\n        $scope.toggle = function ( term ) {\n\n            var index;\n\n            index = $scope.selectedTermIds.indexOf( term.id );\n\n            if ( index === -1 ) {\n                $scope.selectedTermIds.push( term.id );\n            } else {\n                $scope.selectedTermIds.splice( index, 1 );\n            }\n        };\n\n    } )\n    .directive(\n        'termFilter',\n        function () {\n\n            return {\n                scope: {\n                    availableTerms: '=',\n                    selectedTermIds: '='\n                },\n                controller: 'TermFilterController',\n                restrict: 'E',\n                replace: true,\n                templateUrl: '/ng-gme/templates/termFilter.html'\n            };\n        } );","'use strict';\n\nmodule.exports = function ( $q, dataStoreService, projectService ) {\n\n    this.selectBranch = function ( databaseId, branchId ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            deferred = new $q.defer();\n\n        dbConn.branchService = dbConn.branchService || {};\n\n        dbConn.client.selectBranchAsync( branchId,\n            function ( err ) {\n                if ( err ) {\n                    deferred.reject( err );\n                    return;\n                }\n\n                dbConn.branchService.branchId = branchId;\n                dbConn.branchService.isInitialized = true;\n\n                deferred.resolve( branchId );\n            } );\n\n        return deferred.promise;\n    };\n\n    this.getBranches = function ( databaseId ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            deferred = new $q.defer();\n\n        dbConn.branchService = dbConn.branchService || {};\n\n        dbConn.client.getBranchesAsync( function ( err, branches ) {\n            if ( err ) {\n                deferred.reject( err );\n                return;\n            }\n\n            dbConn.branchService.isInitialized = true;\n\n            deferred.resolve( branches );\n        } );\n\n        return deferred.promise;\n    };\n\n    this.createBranch = function ( databaseId, branchId, hash ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            deferred = new $q.defer();\n\n        dbConn.branchService = dbConn.branchService || {};\n\n        dbConn.client.createBranchAsync( branchId, hash,\n            function ( err ) {\n                if ( err ) {\n                    deferred.reject( err );\n                    return;\n                }\n\n                deferred.resolve( branchId );\n            } );\n\n        return deferred.promise;\n    };\n\n    this.getSelectedBranch = function ( /*databaseId*/) {\n        throw new Error( 'Not implemented yet.' );\n    };\n\n    this.watchBranches = function ( /*databaseId*/) {\n        // TODO: register for branch events\n        // TODO: SERVER_BRANCH_CREATED\n        // TODO: SERVER_BRANCH_UPDATED\n        // TODO: SERVER_BRANCH_DELETED\n\n        throw new Error( 'Not implemented yet.' );\n    };\n\n    /**\n     * Registered functions are fired when the BRANCHSTATUS_CHANGED event was raised.\n     * TODO: Currently the eventTypes are passed to fn as the values in branchStates.\n     *  branchStates = {\n     *    'SYNC':    'inSync',\n     *    'FORKED':  'forked',\n     *    'OFFLINE': 'offline'\n     *  };\n     * @param {string} databaseId\n     * @param {function} fn\n     */\n    this.watchBranchState = function ( databaseId, fn ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId );\n        if ( !( dbConn && dbConn.branchService && dbConn.branchService.branchId ) ) {\n            console.error( databaseId + ' does not have an active database connection or branch-service.' );\n        }\n        if ( typeof dbConn.branchService.events === 'undefined' ||\n            typeof dbConn.branchService.events.branchState === 'undefined' ) {\n            dbConn.branchService.events = dbConn.branchService.events || {};\n            dbConn.branchService.events.branchState = dbConn.branchService.events.branchState || [];\n            dbConn.branchService.events.branchState.push( fn );\n            dbConn.client.addEventListener( dbConn.client.events.BRANCHSTATUS_CHANGED,\n                function ( dummy, eventType ) {\n                    var i;\n                    //console.log(eventType);\n                    for ( i = 0; i < dbConn.branchService.events.branchState.length; i += 1 ) {\n                        dbConn.branchService.events.branchState[ i ]( eventType );\n                    }\n                } );\n        } else {\n            dbConn.branchService.events.branchState.push( fn );\n        }\n        // FIXME: When should these be cleaned up? On demand? On destroy? Never?\n    };\n\n    this.on = function ( databaseId, eventName, fn ) {\n        var dbConn,\n            i;\n\n        console.assert( typeof databaseId === 'string' );\n        console.assert( typeof eventName === 'string' );\n        console.assert( typeof fn === 'function' );\n\n        dbConn = dataStoreService.getDatabaseConnection( databaseId );\n        dbConn.branchService = dbConn.branchService || {};\n\n        dbConn.branchService.isInitialized = dbConn.branchService.isInitialized || false;\n\n        if ( typeof dbConn.branchService.events === 'undefined' ) {\n            // register for project events\n            projectService.on( databaseId, 'initialize', function ( dbId ) {\n                var dbConnEvent = dataStoreService.getDatabaseConnection( dbId ),\n                    i;\n\n                if ( dbConnEvent.branchService &&\n                    dbConnEvent.branchService.events &&\n                    dbConnEvent.branchService.events.initialize ) {\n\n                    dbConnEvent.branchService.isInitialized = true;\n\n                    for ( i = 0; i < dbConnEvent.branchService.events.initialize.length; i += 1 ) {\n                        dbConnEvent.branchService.events.initialize[ i ]( dbId );\n                    }\n                }\n            } );\n\n            projectService.on( databaseId, 'destroy', function ( dbId ) {\n                var dbConnEvent = dataStoreService.getDatabaseConnection( dbId ),\n                    i;\n\n                if ( dbConnEvent.branchService &&\n                    dbConnEvent.branchService.events &&\n                    dbConnEvent.branchService.events.destroy ) {\n\n                    dbConnEvent.branchService.isInitialized = false;\n\n                    for ( i = 0; i < dbConnEvent.branchService.events.destroy.length; i += 1 ) {\n                        dbConnEvent.branchService.events.destroy[ i ]( dbId );\n                    }\n                }\n            } );\n\n            dbConn.client.addEventListener( dbConn.client.events.BRANCH_CHANGED,\n                function ( projectId /* FIXME */ , branchId ) {\n\n                    if ( dbConn.branchService.branchId !== branchId ) {\n\n                        dbConn.branchService.branchId = branchId;\n\n                        console.log( 'There was a BRANCH_CHANGED event', branchId );\n                        if ( branchId ) {\n                            // initialize\n                            if ( dbConn.branchService &&\n                                dbConn.branchService.events &&\n                                dbConn.branchService.events.initialize ) {\n\n                                dbConn.branchService.isInitialized = true;\n\n                                for ( i = 0; i < dbConn.branchService.events.initialize.length; i += 1 ) {\n                                    dbConn.branchService.events.initialize[ i ]( databaseId );\n                                }\n                            }\n                        } else {\n                            // branchId is falsy, empty or null or undefined\n                            // destroy\n                            if ( dbConn.branchService &&\n                                dbConn.branchService.events &&\n                                dbConn.branchService.events.destroy ) {\n\n                                dbConn.branchService.isInitialized = false;\n                                delete dbConn.branchService.branchId;\n\n                                for ( i = 0; i < dbConn.branchService.events.destroy.length; i += 1 ) {\n                                    dbConn.branchService.events.destroy[ i ]( databaseId );\n                                }\n                            }\n                        }\n                    }\n                } );\n        }\n\n        dbConn.branchService.events = dbConn.branchService.events || {};\n        dbConn.branchService.events[ eventName ] = dbConn.branchService.events[ eventName ] || [];\n        dbConn.branchService.events[ eventName ].push( fn );\n\n        if ( dbConn.branchService.isInitialized ) {\n            if ( eventName === 'initialize' ) {\n                fn( databaseId );\n            }\n        } else {\n            if ( eventName === 'destroy' ) {\n                fn( databaseId );\n            }\n        }\n\n        // TODO: register for branch change event OR BranchService onInitialize\n    };\n};","/*globals GME*/\n\n'use strict';\n\nmodule.exports = function ( $q ) {\n    var dataStores = {},\n        connectQueue = [],\n        queueProcessing = false,\n        connectNextInQueue,\n        processQueue;\n\n    /*isAnotherThreadConnecting = function(databaseId) {\n        if (connectingProgress.indexOf(databaseId) !== -1) {\n            return true;\n        }\n        return false;\n    };\n\n    connect = function(databaseId, options, deferred) {\n        var client;\n\n        connectingProgress.push(databaseId);\n\n        if (dataStores.hasOwnProperty(databaseId)) {\n            console.log('connection already exists, remove from connecting phase');\n            connectingProgress.splice(connectingProgress.indexOf(databaseId), 1);\n\n            // FIXME: this may or may not ready yet...\n            deferred.resolve();\n        } else {\n\n\n            client = new WebGMEGlobal.classes.Client(options);\n\n            // hold a reference to the client instance\n            dataStores[databaseId] = {\n                client: client\n            };\n\n            // TODO: add event listeners to client\n\n            // FIXME: deferred should not be used from closure\n            client.connectToDatabaseAsync({}, function(err) {\n                console.log('connected, remove from connecting phase');\n                connectingProgress.splice(connectingProgress.indexOf(databaseId), 1);\n                if (err) {\n                    deferred.reject(err);\n                    return;\n                }\n\n                deferred.resolve();\n            });\n        }\n    };\n\n    waitForAnotherThread = function(databaseId, options, deferred, maxTry) {\n        if (isAnotherThreadConnecting(databaseId)) {\n            console.log('another thread is connecting: ' + maxTry);\n            timer = setTimeout(function() {\n                clearTimeout(timer);\n                if (maxTry-- > 0) {\n                    waitForAnotherThread(databaseId, options, deferred, maxTry);\n                }\n            }, 100);\n        } else {\n            console.log('connecting, remaining tries' + maxTry);\n            connect(databaseId, options, deferred);\n        }\n    };*/\n\n\n    // Picks up the next connectionmeta and tries to connect\n    // After a(n) (un)successful connection, the defered resolve/promise is called\n    // and the function picks up the next item from the queue\n    connectNextInQueue = function () {\n        if ( connectQueue.length > 0 ) {\n            var currentItem = connectQueue[ 0 ];\n\n            if ( dataStores.hasOwnProperty( currentItem.databaseId ) ) {\n                // FIXME: this may or may not ready yet...\n                currentItem.deferred.resolve();\n                connectQueue.splice( 0, 1 );\n                connectNextInQueue();\n            } else {\n                var client = new GME.classes.Client( currentItem.options );\n\n                // hold a reference to the client instance\n                dataStores[ currentItem.databaseId ] = {\n                    client: client,\n                    isInTransaction: false\n                };\n\n                // TODO: add event listeners to client\n                // FIXME: deferred should not be used from closure\n                client.connectToDatabaseAsync( {}, function ( err ) {\n                    if ( err ) {\n                        currentItem.deferred.reject( err );\n                    } else {\n                        currentItem.deferred.resolve();\n                    }\n\n                    connectQueue.splice( 0, 1 );\n                    connectNextInQueue();\n                } );\n            }\n        } else {\n            queueProcessing = false;\n            if ( connectQueue.length > 0 ) {\n                processQueue();\n            }\n        }\n    };\n\n    // Check if there are any processing phase\n    // No simultaneous processing\n    processQueue = function () {\n        if ( !queueProcessing ) {\n            queueProcessing = true;\n            connectNextInQueue();\n        }\n    };\n\n    // Just one connection phase at one time.\n    // Multiple connection phase may cause 'unexpected results'\n    this.connectToDatabase = function ( databaseId, options ) {\n        var deferred = $q.defer();\n\n        // Put the connection metadata into a queue\n        connectQueue.push( {\n            databaseId: databaseId, // Where to connect? Default: 'multi'\n            deferred: deferred, // defered object, where the notifications are sent if the connection succesful (or not)\n            options: options // Connection oprtions\n        } );\n\n        processQueue();\n\n        return deferred.promise;\n    };\n\n    this.getDatabaseConnection = function ( databaseId ) {\n        if ( dataStores.hasOwnProperty( databaseId ) && typeof dataStores[ databaseId ] === 'object' ) {\n            return dataStores[ databaseId ];\n        }\n\n        console.error( databaseId + ' does not have an active database connection.' );\n    };\n\n    /**\n     * Registered functions are fired when the NETWORKSTATUS_CHANGED event was raised.\n     * TODO: Currently the eventTypes are passed to fn as the values in networkStates.\n     *  networkStates = {\n     *    'CONNECTED':    'connected',\n     *    'DISCONNECTED': 'socket.io is disconnected'\n     *  };\n     * @param {string} databaseId\n     * @param {function} fn\n     */\n    this.watchConnectionState = function ( databaseId, fn ) {\n        var dbConn = dataStores[ databaseId ];\n\n        if ( !( dbConn && typeof dbConn === 'object' ) ) {\n            console.error( databaseId + ' does not have an active database connection.' );\n        }\n\n        if ( typeof dbConn.events === 'undefined' || typeof dbConn.events.connectionState === 'undefined' ) {\n            dbConn.events = dbConn.events || {};\n            dbConn.events.connectionState = dbConn.events.connectionState || [];\n            dbConn.events.connectionState.push( fn );\n            dbConn.client.addEventListener( dbConn.client.events.NETWORKSTATUS_CHANGED,\n                function ( dummy, eventType ) {\n                    var i;\n                    console.log( eventType );\n                    for ( i = 0; i < dbConn.events.connectionState.length; i += 1 ) {\n                        dbConn.events.connectionState[ i ]( eventType );\n                    }\n                } );\n        } else {\n            dbConn.events.push( fn );\n        }\n    };\n\n    // TODO: on selected project changed, on initialize and on destroy (socket.io connected/disconnected)\n};","'use strict';\n\nmodule.exports = function ( $q, dataStoreService, branchService ) {\n\n    var self = this,\n        NodeObj,\n        getIdFromNodeOrString;\n\n    /**\n     * Loads the meta nodes from the context (will create a node-service on the dbConn with regions if not present when invoked).\n     * The meta-nodes will be returned in the following format:\n     * {\n     *     byId: {\n     *         '1/2': NodeObj1,\n     *         '1/3': NodeObj2,\n     *         ...\n     *         'x/x/': NodeObjN\n     *     },\n     *     byName: {\n     *         'Name1': NodeObj1,\n     *         'Name2': NodeObj2,\n     *         ...\n     *         'NameN': NodeObjN\n     *     }\n     * }\n     * @param {object} context - From where to load the nodes.\n     * @param {string} context.db - Database where the nodes will be loaded from.\n     * @param {string} context.regionId - Region where the NodeObjs will be stored.\n     * @returns {Promise<object>} - Returns an object of NodeObjs grouped by \"byId\" and \"byName\" when resolved.\n     */\n    this.getMetaNodes = function ( context ) {\n        var deferred = $q.defer();\n        self.loadNode( context, '' )\n            .then( function ( rootNode ) {\n                var metaNodeIds = rootNode.getMemberIds( 'MetaAspectSet' ),\n                    queueList = [],\n                    i;\n\n                //console.log(metaNodeIds);\n                for ( i = 0; i < metaNodeIds.length; i += 1 ) {\n                    queueList.push( self.loadNode( context, metaNodeIds[ i ] ) );\n                }\n                $q.all( queueList )\n                    .then( function ( metaNodes ) {\n                        var i,\n                            metaNode,\n                            meta = {\n                                byId: {},\n                                byName: {}\n                            };\n                        for ( i = 0; i < metaNodes.length; i += 1 ) {\n                            metaNode = metaNodes[ i ];\n                            meta.byId[ metaNode.getId() ] = metaNode;\n                            meta.byName[ metaNode.getAttribute( 'name' ) ] = metaNode;\n                        }\n                        deferred.resolve( meta );\n                    } );\n            } );\n\n        return deferred.promise;\n    };\n\n    /**\n     * Loads a node from context (will create a node-service on the dbConn with regions if not present when invoked).\n     * @param {object} context - From where to look for the node.\n     * @param {string} context.db - Database where the node will be looked for.\n     * @param {string} context.regionId - Region where the NodeObj will be stored.\n     * @param {string} id - Path to the node.\n     * @returns {Promise<NodeObj>} - Returns the NodeObj when resolved.\n     */\n    this.loadNode = function ( context, id ) {\n        var deferred = $q.defer(),\n            dbConn = dataStoreService.getDatabaseConnection( context.db ),\n            territoryId,\n            territoryPattern = {},\n            nodes;\n\n        console.assert( typeof context.regionId === 'string' );\n\n        territoryId = context.regionId + '_' + id;\n        dbConn.nodeService = dbConn.nodeService || {};\n        dbConn.nodeService.regions = dbConn.nodeService.regions || {};\n        dbConn.nodeService.regions[ context.regionId ] = dbConn.nodeService.regions[ context.regionId ] || {\n            regionId: context.regionId,\n            nodes: {}\n        };\n\n        nodes = dbConn.nodeService.regions[ context.regionId ].nodes;\n        //console.log('territoryId', territoryId);\n        if ( nodes.hasOwnProperty( id ) ) {\n            console.log( 'Node already loaded..', id );\n            deferred.resolve( nodes[ id ] );\n        } else {\n            dbConn.client.addUI( {}, function ( events ) {\n                var i,\n                    event;\n\n                for ( i = 0; i < events.length; i += 1 ) {\n                    event = events[ i ];\n                    if ( id !== event.eid ) {\n                        continue;\n                    }\n                    if ( event.etype === 'load' ) {\n                        nodes[ id ] = new NodeObj( context, id );\n                        nodes[ id ].territories.push( territoryId );\n                        deferred.resolve( nodes[ id ] );\n                    } else if ( event.etype === 'update' ) {\n                        nodes[ id ]._onUpdate( event.eid );\n                    } else if ( event.etype === 'unload' ) {\n                        nodes[ id ]._onUnload( event.eid );\n                        nodes[ id ].__onUnload();\n                    } else {\n                        throw 'Unexpected event type' + events[ i ].etype;\n                    }\n                }\n            }, territoryId );\n\n            territoryPattern[ id ] = {\n                children: 0\n            };\n            dbConn.client.updateTerritory( territoryId, territoryPattern );\n        }\n\n        return deferred.promise;\n    };\n\n    /**\n     * Creates a new node in the database and returns with the NodeObj.\n     * @param {object} context - Where to create the node.\n     * @param {string} context.db - Database where the node will be created.\n     * @param {string} context.regionId - Region where the NodeObj will be stored.\n     * @param {NodeObj|string} parent - model where the node should be created.\n     * @param {NodeObj|string} base - base, e.g. meta-type, of the new node.\n     * @param {string} [msg] - optional commit message.\n     * @returns {Promise<NodeObj>} - Evaluates to the newly created node (inside context).\n     */\n    this.createNode = function ( context, parent, base, msg ) {\n        var deferred = $q.defer(),\n            dbConn = dataStoreService.getDatabaseConnection( context.db ),\n            parentId = getIdFromNodeOrString( parent ),\n            baseId = getIdFromNodeOrString( base ),\n            id;\n\n        id = dbConn.client.createChild( {\n            parentId: parentId,\n            baseId: baseId\n        }, msg );\n\n        self.loadNode( context, id )\n            .then( function ( node ) {\n                deferred.resolve( node );\n            } );\n\n        return deferred.promise;\n    };\n\n    /**\n     * Creates a new node in the database and returns with its assigned id (path).\n     * @param {object} context - Where to create the node.\n     * @param {string} context.db - Database where the node will be created.\n     * @param {object} parameters - as in client.createChild (see this.createNode for example).\n     * @param {string} [msg] - optional commit message.\n     * @returns {string} - id (path) of new node.\n     */\n    this.createChild = function ( context, parameters, msg ) {\n        var dbConn = dataStoreService.getDatabaseConnection( context.db );\n        return dbConn.client.createChild( parameters, msg );\n    };\n\n    /**\n     * Updates the attribute of the given node\n     * @param {object} context - Where to create the node.\n     * @param {string} context.db - Database where the node will be created.\n     * @param {string} id - Path to node to update.\n     * @param {string} name - Name of Attribute.\n     * @param {string} value - New value for Attribute.\n     * @param {string} [msg] - optional commit message.\n     * @returns {string} - id (path) of new node.\n     */\n    this.setAttributes = function ( context, id, name, value, msg ) {\n        var dbConn = dataStoreService.getDatabaseConnection( context.db );\n        return dbConn.client.setAttributes( id, name, value, msg );\n    };\n\n    /**\n     * Removes the node from the data-base connection.\n     * @param {object} context - From where to delete the node.\n     * @param {string} context.db - Database from where the node will be deleted.\n     * @param {NodeObj|string} nodeOrId - node that should be deleted (the NodeObj(s) will be removed from all regions through __OnUnload()).\n     * @param {string} [msg] - optional commit message.\n     */\n    this.destroyNode = function ( context, nodeOrId, msg ) {\n        var dbConn = dataStoreService.getDatabaseConnection( context.db ),\n            id = getIdFromNodeOrString( nodeOrId ),\n            nodeToDelete = dbConn.client.getNode( id );\n        if ( nodeToDelete ) {\n            dbConn.client.delMoreNodes( [ id ], msg );\n        } else {\n            console.warn( 'Requested deletion of node that does not exist in context! (id, context) ',\n                id,\n                context );\n        }\n    };\n\n    /**\n     * Copies the nodes from nodeIds into parentId. N.B. all participating nodes need to be loaded in some region.\n     * nodesToCopy:\n     *  {\n     *      '/1/2/3': {\n     *          registry: {\n     *              position: {\n     *                  x: 100,\n     *                  y: 100\n     *              }\n     *          },\n     *          attributes: {\n     *              name: 'Copy'\n     *          }\n     *      },\n     *      '/1/2/4': {\n     *          attributes: {\n     *              name: 'Copy'\n     *          }\n     *      },\n     *      '/1/2/5': null\n     *  }\n     * @param {object} context - Where to create the node.\n     * @param {string} context.db - Database where the node will be created.\n     * @param {string} parentId - Path to parent node (must be loaded and needs to watch for new children to get events).\n     * @param {Object} nodesToCopy - Object where keys are ids of nodes to be copied, these need to be loaded in the client.\n     */\n    this.copyMoreNodes = function ( context, parentId, nodesToCopy ) {\n        var dbConn = dataStoreService.getDatabaseConnection( context.db );\n        nodesToCopy.parentId = parentId;\n\n        // There is no callback/promise here, instead wait for events in the parent\n        // granted it watches for new children.\n        dbConn.client.copyMoreNodes( nodesToCopy );\n    };\n\n    /**\n     * Removes all references and listeners attached to any NodeObj in the region.\n     * N.B. This function must be invoked for all regions that a \"user\" created.\n     * This is typically done in the \"$scope.on($destroy)\"-function of a controller.\n     * @param {string} databaseId - data-base connection from where the region will be removed.\n     * @param {string} regionId - Region to clean-up.\n     */\n    this.cleanUpRegion = function ( databaseId, regionId ) {\n        var key,\n            dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            nodes = dbConn.nodeService.regions[ regionId ].nodes;\n        // Go through all nodes and remove the territories associated with each node.\n        for ( key in nodes ) {\n            if ( nodes.hasOwnProperty( key ) ) {\n                nodes[ key ].cleanUpNode();\n            }\n        }\n        // Remove the reference to the region (includes) nodes.\n        delete dbConn.nodeService.regions[ regionId ];\n    };\n\n\n    this.cleanUpAllRegions = function ( databaseId ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            regionId;\n\n        if ( dbConn.nodeService ) {\n            //                console.log(dbConn.nodeService.regions);\n            for ( regionId in dbConn.nodeService.regions ) {\n                if ( dbConn.nodeService.regions.hasOwnProperty( regionId ) ) {\n                    self.cleanUpRegion( databaseId, regionId );\n                }\n            }\n            //                console.log(dbConn.nodeService.regions);\n        }\n    };\n\n    /**\n     * Starts a new transaction meaning where changes are bundled into a single commit upon\n     * completion (see this.completeTransaction).\n     * @param {object} context - Where to create the node.\n     * @param {string} context.db - Database where the node will be created.\n     * @param {string} [msg] - Optional commit message.\n     * @returns {boolean} - True if no other transaction was open.\n     */\n    this.startTransaction = function ( context, msg ) {\n        var result = false,\n            dbConn = dataStoreService.getDatabaseConnection( context.db );\n\n        if ( dbConn.isInTransaction ) {\n            // TODO: Remove error logging here and let user log.\n            console.error( 'Already in transaction - refused to start additional.' );\n        } else {\n            dbConn.isInTransaction = true;\n            dbConn.client.startTransaction( msg );\n            result = true;\n        }\n\n        return result;\n    };\n\n    /**\n     * Closes an open transaction and updates the branch hash.\n     * @param {object} context - Where to create the node.\n     * @param {string} context.db - Database where the node will be created.\n     * @param {string} [msg] - Optional commit message.\n     * @returns {Promise} - Resolved when branch updated successfully.\n     */\n    this.completeTransaction = function ( context, msg ) {\n        var deferred = $q.defer(),\n            dbConn = dataStoreService.getDatabaseConnection( context.db );\n\n        if ( dbConn.isInTransaction ) {\n            dbConn.client.completeTransaction( msg, function ( err ) {\n                dbConn.isInTransaction = false;\n                if ( err ) {\n                    deferred.reject( err );\n                } else {\n                    deferred.resolve();\n                }\n            } );\n        } else {\n            deferred.reject( 'No transaction open!' );\n        }\n\n        return deferred.promise;\n    };\n\n    /**\n     * Logs the regions of the database connection.\n     * @param {string} databaseId - Id of database to log.\n     */\n    this.logContext = function ( databaseId ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId );\n        console.log( 'logContext: ', dbConn );\n    };\n\n    NodeObj = function ( context, id ) {\n        var thisNode = this;\n        this.id = id;\n        this.territories = [];\n        this.context = context;\n        this.databaseConnection = dataStoreService.getDatabaseConnection( context.db );\n        // TODO: Should these be arrays of functions? The controller may want to add more methods.\n        this._onUpdate = function ( /*id*/) {};\n        this._onUnload = function ( /*id*/) {};\n        // This will always be called on unload.\n        this.__onUnload = function () {\n            thisNode.cleanUpNode();\n            delete thisNode.databaseConnection.nodeService.regions[ context.regionId ].nodes[ thisNode.id ];\n        };\n    };\n\n    NodeObj.prototype.cleanUpNode = function () {\n        var i;\n        // This ought to remove all references to event handlers in the client.\n        // In current implementation a NodeObj can own two territories - its own and its 'newchild' terr\n        for ( i = 0; i < this.territories.length; i += 1 ) {\n            this.databaseConnection.client.removeUI( this.territories[ i ] );\n        }\n    };\n\n    NodeObj.prototype.getAttribute = function ( name ) {\n        return this.databaseConnection.client.getNode( this.id )\n            .getAttribute( name );\n    };\n\n    NodeObj.prototype.setAttribute = function ( name, value, msg ) {\n        this.databaseConnection.client.setAttributes( this.id, name, value, msg );\n    };\n\n    NodeObj.prototype.getRegistry = function ( name ) {\n        return this.databaseConnection.client.getNode( this.id )\n            .getRegistry( name );\n    };\n\n    NodeObj.prototype.setRegistry = function ( name, value, msg ) {\n        this.databaseConnection.client.setRegistry( this.id, name, value, msg );\n    };\n\n    /** Gets nodeIds of nodes this node points 'to' and is pointed to 'from'.\n     * @param {string} name - name of pointer, e.g. 'src', 'dst'.\n     * @returns {object} pointers - object with ids.\n     * @returns {string} pointers.to - node id the pointer of this NodeObj points to.\n     * @returns {[string]} pointers.from - node ids of nodes that points to this NodeObj through the pointer.\n     */\n    NodeObj.prototype.getPointer = function ( name ) {\n        return this.databaseConnection.client.getNode( this.id )\n            .getPointer( name );\n    };\n\n    /**\n     * Sets pointer named pointer from this node to given node.\n     * @param {string} name - name of pointer, e.g. 'src', 'dst'.\n     * @param {string} toId - id of node to point to\n     * @param {string} [msg] - optional commit message.\n     */\n    NodeObj.prototype.makePointer = function ( name, toId, msg ) {\n        this.databaseConnection.client.makePointer( this.id, name, toId, msg );\n    };\n\n    NodeObj.prototype.getCollectionPaths = function ( name ) {\n        return this.databaseConnection.client.getNode( this.id )\n            .getCollectionPaths( name );\n    };\n\n    NodeObj.prototype.getBaseNode = function () {\n        // TODO: add proper error handling\n        return self.loadNode( this.context, this.getBaseId() );\n    };\n\n    NodeObj.prototype.getParentId = function () {\n        return this.databaseConnection.client.getNode( this.id )\n            .getParentId();\n    };\n\n    NodeObj.prototype.getParentNode = function () {\n        // TODO: add proper error handling\n        return self.loadNode( this.context, this.getParentId() );\n    };\n\n    NodeObj.prototype.getId = function () {\n        return this.id;\n    };\n\n    NodeObj.prototype.getBaseId = function () {\n        return this.databaseConnection.client.getNode( this.id )\n            .getBaseId();\n    };\n\n    NodeObj.prototype.getGuid = function () {\n        return this.databaseConnection.client.getNode( this.id )\n            .getGuid();\n    };\n\n    NodeObj.prototype.getChildrenIds = function () {\n        return this.databaseConnection.client.getNode( this.id )\n            .getChildrenIds();\n    };\n\n    NodeObj.prototype.loadChildren = function () {\n        var childrenIds = this.getChildrenIds(),\n            queueList = [],\n            i;\n\n        for ( i = 0; i < childrenIds.length; i += 1 ) {\n            queueList.push( self.loadNode( this.context, childrenIds[ i ] ) );\n        }\n\n        return $q.all( queueList );\n    };\n\n    NodeObj.prototype.createChild = function ( /*baseNodeOrId, name*/) {\n\n    };\n\n    /**\n     * Removes the node from the data-base. (All regions within the same context should get onUnload events).\n     * @param [msg] - Optional commit message.\n     */\n    NodeObj.prototype.destroy = function ( msg ) {\n        // TODO: Perhaps remove the node from its context/region at this point? Now it waits for the unload event\n        self.destroyNode( this.context, this.id, msg );\n    };\n\n    NodeObj.prototype.getMemberIds = function ( name ) {\n        return this.databaseConnection.client.getNode( this.id )\n            .getMemberIds( name );\n    };\n\n    /**\n     * Finds the (most specific) meta-node this node inherits from and returns it.\n     * @param {Object} metaNodes - MetaNodes given as returned in this.getMetaType\n     * @param {Object} metaNodes.byId - Dictionary where keys are the ids of the metaNodes.\n     * @returns {NodeObj} - The (most specific) meta-node this node inherits from.\n     */\n    NodeObj.prototype.getMetaTypeNode = function ( metaNodes ) {\n        var node = this.databaseConnection.client.getNode( this.id ),\n            metaNode;\n        console.assert( typeof metaNodes.byId === 'object' );\n        while ( node ) {\n            metaNode = metaNodes.byId[ node.getId() ];\n            if ( metaNode ) {\n                return metaNode;\n            }\n            node = this.databaseConnection.client.getNode( node.getBaseId() );\n        }\n\n        console.error( 'Could not getMetaTypeNode of ', this.getAttribute( 'name' ), this.id );\n        return null;\n    };\n\n    /**\n     * Finds the name of the (most specific) meta-node this node inherits from and returns it.\n     * @param {Object} metaNodes - MetaNodes given as returned in this.getMetaType\n     * @param {Object} metaNodes.byId - Dictionary where keys are the ids of the metaNodes.\n     * @returns {string} - The name of the (most specific) meta-node this node inherits from.\n     */\n    NodeObj.prototype.getMetaTypeName = function ( metaNodes ) {\n        var metaNode = this.getMetaTypeNode( metaNodes );\n        if ( metaNode ) {\n            return metaNode.getAttribute( 'name' );\n        }\n        return null;\n    };\n\n    /**\n     * Checks if this node inherits from the given metaNode.\n     * @param {NodeObj} metaNode\n     * @returns {boolean} - True if it inherits from the metaNode.\n     */\n    NodeObj.prototype.isMetaTypeOf = function ( metaNode ) {\n        var node = this.databaseConnection.client.getNode( this.id );\n\n        while ( node ) {\n            if ( node.getId() === metaNode.getId() ) {\n                return true;\n            }\n            node = this.databaseConnection.client.getNode( node.getBaseId() );\n        }\n        return false;\n    };\n\n    NodeObj.prototype.onUpdate = function ( fn ) {\n        console.assert( typeof fn === 'function' );\n        this._onUpdate = fn;\n    };\n\n    NodeObj.prototype.onUnload = function ( fn ) {\n        console.assert( typeof fn === 'function' );\n        this._onUnload = fn;\n    };\n\n    NodeObj.prototype.onNewChildLoaded = function ( fn ) {\n        var dbConn = this.databaseConnection,\n            context = this.context,\n            territoryPattern = {},\n            id = this.id,\n            terrId = context.regionId + '_' + id + '_new_children_watch',\n            initializeNewNode;\n\n        initializeNewNode = function ( newNode ) {\n            fn( newNode );\n            //console.log('Added new territory through onNewChildLoaded ', event.eid);\n        };\n\n        //console.log(dbConn);\n        if ( this.territories.indexOf( terrId ) > -1 ) {\n            console.warn( 'Children are already being watched for ', terrId );\n        } else {\n            this.territories.push( terrId );\n            dbConn.client.addUI( {}, function ( events ) {\n                var i,\n                    event;\n                for ( i = 0; i < events.length; i += 1 ) {\n                    event = events[ i ];\n                    if ( event.etype === 'load' ) {\n                        if ( dbConn.nodeService.regions[ context.regionId ].nodes.hasOwnProperty( event.eid ) ===\n                            false ) {\n                            self.loadNode( context, event.eid )\n                                .then( initializeNewNode );\n                        } else {\n                            //console.info('Node ' + event.eid + ' was loaded in ' + terrId + ' but it already' +\n                            //    ' existed in the nodes of the region: ' + context.regionId);\n                        }\n                    } else {\n                        // These node are just watched for loading..\n                    }\n                }\n            }, terrId );\n\n            territoryPattern[ id ] = {\n                children: 1\n            };\n            dbConn.client.updateTerritory( terrId, territoryPattern );\n        }\n    };\n\n    getIdFromNodeOrString = function ( nodeOrId ) {\n        if ( typeof nodeOrId === 'string' ) {\n            return nodeOrId;\n        }\n\n        if ( typeof nodeOrId === 'object' ) {\n            if ( typeof nodeOrId.getId === 'function' ) {\n                return nodeOrId.getId();\n            } else {\n                console.error( nodeOrId, ' does not have a getId function' );\n            }\n        } else {\n            console.error( nodeOrId, ' is not a string nor an object.' );\n        }\n    };\n\n    this.on = function ( databaseId, eventName, fn ) {\n        var dbConn;\n\n        console.assert( typeof databaseId === 'string' );\n        console.assert( typeof eventName === 'string' );\n        console.assert( typeof fn === 'function' );\n\n        dbConn = dataStoreService.getDatabaseConnection( databaseId );\n        dbConn.nodeService = dbConn.nodeService || {};\n\n        dbConn.nodeService.isInitialized = dbConn.nodeService.isInitialized || false;\n\n        if ( typeof dbConn.nodeService.events === 'undefined' ) {\n            branchService.on( databaseId, 'initialize', function ( dbId ) {\n                var dbConnEvent = dataStoreService.getDatabaseConnection( dbId ),\n                    i;\n\n                self.cleanUpAllRegions( dbId );\n\n                if ( dbConnEvent.nodeService &&\n                    dbConnEvent.nodeService.events &&\n                    dbConnEvent.nodeService.events.initialize ) {\n                    // NodeService requires a selected branch.\n                    if ( dbConn.branchService.branchId ) {\n                        dbConnEvent.nodeService.isInitialized = true;\n\n                        for ( i = 0; i < dbConnEvent.nodeService.events.initialize.length; i += 1 ) {\n                            dbConnEvent.nodeService.events.initialize[ i ]( dbId );\n                        }\n                    }\n                }\n            } );\n\n            branchService.on( databaseId, 'destroy', function ( dbId ) {\n                var dbConnEvent = dataStoreService.getDatabaseConnection( dbId ),\n                    i;\n\n                self.cleanUpAllRegions( dbId );\n\n                if ( dbConnEvent.nodeService &&\n                    dbConnEvent.nodeService.events &&\n                    dbConnEvent.nodeService.events.destroy ) {\n\n                    dbConnEvent.nodeService.isInitialized = false;\n\n                    for ( i = 0; i < dbConnEvent.nodeService.events.destroy.length; i += 1 ) {\n                        dbConnEvent.nodeService.events.destroy[ i ]( dbId );\n                    }\n                }\n            } );\n        }\n\n        dbConn.nodeService.events = dbConn.nodeService.events || {};\n        dbConn.nodeService.events[ eventName ] = dbConn.nodeService.events[ eventName ] || [];\n        dbConn.nodeService.events[ eventName ].push( fn );\n\n        if ( dbConn.nodeService.isInitialized || dbConn.branchService.isInitialized ) {\n            if ( eventName === 'initialize' ) {\n                dbConn.nodeService.isInitialized = true;\n                fn( databaseId );\n            }\n        } else {\n            if ( eventName === 'destroy' ) {\n                dbConn.nodeService.isInitialized = false;\n                fn( databaseId );\n            }\n        }\n    };\n};","/*globals angular*/\n\nmodule.exports = function ( $q, dataStoreService ) {\n    'use strict';\n    //var self = this;\n\n    this.getAvailableProjectTags = function ( databaseId ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            deferred = $q.defer();\n        dbConn.projectService = dbConn.projectService || {};\n        dbConn.client.getAllInfoTagsAsync( function ( err, results ) {\n            var tagKeys,\n                tags = [];\n            if ( err ) {\n                deferred.reject( err );\n                return;\n            }\n\n            tagKeys = Object.keys( results );\n            for ( var i = tagKeys.length - 1; i >= 0; i-- ) {\n                tags.push( {\n                    id: tagKeys[ i ],\n                    name: results[ tagKeys[ i ] ]\n                } );\n            }\n\n            deferred.resolve( tags );\n        } );\n\n        return deferred.promise;\n    };\n\n    this.applyTagsOnProject = function ( databaseId, projectId, newTags ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            deferred = $q.defer(),\n            mappedTags = {},\n            tagMapper = function ( tag ) {\n                mappedTags[ tag.id ] = tag.name;\n            };\n        dbConn.projectService = dbConn.projectService || {};\n        dbConn.client.getProjectInfoAsync( projectId, function ( err, existingInfo ) {\n            if ( err ) {\n                deferred.reject( err );\n                return;\n            }\n            // Transform the tags to key-value format\n            angular.forEach( newTags, tagMapper );\n            existingInfo.tags = mappedTags;\n            dbConn.client.setProjectInfoAsync( projectId, existingInfo, function ( errInfo ) {\n                if ( errInfo ) {\n                    deferred.reject( errInfo );\n                    return;\n                }\n                deferred.resolve();\n            } );\n        } );\n\n        return deferred.promise;\n    };\n\n    this.getAvailableProjects = function ( databaseId ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            deferred = $q.defer();\n        dbConn.projectService = dbConn.projectService || {};\n        dbConn.client.getAvailableProjectsAsync( function ( err, projects ) {\n            if ( err ) {\n                deferred.reject( err );\n                return;\n            }\n\n            deferred.resolve( projects );\n        } );\n\n        return deferred.promise;\n    };\n\n    this.getProjects = function ( databaseId ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            deferred = new $q.defer();\n\n        dbConn.projectService = dbConn.projectService || {};\n\n        dbConn.client.getFullProjectsInfoAsync( function ( err, result ) {\n            var projectTags,\n                branches,\n                projects = [],\n                projectMapper,\n                projectTagsMapper,\n                branchMapper;\n\n            projectTagsMapper = function ( tagName, tagId ) {\n                projectTags.push( {\n                    id: tagId,\n                    name: tagName\n                } );\n            };\n\n            branchMapper = function ( commitId, branchId ) {\n                branches.push( {\n                    branchId: branchId,\n                    commitId: commitId\n                } );\n            };\n\n            projectMapper = function ( project, projectId ) {\n                projectTags = [];\n                branches = [];\n\n                project.info = project.info || {};\n\n                // Transform tags\n                angular.forEach( project.info.tags, projectTagsMapper );\n                project.info.tags = projectTags;\n\n                // Transform branches\n                angular.forEach( project.branches, branchMapper );\n\n                // Transform project\n                projects.push( {\n                    id: projectId,\n                    branches: branches,\n                    info: project.info,\n                    rights: project.rights\n                } );\n            };\n\n            if ( err ) {\n                deferred.reject( err );\n                return;\n            }\n\n            angular.forEach( result, projectMapper );\n            deferred.resolve( projects );\n        } );\n        return deferred.promise;\n    };\n\n    this.getProjectsIds = function ( databaseId ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            deferred = new $q.defer();\n\n        dbConn.projectService = dbConn.projectService || {};\n\n        dbConn.client.getAvailableProjectsAsync( function ( err, projectIds ) {\n            if ( err ) {\n                deferred.reject( err );\n                return;\n            }\n\n            deferred.resolve( projectIds );\n        } );\n\n        return deferred.promise;\n    };\n\n    this.createProject = function ( databaseId, projectname, projectInfo ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            deferred = new $q.defer();\n\n        dbConn.client.createProjectAsync( projectname, projectInfo, function ( err ) {\n            if ( err ) {\n                deferred.reject( err );\n                return;\n            } else {\n                deferred.resolve();\n            }\n        } );\n\n        return deferred.promise;\n    };\n\n    this.deleteProject = function ( databaseId, projectId ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            deferred = new $q.defer();\n\n        console.log( projectId );\n\n        dbConn.client.deleteProjectAsync( projectId, function ( err ) {\n            if ( err ) {\n                deferred.reject( err );\n                return;\n            } else {\n                deferred.resolve();\n            }\n        } );\n\n        return deferred.promise;\n    };\n\n    this.selectProject = function ( databaseId, projectId ) {\n        var dbConn = dataStoreService.getDatabaseConnection( databaseId ),\n            deferred = new $q.defer();\n\n        dbConn.projectService = dbConn.projectService || {};\n\n        this.getProjectsIds( databaseId )\n            .then( function ( projectIds ) {\n                if ( projectIds.indexOf( projectId ) > -1 ) {\n                    // Make sure that PROJECT_OPENED is registered.\n                    // self.on( databaseId, 'RegisterEventListener', function () {} );\n                    dbConn.client.selectProjectAsync( projectId, function ( err ) {\n                        if ( err ) {\n                            deferred.reject( err );\n                            return;\n                        }\n\n                        dbConn.projectService.projectId = projectId;\n                        dbConn.projectService.isInitialized = true;\n                        deferred.resolve( projectId );\n                    } );\n                } else {\n                    deferred.reject( new Error( 'Project does not exist. ' + projectId + ' databaseId: ' +\n                        databaseId ) );\n                }\n            } )\n            .\n        catch ( function ( reason ) {\n            deferred.reject( reason );\n        } );\n\n        return deferred.promise;\n    };\n\n    this.watchProjects = function ( /*databaseId*/) {\n        // TODO: register for project events\n        // TODO: SERVER_PROJECT_CREATED\n        // TODO: SERVER_PROJECT_DELETED\n\n        throw new Error( 'Not implemented yet.' );\n    };\n\n    this.on = function ( databaseId, eventName, fn ) {\n        var dbConn,\n            i;\n\n        console.assert( typeof databaseId === 'string' );\n        console.assert( typeof eventName === 'string' );\n        console.assert( typeof fn === 'function' );\n\n        dbConn = dataStoreService.getDatabaseConnection( databaseId );\n        dbConn.projectService = dbConn.projectService || {};\n\n        dbConn.projectService.isInitialized = dbConn.projectService.isInitialized || false;\n\n        if ( typeof dbConn.projectService.events === 'undefined' ) {\n            // this should not be an inline function\n\n            dbConn.client.addEventListener( dbConn.client.events.PROJECT_OPENED,\n                function ( dummy /* FIXME */ , projectId ) {\n\n                    if ( dbConn.projectService.projectId !== projectId ) {\n                        dbConn.projectService.projectId = projectId;\n\n                        console.log( 'There was a PROJECT_OPENED event', projectId );\n                        if ( projectId ) {\n                            // initialize\n                            if ( dbConn.projectService &&\n                                dbConn.projectService.events &&\n                                dbConn.projectService.events.initialize ) {\n\n                                dbConn.projectService.isInitialized = true;\n\n                                for ( i = 0; i < dbConn.projectService.events.initialize.length; i += 1 ) {\n                                    dbConn.projectService.events.initialize[ i ]( databaseId );\n                                }\n                            }\n                        } else {\n                            // branchId is falsy, empty or null or undefined\n                            // destroy\n                            if ( dbConn.projectService &&\n                                dbConn.projectService.events &&\n                                dbConn.projectService.events.destroy ) {\n\n                                dbConn.projectService.isInitialized = false;\n\n                                for ( i = 0; i < dbConn.projectService.events.destroy.length; i += 1 ) {\n                                    dbConn.projectService.events.destroy[ i ]( databaseId );\n                                }\n                            }\n                        }\n                    }\n                } );\n\n            dbConn.client.addEventListener( dbConn.client.events.PROJECT_CLOSED,\n                function ( /*dummy*/ /* FIXME */) {\n                    console.log( 'There was a PROJECT_CLOSED event', dbConn.projectService.projectId );\n\n                    delete dbConn.projectService.projectId;\n\n                    // destroy\n                    if ( dbConn.projectService &&\n                        dbConn.projectService.events &&\n                        dbConn.projectService.events.destroy ) {\n\n                        dbConn.projectService.isInitialized = false;\n\n                        for ( i = 0; i < dbConn.projectService.events.destroy.length; i += 1 ) {\n                            dbConn.projectService.events.destroy[ i ]( databaseId );\n                        }\n                    }\n\n                } );\n        }\n\n        dbConn.projectService.events = dbConn.projectService.events || {};\n        dbConn.projectService.events[ eventName ] = dbConn.projectService.events[ eventName ] || [];\n        dbConn.projectService.events[ eventName ].push( fn );\n\n        if ( dbConn.projectService.isInitialized ) {\n            if ( eventName === 'initialize' ) {\n                fn( databaseId );\n            }\n        } else {\n            if ( eventName === 'destroy' ) {\n                fn( databaseId );\n            }\n        }\n    };\n};","/*globals angular, require*/\n\n'use strict';\n\nvar DataStoreServiceClass = require( './DataStoreService.js' ),\n    ProjectServiceClass = require( './ProjectService/ProjectService.js' ),\n    BranchServiceClass = require( './BranchService.js' ),\n    NodeServiceClass = require( './NodeService.js' );\n\nangular.module( 'gme.services', [] )\n    .service( 'dataStoreService', DataStoreServiceClass )\n    .service( 'projectService', ProjectServiceClass )\n    .service( 'branchService', BranchServiceClass )\n    .service( 'nodeService', NodeServiceClass );","/*globals angular, require*/\n\n'use strict';\n\nvar ProjectServiceTestClass = require( './tests/ProjectServiceTest.js' );\n\nangular.module( 'gme.testServices', [] )\n    .service( 'projectServiceTest', ProjectServiceTestClass );","'use strict';\n\nrequire( '../gmeServices.js' );\n\nmodule.exports = function ( $q, dataStoreService, projectService ) {\n    var testProjects = [ {\n        projectName: 'ProjectServiceTest1',\n        projectInfo: {\n            visibleName: 'ProjectServiceTest1',\n            description: 'project in webGME',\n            tags: {\n                tag1: 'Master'\n            }\n        }\n    }, {\n        projectName: 'ProjectServiceTest2',\n        projectInfo: {\n            visibleName: 'ProjectServiceTest2',\n            description: 'project in webGME',\n            tags: {\n                tag1: 'Master'\n            }\n        }\n    } ];\n\n    this.startTest = function () {\n        var deferred = new $q.defer(),\n            index = 0;\n\n        dataStoreService.connectToDatabase( 'multi', {\n            host: window.location.basename\n        } )\n            .then( function () {\n                //projectService.applyTagsOnProject('multi','ProjectServiceTest2',[{id:'t1', name:'alma1'},{id:'t2', name:'korte2'}]);\n                //projectService.deleteProject('multi', 'ProjectServiceTest1').then(function() {\n                projectService.getAvailableProjects( 'multi' )\n                    .then( function ( names ) {\n                        if ( names ) {\n                            var createProjectPromises = [];\n\n                            for ( index = 0; index < testProjects.length; index++ ) {\n                                // If testProject doesn't exist\n                                if ( names.indexOf( testProjects[ index ].projectName ) === -1 ) {\n                                    createProjectPromises.push( projectService.createProject( 'multi',\n                                        testProjects[ index ].projectName,\n                                        testProjects[ index ].projectInfo ) );\n                                }\n                            }\n\n                            // Waiting for the createProject promise\n                            if ( createProjectPromises.length > 0 ) {\n                                $q.all( createProjectPromises )\n                                    .then( function () {\n                                        deferred.resolve();\n                                    } );\n                            } else {\n                                deferred.resolve();\n                            }\n                        }\n                    } );\n                //});\n            } );\n\n        return deferred.promise;\n    };\n};"]}